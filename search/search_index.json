{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"epinterface","text":"<p>This is a repository for dynamically generating energy models within Python, relying on Archetypal and Eppy for most of its functionality.</p>"},{"location":"modules/","title":"Modules","text":"<p>Interface for EnergyPlus IDF objects.</p> <p>Geometry utilities for the UBEM construction.</p> <p>A module for parsing climate studio data and generating EnergyPlus objects.</p> <p>A module for building the energy model using the Climate Studio API.</p>"},{"location":"modules/#epinterface.interface.AirGapMaterial","title":"<code>AirGapMaterial</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>AirGapMaterial object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class AirGapMaterial(BaseObj, extra=\"ignore\"):\n    \"\"\"AirGapMaterial object.\"\"\"\n\n    key: ClassVar[str] = \"MATERIAL:AIRGAP\"\n    Name: str\n    Thermal_Resistance: float\n</code></pre>"},{"location":"modules/#epinterface.interface.BaseMaterial","title":"<code>BaseMaterial</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A base material object for storing material definitions.</p> <p>Note that this is not an EnergyPlus object, but a base class for creating new material objects which can be turned into EP objects once assigned thicknesses.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class BaseMaterial(BaseModel, extra=\"ignore\", populate_by_name=True):\n    \"\"\"A base material object for storing material definitions.\n\n    Note that this is not an EnergyPlus object, but a base class for creating new\n    material objects which can be turned into EP objects once assigned thicknesses.\n    \"\"\"\n\n    Name: str\n    Roughness: str\n    Conductivity: float = Field(..., ge=0, validation_alias=\"Conductivity [W/m.K]\")\n    Density: float = Field(..., ge=0, validation_alias=\"Density [kg/m3]\")\n    Specific_Heat: float = Field(..., ge=0, validation_alias=\"SpecificHeat [J/kg.K]\")\n    Thermal_Absorptance: float | None = Field(\n        default=None, validation_alias=\"ThermalAbsorptance [0-1]\", ge=0, le=1\n    )\n    Solar_Absorptance: float | None = Field(\n        default=None, validation_alias=\"SolarAbsorptance [0-1]\", ge=0, le=1\n    )\n    Visible_Absorptance: float | None = Field(\n        default=None, validation_alias=\"VisibleAbsorptance [0-1]\", ge=0, le=1\n    )\n\n    def as_layer(self, thickness: float):\n        \"\"\"Create a new material object with a given thickness.\n\n        Args:\n            thickness (float): The thickness of the material.\n\n        Returns:\n            mat (Material): The new material object with the given thickness.\n        \"\"\"\n        name = f\"{self.Name}_{thickness}m\"\n        return Material(\n            Name=name, Thickness=thickness, **self.model_dump(exclude={\"Name\"})\n        )\n</code></pre>"},{"location":"modules/#epinterface.interface.BaseMaterial.as_layer","title":"<code>as_layer(thickness)</code>","text":"<p>Create a new material object with a given thickness.</p> <p>Parameters:</p> Name Type Description Default <code>thickness</code> <code>float</code> <p>The thickness of the material.</p> required <p>Returns:</p> Name Type Description <code>mat</code> <code>Material</code> <p>The new material object with the given thickness.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>def as_layer(self, thickness: float):\n    \"\"\"Create a new material object with a given thickness.\n\n    Args:\n        thickness (float): The thickness of the material.\n\n    Returns:\n        mat (Material): The new material object with the given thickness.\n    \"\"\"\n    name = f\"{self.Name}_{thickness}m\"\n    return Material(\n        Name=name, Thickness=thickness, **self.model_dump(exclude={\"Name\"})\n    )\n</code></pre>"},{"location":"modules/#epinterface.interface.BaseObj","title":"<code>BaseObj</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for EnergyPlus IDF objects.</p> <p>The class should be inherited by all EnergyPlus IDF objects. It provides methods to add and extract objects from an IDF object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class BaseObj(BaseModel):\n    \"\"\"Base class for EnergyPlus IDF objects.\n\n    The class should be inherited by all EnergyPlus IDF objects. It provides\n    methods to add and extract objects from an IDF object.\n    \"\"\"\n\n    key: ClassVar[str]\n\n    def add(self, idf: IDF):\n        \"\"\"Add the object to the IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the object to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        idf.newidfobject(self.key, **self.model_dump())\n        return idf\n\n    @classmethod\n    def extract(cls, idf: IDF):\n        \"\"\"Extract objects from an IDF object.\n\n        Args:\n            idf (IDF): The IDF object to extract objects from.\n\n        Returns:\n            objs (list[BaseObj]): A list of objects extracted from the IDF object.\n        \"\"\"\n        objs = idf.idfobjects[cls.key]\n        try:\n            return [cls(**obj) for obj in objs]\n        except ValidationError:\n            return [cls(**obj.to_dict()) for obj in objs]\n</code></pre>"},{"location":"modules/#epinterface.interface.BaseObj.add","title":"<code>add(idf)</code>","text":"<p>Add the object to the IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the object to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>def add(self, idf: IDF):\n    \"\"\"Add the object to the IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the object to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    idf.newidfobject(self.key, **self.model_dump())\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.interface.BaseObj.extract","title":"<code>extract(idf)</code>  <code>classmethod</code>","text":"<p>Extract objects from an IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to extract objects from.</p> required <p>Returns:</p> Name Type Description <code>objs</code> <code>list[BaseObj]</code> <p>A list of objects extracted from the IDF object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>@classmethod\ndef extract(cls, idf: IDF):\n    \"\"\"Extract objects from an IDF object.\n\n    Args:\n        idf (IDF): The IDF object to extract objects from.\n\n    Returns:\n        objs (list[BaseObj]): A list of objects extracted from the IDF object.\n    \"\"\"\n    objs = idf.idfobjects[cls.key]\n    try:\n        return [cls(**obj) for obj in objs]\n    except ValidationError:\n        return [cls(**obj.to_dict()) for obj in objs]\n</code></pre>"},{"location":"modules/#epinterface.interface.Construction","title":"<code>Construction</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>Construction object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class Construction(BaseObj, extra=\"ignore\"):\n    \"\"\"Construction object.\"\"\"\n\n    key: ClassVar[str] = \"CONSTRUCTION\"\n    name: str\n    layers: Sequence[Material | AirGapMaterial | SimpleGlazingMaterial | NoMassMaterial]\n\n    @property\n    def r_value(self):\n        \"\"\"Return the R-value of the construction.\n\n        Computed using the formula: R = sum(thickness_i / conductivity_i)\n\n        Returns:\n            r (float): The R-value of the construction (units: m^2.K/W).\n        \"\"\"\n        return (\n            sum([layer.r for layer in self.layers if isinstance(layer, Material)])\n            + sum([\n                layer.Thermal_Resistance\n                for layer in self.layers\n                if isinstance(layer, AirGapMaterial)\n            ])\n            + sum([\n                layer.Thermal_Resistance\n                for layer in self.layers\n                if isinstance(layer, NoMassMaterial)\n            ])\n            + sum([\n                1 / layer.UFactor\n                for layer in self.layers\n                if isinstance(layer, SimpleGlazingMaterial)\n            ])\n        )\n\n    @classmethod\n    def extract(cls, idf: IDF):\n        \"\"\"Extract objects from an IDF object.\n\n        Args:\n            idf (IDF): The IDF object to extract objects from.\n\n        Returns:\n            constructions (list[Construction]): A list of objects extracted from the IDF object.\n        \"\"\"\n        constructions = idf.idfobjects[\"CONSTRUCTION\"]\n        res: list[Construction] = []\n        for construction in constructions:\n            const_dict = construction.to_dict()\n            layer_names = [\n                const_dict[key]\n                for key in [\n                    \"Outside_Layer\",\n                    \"Layer_2\",\n                    \"Layer_3\",\n                    \"Layer_4\",\n                    \"Layer_5\",\n                    \"Layer_6\",\n                    \"Layer_7\",\n                    \"Layer_8\",\n                    \"Layer_9\",\n                    \"Layer_10\",\n                ]\n                if key in const_dict\n            ]\n\n            layer_names = [n for n in layer_names if n != \"\" and n]\n            material_defs = [\n                idf.getobject(\"MATERIAL\", name) for name in layer_names\n            ]  # TODO: handle air layers\n            airgap_material_defs = [\n                idf.getobject(\"MATERIAL:AIRGAP\", name) for name in layer_names\n            ]\n            simple_glazing_material_defs = [\n                idf.getobject(\"WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM\", name)\n                for name in layer_names\n            ]\n            no_mass_material_defs = [\n                idf.getobject(\"MATERIAL:NOMASS\", name) for name in layer_names\n            ]\n            materials = [Material(**m.to_dict()) if m else None for m in material_defs]\n            airgap_materials = [\n                AirGapMaterial(**m.to_dict()) if m else None\n                for m in airgap_material_defs\n            ]\n            simple_glazing_materials = [\n                SimpleGlazingMaterial(**m.to_dict()) if m else None\n                for m in simple_glazing_material_defs\n            ]\n            nomass_materials = [\n                NoMassMaterial(**m.to_dict()) if m else None\n                for m in no_mass_material_defs\n            ]\n\n            layers = [\n                m if m else (n if n else (o if o else p))\n                for m, n, o, p in zip(\n                    materials,\n                    airgap_materials,\n                    simple_glazing_materials,\n                    nomass_materials,\n                    strict=False,\n                )\n            ]\n\n            valid_layers = [layer for layer in layers if layer is not None]\n            if len(valid_layers) != len(layers):\n                logger.warning(\n                    f\"Construction {construction.Name} has missing layers. \"\n                    f\"Expected {len(layers)} layers, got {len(valid_layers)}.\"\n                    f\"Skipping construction extraction.\"\n                )\n                continue\n            construction = cls(name=construction.Name, layers=valid_layers)\n            res.append(construction)\n        return res\n\n    def add(self, idf: IDF):\n        \"\"\"Add the object to the IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the object to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        for layer in self.layers:\n            idf = layer.add(idf)\n        idf.newidfobject(\n            self.key,\n            Name=self.name,\n            **{\n                (f\"Layer_{i + 1}\" if i != 0 else \"Outside_Layer\"): layer.Name\n                for i, layer in enumerate(self.layers)\n            },\n        )\n        return idf\n</code></pre>"},{"location":"modules/#epinterface.interface.Construction.r_value","title":"<code>r_value</code>  <code>property</code>","text":"<p>Return the R-value of the construction.</p> <p>Computed using the formula: R = sum(thickness_i / conductivity_i)</p> <p>Returns:</p> Name Type Description <code>r</code> <code>float</code> <p>The R-value of the construction (units: m^2.K/W).</p>"},{"location":"modules/#epinterface.interface.Construction.add","title":"<code>add(idf)</code>","text":"<p>Add the object to the IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the object to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>def add(self, idf: IDF):\n    \"\"\"Add the object to the IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the object to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    for layer in self.layers:\n        idf = layer.add(idf)\n    idf.newidfobject(\n        self.key,\n        Name=self.name,\n        **{\n            (f\"Layer_{i + 1}\" if i != 0 else \"Outside_Layer\"): layer.Name\n            for i, layer in enumerate(self.layers)\n        },\n    )\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.interface.Construction.extract","title":"<code>extract(idf)</code>  <code>classmethod</code>","text":"<p>Extract objects from an IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to extract objects from.</p> required <p>Returns:</p> Name Type Description <code>constructions</code> <code>list[Construction]</code> <p>A list of objects extracted from the IDF object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>@classmethod\ndef extract(cls, idf: IDF):\n    \"\"\"Extract objects from an IDF object.\n\n    Args:\n        idf (IDF): The IDF object to extract objects from.\n\n    Returns:\n        constructions (list[Construction]): A list of objects extracted from the IDF object.\n    \"\"\"\n    constructions = idf.idfobjects[\"CONSTRUCTION\"]\n    res: list[Construction] = []\n    for construction in constructions:\n        const_dict = construction.to_dict()\n        layer_names = [\n            const_dict[key]\n            for key in [\n                \"Outside_Layer\",\n                \"Layer_2\",\n                \"Layer_3\",\n                \"Layer_4\",\n                \"Layer_5\",\n                \"Layer_6\",\n                \"Layer_7\",\n                \"Layer_8\",\n                \"Layer_9\",\n                \"Layer_10\",\n            ]\n            if key in const_dict\n        ]\n\n        layer_names = [n for n in layer_names if n != \"\" and n]\n        material_defs = [\n            idf.getobject(\"MATERIAL\", name) for name in layer_names\n        ]  # TODO: handle air layers\n        airgap_material_defs = [\n            idf.getobject(\"MATERIAL:AIRGAP\", name) for name in layer_names\n        ]\n        simple_glazing_material_defs = [\n            idf.getobject(\"WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM\", name)\n            for name in layer_names\n        ]\n        no_mass_material_defs = [\n            idf.getobject(\"MATERIAL:NOMASS\", name) for name in layer_names\n        ]\n        materials = [Material(**m.to_dict()) if m else None for m in material_defs]\n        airgap_materials = [\n            AirGapMaterial(**m.to_dict()) if m else None\n            for m in airgap_material_defs\n        ]\n        simple_glazing_materials = [\n            SimpleGlazingMaterial(**m.to_dict()) if m else None\n            for m in simple_glazing_material_defs\n        ]\n        nomass_materials = [\n            NoMassMaterial(**m.to_dict()) if m else None\n            for m in no_mass_material_defs\n        ]\n\n        layers = [\n            m if m else (n if n else (o if o else p))\n            for m, n, o, p in zip(\n                materials,\n                airgap_materials,\n                simple_glazing_materials,\n                nomass_materials,\n                strict=False,\n            )\n        ]\n\n        valid_layers = [layer for layer in layers if layer is not None]\n        if len(valid_layers) != len(layers):\n            logger.warning(\n                f\"Construction {construction.Name} has missing layers. \"\n                f\"Expected {len(layers)} layers, got {len(valid_layers)}.\"\n                f\"Skipping construction extraction.\"\n            )\n            continue\n        construction = cls(name=construction.Name, layers=valid_layers)\n        res.append(construction)\n    return res\n</code></pre>"},{"location":"modules/#epinterface.interface.DefaultMaterialLibrary","title":"<code>DefaultMaterialLibrary</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Default material library for storing some common material defs.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class DefaultMaterialLibrary(BaseModel):\n    \"\"\"Default material library for storing some common material defs.\"\"\"\n\n    wood: BaseMaterial = wood\n    gypsum: BaseMaterial = gypsum\n    drywall: BaseMaterial = drywall\n    osb: BaseMaterial = osb\n    concrete: BaseMaterial = concrete\n    insulation: BaseMaterial = insulation\n    stucco: BaseMaterial = stucco\n</code></pre>"},{"location":"modules/#epinterface.interface.ElectricEquipment","title":"<code>ElectricEquipment</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>ElectricEquipment object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class ElectricEquipment(BaseObj, extra=\"ignore\"):\n    \"\"\"ElectricEquipment object.\"\"\"\n\n    key: ClassVar[str] = \"ELECTRICEQUIPMENT\"\n    Name: str\n    Zone_or_ZoneList_Name: str\n    Schedule_Name: str\n    Design_Level_Calculation_Method: DesignLevelCalculationMethodType = \"Watts/Area\"\n    Design_Level: float | None = None\n    Watts_per_Zone_Floor_Area: float | None = None\n    Watts_per_Person: float | None = None\n    Fraction_Latent: float = 0.00\n    Fraction_Radiant: float = 0.2\n    Fraction_Lost: float = 0\n    EndUse_Subcategory: str | None = None\n</code></pre>"},{"location":"modules/#epinterface.interface.HVACTemplateThermostat","title":"<code>HVACTemplateThermostat</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>HVACTemplateThermostat object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class HVACTemplateThermostat(BaseModel):\n    \"\"\"HVACTemplateThermostat object.\"\"\"\n\n    Name: str\n    Heating_Setpoint_Schedule_Name: str | None = None\n    Constant_Heating_Setpoint: float | None = 21\n    Cooling_Setpoint_Schedule_Name: str | None = None\n    Constant_Cooling_Setpoint: float | None = 24\n\n    def add(self, idf: IDF):\n        \"\"\"Add the object to the IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the object to.\n\n        Returns:\n            idf (IDF): The updated IDF object\n        \"\"\"\n        idf.newidfobject(\"HVACTEMPLATE:THERMOSTAT\", **self.model_dump())\n        return idf\n</code></pre>"},{"location":"modules/#epinterface.interface.HVACTemplateThermostat.add","title":"<code>add(idf)</code>","text":"<p>Add the object to the IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the object to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object</p> Source code in <code>epinterface\\interface.py</code> <pre><code>def add(self, idf: IDF):\n    \"\"\"Add the object to the IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the object to.\n\n    Returns:\n        idf (IDF): The updated IDF object\n    \"\"\"\n    idf.newidfobject(\"HVACTEMPLATE:THERMOSTAT\", **self.model_dump())\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.interface.HVACTemplateZoneIdealLoadsAirSystem","title":"<code>HVACTemplateZoneIdealLoadsAirSystem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>HVACTemplateZoneIdealLoadsAirSystem object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class HVACTemplateZoneIdealLoadsAirSystem(BaseModel):\n    \"\"\"HVACTemplateZoneIdealLoadsAirSystem object.\"\"\"\n\n    Zone_Name: str\n    Template_Thermostat_Name: str\n    System_Availability_Schedule_Name: str | None = None\n    Heating_Availability_Schedule_Name: str | None = None\n    Cooling_Availability_Schedule_Name: str | None = None\n    Maximum_Heating_Supply_Air_Temperature: float = 30\n    Minimum_Cooling_Supply_Air_Temperature: float = 18\n    Maximum_Heating_Supply_Air_Humidity_Ratio: float = 0.0156\n    Minimum_Cooling_Supply_Air_Humidity_Ratio: float = 0.0077\n    Heating_Limit: IdealLoadsLimitType = \"NoLimit\"\n    Maximum_Heating_Air_Flow_Rate: float | None = None\n    Maximum_Sensible_Heating_Capacity: float | None = None\n    Cooling_Limit: IdealLoadsLimitType = \"NoLimit\"\n    Maximum_Cooling_Air_Flow_Rate: float | None = None\n    Maximum_Total_Cooling_Capacity: float | None = None\n    Dehumidification_Control_Type: DehumidificationControlTypeType = \"None\"\n    Cooling_Sensible_Heat_Ratio: float = 0.7\n    Dehumidification_Setpoint: float = 60\n    Humidification_Control_Type: HumidificationControlTypeType = \"None\"\n    Humidification_Setpoint: float = 30\n    Outdoor_Air_Method: OutdoorAirMethodType = \"None\"\n    Outdoor_Air_Flow_Rate_per_Person: float = 0.00944\n    Outdoor_Air_Flow_Rate_per_Zone_Floor_Area: float = 0.00025\n    Outdoor_Air_Flow_Rate_per_Zone: float = 0.0\n    # Design_Specification_Outdoor_Air_Object_Name: Optional[str] = None\n    Demand_Controlled_Ventilation_Type: DemandControlledVentilationTypeType = \"None\"\n    Outdoor_Air_Economizer_Type: OutdoorAirEconomizerTypeType = \"NoEconomizer\"\n    Heat_Recovery_Type: HeatRecoveryTypeType = \"None\"\n    Sensible_Heat_Recovery_Effectiveness: float = 0.7\n    Latent_Heat_Recovery_Effectiveness: float = 0.65\n\n    def add(self, idf: IDF):\n        \"\"\"Add the object to the IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the object to.\n\n        Returns:\n            idf (IDF): The updated IDF object\n        \"\"\"\n        idf.newidfobject(\"HVACTEMPLATE:ZONE:IDEALLOADSAIRSYSTEM\", **self.model_dump())\n        return idf\n</code></pre>"},{"location":"modules/#epinterface.interface.HVACTemplateZoneIdealLoadsAirSystem.add","title":"<code>add(idf)</code>","text":"<p>Add the object to the IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the object to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object</p> Source code in <code>epinterface\\interface.py</code> <pre><code>def add(self, idf: IDF):\n    \"\"\"Add the object to the IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the object to.\n\n    Returns:\n        idf (IDF): The updated IDF object\n    \"\"\"\n    idf.newidfobject(\"HVACTEMPLATE:ZONE:IDEALLOADSAIRSYSTEM\", **self.model_dump())\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.interface.Lights","title":"<code>Lights</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>Lights object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class Lights(BaseObj, extra=\"ignore\"):\n    \"\"\"Lights object.\"\"\"\n\n    key: ClassVar[str] = \"LIGHTS\"\n    Name: str\n    Zone_or_ZoneList_Name: str\n    Schedule_Name: str\n    Design_Level_Calculation_Method: DesignLevelCalculationMethodType = \"Watts/Area\"\n    Lighting_Level: float | None = None\n    Watts_per_Zone_Floor_Area: float | None = None\n    Watts_per_Person: float | None = None\n    Return_Air_Fraction: float = 0\n    Fraction_Radiant: float = 0.42\n    Fraction_Visible: float = 0.18\n    Fraction_Replaceable: float | None = 1\n    EndUse_Subcategory: str | None = None\n</code></pre>"},{"location":"modules/#epinterface.interface.Material","title":"<code>Material</code>","text":"<p>               Bases: <code>BaseObj</code>, <code>BaseMaterial</code></p> <p>Material object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class Material(BaseObj, BaseMaterial, extra=\"ignore\"):\n    \"\"\"Material object.\"\"\"\n\n    key: ClassVar[str] = \"MATERIAL\"\n    Name: str\n    Thickness: float\n\n    @field_validator(\"Thermal_Absorptance\", mode=\"before\")\n    def str_cast(cls, v):\n        \"\"\"Cast the value to a float if it is a string or empty.\n\n        Args:\n            v (Any): The value to cast.\n\n        Returns:\n            v (float): The casted value.\n        \"\"\"\n        if v == \"\" or v is None:\n            return None\n        return float(v)\n\n    @property\n    def r(self):\n        \"\"\"Return the R of the material.\"\"\"\n        return self.Thickness / self.Conductivity\n</code></pre>"},{"location":"modules/#epinterface.interface.Material.r","title":"<code>r</code>  <code>property</code>","text":"<p>Return the R of the material.</p>"},{"location":"modules/#epinterface.interface.Material.str_cast","title":"<code>str_cast(v)</code>","text":"<p>Cast the value to a float if it is a string or empty.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Any</code> <p>The value to cast.</p> required <p>Returns:</p> Name Type Description <code>v</code> <code>float</code> <p>The casted value.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>@field_validator(\"Thermal_Absorptance\", mode=\"before\")\ndef str_cast(cls, v):\n    \"\"\"Cast the value to a float if it is a string or empty.\n\n    Args:\n        v (Any): The value to cast.\n\n    Returns:\n        v (float): The casted value.\n    \"\"\"\n    if v == \"\" or v is None:\n        return None\n    return float(v)\n</code></pre>"},{"location":"modules/#epinterface.interface.NoMassMaterial","title":"<code>NoMassMaterial</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>NoMassMaterial object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class NoMassMaterial(BaseObj, extra=\"ignore\"):\n    \"\"\"NoMassMaterial object.\"\"\"\n\n    key: ClassVar[str] = \"MATERIAL:NOMASS\"\n    Name: str\n    Roughness: str\n    Thermal_Resistance: float\n</code></pre>"},{"location":"modules/#epinterface.interface.People","title":"<code>People</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>People object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class People(BaseObj, extra=\"ignore\"):\n    \"\"\"People object.\"\"\"\n\n    key: ClassVar[str] = \"PEOPLE\"\n    Name: str\n    Zone_or_ZoneList_Name: str\n    Number_of_People_Schedule_Name: str\n    Number_of_People_Calculation_Method: NumberOfPeopleCalculationMethodType\n    Number_of_People: float | None = None\n    People_per_Floor_Area: float | None = None\n    Floor_Area_per_Person: float | None = None\n    Fraction_Radiant: float = 0.3\n    Sensible_Heat_Fraction: float | Literal[\"autocalculate\"] = \"autocalculate\"\n    Activity_Level_Schedule_Name: str\n    # Carbon_Dioxide_Generation_Rate: Optional[float] = None\n    Enable_ASHRAE_55_Comfort_Warnings: Literal[\"Yes\", \"No\"] = \"No\"\n</code></pre>"},{"location":"modules/#epinterface.interface.RunPeriod","title":"<code>RunPeriod</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>RunPeriod object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class RunPeriod(BaseObj, extra=\"ignore\"):\n    \"\"\"RunPeriod object.\"\"\"\n\n    key: ClassVar[str] = \"RUNPERIOD\"\n    Name: str\n    Begin_Month: int\n    Begin_Day_of_Month: int\n    Begin_Year: int | None = None\n    End_Month: int\n    End_Day_of_Month: int\n    End_Year: int | None = None\n    Day_of_Week_for_Start_Day: Literal[\n        \"Sunday\",\n        \"Monday\",\n        \"Tuesday\",\n        \"Wednesday\",\n        \"Thursday\",\n        \"Friday\",\n        \"Saturday\",\n    ] = \"Sunday\"\n    Use_Weather_File_Daylight_Saving_Period: Literal[\"Yes\", \"No\"] = \"No\"\n    Use_Weather_File_Holidays_and_Special_Days: Literal[\"Yes\", \"No\"] = \"No\"\n    Apply_Weekend_Holiday_Rule: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Use_Weather_File_Rain_Indicators: Literal[\"Yes\", \"No\"] = \"No\"\n    Use_Weather_File_Snow_Indicators: Literal[\"Yes\", \"No\"] = \"No\"\n</code></pre>"},{"location":"modules/#epinterface.interface.ScheduleTypeLimits","title":"<code>ScheduleTypeLimits</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>ScheduleTypeLimits object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class ScheduleTypeLimits(BaseObj, extra=\"ignore\"):\n    \"\"\"ScheduleTypeLimits object.\"\"\"\n\n    key: ClassVar[str] = \"SCHEDULETYPELIMITS\"\n    Name: str\n    Lower_Limit_Value: float | None = None\n    Upper_Limit_Value: float | None = None\n    Numeric_Type: Literal[\"Continuous\", \"Discrete\"] | None = None\n    Unit_Type: (\n        Literal[\n            \"Dimensionless\",\n            \"Temperature\",\n            \"DeltaTemperature\",\n            \"PrecipitationRate\",\n            \"Angle\",\n            \"ConvectionCoefficient\",\n            \"ActivityLevel\",\n            \"Velocity\",\n            \"Capacity\",\n            \"Power\",\n            \"Availability\",\n            \"Percent\",\n            \"Control\",\n            \"Mode\",\n        ]\n        | None\n    ) = None\n</code></pre>"},{"location":"modules/#epinterface.interface.SimpleGlazingMaterial","title":"<code>SimpleGlazingMaterial</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>SimpleGlazingMaterial object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class SimpleGlazingMaterial(BaseObj, extra=\"ignore\"):\n    \"\"\"SimpleGlazingMaterial object.\"\"\"\n\n    key: ClassVar[str] = \"WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM\"\n    Name: str\n    UFactor: float\n    Solar_Heat_Gain_Coefficient: float\n    Visible_Transmittance: float\n</code></pre>"},{"location":"modules/#epinterface.interface.SimulationControl","title":"<code>SimulationControl</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>SimulationControl object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class SimulationControl(BaseObj, extra=\"ignore\"):\n    \"\"\"SimulationControl object.\"\"\"\n\n    key: ClassVar[str] = \"SIMULATIONCONTROL\"\n    Do_Zone_Sizing_Calculation: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Do_System_Sizing_Calculation: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Do_Plant_Sizing_Calculation: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Run_Simulation_for_Sizing_Periods: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Run_Simulation_for_Weather_File_Run_Periods: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Do_HVAC_Sizing_Simulation_for_Sizing_Periods: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Maximum_Number_of_HVAC_Sizing_Simulation_Passes: int = 1\n</code></pre>"},{"location":"modules/#epinterface.interface.Timestep","title":"<code>Timestep</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>Timestep object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class Timestep(BaseObj, extra=\"ignore\"):\n    \"\"\"Timestep object.\"\"\"\n\n    key: ClassVar[str] = \"TIMESTEP\"\n    Number_of_Timesteps_per_Hour: int = 6\n</code></pre>"},{"location":"modules/#epinterface.interface.WaterUseEquipment","title":"<code>WaterUseEquipment</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>WaterUseEquipment object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class WaterUseEquipment(BaseObj, extra=\"ignore\"):\n    \"\"\"WaterUseEquipment object.\"\"\"\n\n    key: ClassVar[str] = \"WATERUSE:EQUIPMENT\"\n    Name: str\n    EndUse_Subcategory: str | None = None\n    Peak_Flow_Rate: float\n    Flow_Rate_Fraction_Schedule_Name: str | None = None\n    Target_Temperature_Schedule_Name: str | None = None\n    Hot_Water_Supply_Temperature_Schedule_Name: str | None = None\n    Cold_Water_Supply_Temperature_Schedule_Name: str | None = None\n    Zone_Name: str | None = None\n    Sensible_Fraction_Schedule_Name: str | None = None\n    Latent_Fraction_Schedule_Name: str | None = None\n</code></pre>"},{"location":"modules/#epinterface.interface.ZoneInfiltrationDesignFlowRate","title":"<code>ZoneInfiltrationDesignFlowRate</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>ZoneInfiltrationDesignFlowRate object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class ZoneInfiltrationDesignFlowRate(BaseObj, extra=\"ignore\"):\n    \"\"\"ZoneInfiltrationDesignFlowRate object.\"\"\"\n\n    key: ClassVar[str] = \"ZONEINFILTRATION:DESIGNFLOWRATE\"\n    Name: str\n    Zone_or_ZoneList_Name: str\n    Schedule_Name: str\n    Design_Flow_Rate_Calculation_Method: InfDesignFlowRateCalculationMethodType\n    Design_Flow_Rate: float | None = None\n    Flow_Rate_per_Floor_Area: float | None = None\n    Flow_Rate_per_Exterior_Surface_Area: float | None = None\n    Air_Changes_per_Hour: float | None = None\n    Constant_Term_Coefficient: float = 0.606\n    Temperature_Term_Coefficient: float = 3.6359996e-2\n    Velocity_Term_Coefficient: float = 0.117765\n    Velocity_Squared_Term_Coefficient: float = 0\n</code></pre>"},{"location":"modules/#epinterface.interface.ZoneList","title":"<code>ZoneList</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>ZoneList object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class ZoneList(BaseModel, extra=\"ignore\"):\n    \"\"\"ZoneList object.\"\"\"\n\n    Name: str\n    Names: list[str]\n\n    def add(self, idf: IDF):\n        \"\"\"Add the object to the IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the object to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        names = {\n            f\"Zone_{i + 1}_Name\": zone for i, zone in enumerate(self.Names) if zone\n        }\n        idf.newidfobject(\"ZONELIST\", Name=self.Name, **names)\n        return idf\n</code></pre>"},{"location":"modules/#epinterface.interface.ZoneList.add","title":"<code>add(idf)</code>","text":"<p>Add the object to the IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the object to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>def add(self, idf: IDF):\n    \"\"\"Add the object to the IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the object to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    names = {\n        f\"Zone_{i + 1}_Name\": zone for i, zone in enumerate(self.Names) if zone\n    }\n    idf.newidfobject(\"ZONELIST\", Name=self.Name, **names)\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.interface.add_default_schedules","title":"<code>add_default_schedules(idf)</code>","text":"<p>Helper to add default schedules to the IDF model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the schedules to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The IDF model with the added schedules.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>def add_default_schedules(idf: IDF) -&gt; IDF:\n    \"\"\"Helper to add default schedules to the IDF model.\n\n    Args:\n        idf (IDF): The IDF model to add the schedules to.\n\n    Returns:\n        IDF: The IDF model with the added schedules.\n    \"\"\"\n    # create constant scheds\n    always_on_schedule = Schedule.constant_schedule(Name=\"Always_On\", value=1)\n    always_off_schedule = Schedule.constant_schedule(Name=\"Always_Off\", value=0)\n    year, *_ = always_on_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n    year, *_ = always_off_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n\n    always_on_schedule = Schedule.constant_schedule(Name=\"Always On\", value=1)\n    always_off_schedule = Schedule.constant_schedule(Name=\"Always Off\", value=0)\n    year, *_ = always_on_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n    year, *_ = always_off_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n\n    always_on_schedule = Schedule.constant_schedule(Name=\"On\", value=1)\n    always_off_schedule = Schedule.constant_schedule(Name=\"Off\", value=0)\n    year, *_ = always_on_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n    year, *_ = always_off_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n\n    always_on_schedule = Schedule.constant_schedule(Name=\"AlwaysOn\", value=1)\n    always_off_schedule = Schedule.constant_schedule(Name=\"AlwaysOff\", value=0)\n    year, *_ = always_on_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n    year, *_ = always_off_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.interface.add_default_sim_controls","title":"<code>add_default_sim_controls(idf)</code>","text":"<p>Helper to add default simulation controls to the IDF model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the simulation controls to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The IDF model with the added simulation controls.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>def add_default_sim_controls(idf: IDF) -&gt; IDF:\n    \"\"\"Helper to add default simulation controls to the IDF model.\n\n    Args:\n        idf (IDF): The IDF model to add the simulation controls to.\n\n    Returns:\n        IDF: The IDF model with the added simulation controls.\n    \"\"\"\n    # Configure simulation\n    sim_control = SimulationControl(\n        Do_Zone_Sizing_Calculation=\"Yes\",\n        Do_System_Sizing_Calculation=\"Yes\",\n        Do_Plant_Sizing_Calculation=\"Yes\",\n        Run_Simulation_for_Sizing_Periods=\"Yes\",\n        Run_Simulation_for_Weather_File_Run_Periods=\"Yes\",\n        Do_HVAC_Sizing_Simulation_for_Sizing_Periods=\"Yes\",\n    )\n    sim_control.add(idf)\n\n    # Configure run period\n    run_period = RunPeriod(\n        Name=\"Year\",\n        Use_Weather_File_Daylight_Saving_Period=\"No\",\n        Use_Weather_File_Rain_Indicators=\"No\",\n        Use_Weather_File_Snow_Indicators=\"No\",\n        Use_Weather_File_Holidays_and_Special_Days=\"No\",\n        Begin_Month=1,\n        Begin_Day_of_Month=1,\n        End_Month=12,\n        End_Day_of_Month=31,\n        Day_of_Week_for_Start_Day=\"Sunday\",\n    )\n    run_period.add(idf)\n\n    # configure timestep\n    timestep = Timestep(\n        Number_of_Timesteps_per_Hour=6,\n    )\n    timestep.add(idf)\n\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.geometry.ShoeboxGeometry","title":"<code>ShoeboxGeometry</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A simple shoebox constructor for the IDF model.</p> <p>Can create gables, basements, and various zoning strategies.</p> Source code in <code>epinterface\\geometry.py</code> <pre><code>class ShoeboxGeometry(BaseModel):\n    \"\"\"A simple shoebox constructor for the IDF model.\n\n    Can create gables, basements, and various zoning strategies.\n    \"\"\"\n\n    x: float\n    y: float\n    w: float\n    d: float\n    h: float\n    num_stories: int = Field(\n        ...,\n        title=\"Number of stories\",\n        ge=1,\n        description=\"The number of stories in the building.\",\n    )\n    zoning: ZoningType = Field(\n        ...,\n        title=\"Zoning type\",\n        description=\"Whether to use core/perim or full-floor zones.\",\n    )\n    perim_depth: float = Field(\n        default=3,\n        title=\"Perimeter depth\",\n        description=\"Sets the perimeter depth when using core/perim zoning.  Ignored otherwise.\",\n    )\n    roof_height: float | None = Field(\n        default=None,\n        title=\"Roof gable height\",\n        description=\"The height of the roof gable.  If None, a flat roof is assumed.\",\n    )\n    basement_depth: float | None = Field(\n        default=None,\n        title=\"Basement depth\",\n        description=\"The depth of the basement.  If None, no basement is assumed.\",\n        ge=1.5,\n    )\n    wwr: float = Field(\n        default=0.15,\n        title=\"Window-to-wall ratio\",\n        description=\"The window-to-wall ratio of the building.\",\n        ge=0,\n        le=1,\n    )\n\n    @property\n    def basement_storey_count(self) -&gt; int:\n        \"\"\"Return the number of basement stories.\"\"\"\n        return 1 if self.basement_depth else 0\n\n    @property\n    def zones_height(self) -&gt; float:\n        \"\"\"Return the total height of the zones, excluding any gabling.\"\"\"\n        return self.h * (self.num_stories)\n\n    @property\n    def total_height_with_gabling(self) -&gt; float:\n        \"\"\"Return the total height of the building, including any gabling.\"\"\"\n        return self.zones_height + (self.roof_height or 0)\n\n    @property\n    def footprint_area(self) -&gt; float:\n        \"\"\"Return the total floor area of the building.\"\"\"\n        return self.w * self.d\n\n    @property\n    def total_living_area(self) -&gt; float:\n        \"\"\"Return the total living area of the building.\"\"\"\n        return self.footprint_area * self.num_stories\n\n    @property\n    def total_area(self) -&gt; float:\n        \"\"\"Return the total area of the building.\"\"\"\n        return (\n            self.total_living_area\n            + self.footprint_area * self.basement_storey_count\n            + self.footprint_area * (1 if self.roof_height else 0)\n        )\n\n    def add(self, idf: IDF) -&gt; IDF:\n        \"\"\"Constructs a simple shoebox geometry in the IDF model.\n\n        Takes advantage of the geomeppy methods to do so.\n\n        Can create gables, basements, and various zoning strategies.\n\n        Args:\n            idf: The IDF model to add the geometry to.\n\n        Returns:\n            The IDF model with the added geometry.\n        \"\"\"\n        lower_left_corner = (self.x, self.y)\n        lower_right_corner = (self.x + self.w, self.y)\n        upper_right_corner = (self.x + self.w, self.y + self.d)\n        upper_left_corner = (self.x, self.y + self.d)\n        bottom_plane = [\n            lower_left_corner,\n            lower_right_corner,\n            upper_right_corner,\n            upper_left_corner,\n        ]\n        idf.add_block(\n            name=\"shoebox\",\n            coordinates=bottom_plane,\n            height=self.zones_height,\n            num_stories=self.num_stories + self.basement_storey_count,\n            zoning=self.zoning,\n            perim_depth=self.perim_depth,\n            below_ground_stories=self.basement_storey_count,\n            below_ground_storey_height=self.basement_depth or 2.5,\n        )\n\n        if self.roof_height:\n            idf.newidfobject(\"ZONE\", Name=\"Attic\")\n            roof_centerline = self.x + self.w / 2\n            vert_0 = (self.x, self.y + self.d, self.zones_height)\n            vert_1 = (self.x, self.y, self.zones_height)\n            vert_2 = (roof_centerline, self.y, self.total_height_with_gabling)\n            vert_3 = (roof_centerline, self.y + self.d, self.total_height_with_gabling)\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"Gable1\",\n                Surface_Type=\"Roof\",\n                Number_of_Vertices=4,\n                View_Factor_to_Ground=0,\n                Vertex_1_Xcoordinate=vert_0[0],\n                Vertex_1_Ycoordinate=vert_0[1],\n                Vertex_1_Zcoordinate=vert_0[2],\n                Vertex_2_Xcoordinate=vert_1[0],\n                Vertex_2_Ycoordinate=vert_1[1],\n                Vertex_2_Zcoordinate=vert_1[2],\n                Vertex_3_Xcoordinate=vert_2[0],\n                Vertex_3_Ycoordinate=vert_2[1],\n                Vertex_3_Zcoordinate=vert_2[2],\n                Vertex_4_Xcoordinate=vert_3[0],\n                Vertex_4_Ycoordinate=vert_3[1],\n                Vertex_4_Zcoordinate=vert_3[2],\n                Zone_Name=\"Attic\",\n            )\n\n            vert_0 = (self.x + self.w, self.y, self.zones_height)\n            vert_1 = (self.x + self.w, self.y + self.d, self.zones_height)\n            vert_2 = (roof_centerline, self.y + self.d, self.total_height_with_gabling)\n            vert_3 = (roof_centerline, self.y, self.total_height_with_gabling)\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"Gable2\",\n                Surface_Type=\"Roof\",\n                Number_of_Vertices=4,\n                View_Factor_to_Ground=0,\n                Vertex_1_Xcoordinate=vert_0[0],\n                Vertex_1_Ycoordinate=vert_0[1],\n                Vertex_1_Zcoordinate=vert_0[2],\n                Vertex_2_Xcoordinate=vert_1[0],\n                Vertex_2_Ycoordinate=vert_1[1],\n                Vertex_2_Zcoordinate=vert_1[2],\n                Vertex_3_Xcoordinate=vert_2[0],\n                Vertex_3_Ycoordinate=vert_2[1],\n                Vertex_3_Zcoordinate=vert_2[2],\n                Vertex_4_Xcoordinate=vert_3[0],\n                Vertex_4_Ycoordinate=vert_3[1],\n                Vertex_4_Zcoordinate=vert_3[2],\n                Zone_Name=\"Attic\",\n            )\n\n            # make triangular endcaps\n            vert_0 = (self.x, self.y, self.zones_height)\n            vert_1 = (self.x + self.w, self.y, self.zones_height)\n            vert_2 = (roof_centerline, self.y, self.total_height_with_gabling)\n\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"Endcap1\",\n                Surface_Type=\"Wall\",\n                Number_of_Vertices=3,\n                Vertex_1_Xcoordinate=vert_0[0],\n                Vertex_1_Ycoordinate=vert_0[1],\n                Vertex_1_Zcoordinate=vert_0[2],\n                Vertex_2_Xcoordinate=vert_1[0],\n                Vertex_2_Ycoordinate=vert_1[1],\n                Vertex_2_Zcoordinate=vert_1[2],\n                Vertex_3_Xcoordinate=vert_2[0],\n                Vertex_3_Ycoordinate=vert_2[1],\n                Vertex_3_Zcoordinate=vert_2[2],\n                Zone_Name=\"Attic\",\n            )\n\n            vert_0 = (self.x + self.w, self.y + self.d, self.zones_height)\n            vert_1 = (self.x, self.y + self.d, self.zones_height)\n            vert_2 = (roof_centerline, self.y + self.d, self.total_height_with_gabling)\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"Endcap2\",\n                Surface_Type=\"Wall\",\n                Number_of_Vertices=3,\n                Vertex_1_Xcoordinate=vert_0[0],\n                Vertex_1_Ycoordinate=vert_0[1],\n                Vertex_1_Zcoordinate=vert_0[2],\n                Vertex_2_Xcoordinate=vert_1[0],\n                Vertex_2_Ycoordinate=vert_1[1],\n                Vertex_2_Zcoordinate=vert_1[2],\n                Vertex_3_Xcoordinate=vert_2[0],\n                Vertex_3_Ycoordinate=vert_2[1],\n                Vertex_3_Zcoordinate=vert_2[2],\n                Zone_Name=\"Attic\",\n            )\n\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"attic_bottom_plane\",\n                Surface_Type=\"Floor\",\n                Number_of_Vertices=4,\n                Vertex_1_Xcoordinate=self.x + self.w,\n                Vertex_1_Ycoordinate=self.y,\n                Vertex_1_Zcoordinate=self.zones_height,\n                Vertex_2_Xcoordinate=self.x,\n                Vertex_2_Ycoordinate=self.y,\n                Vertex_2_Zcoordinate=self.zones_height,\n                Vertex_3_Xcoordinate=self.x,\n                Vertex_3_Ycoordinate=self.y + self.d,\n                Vertex_3_Zcoordinate=self.zones_height,\n                Vertex_4_Xcoordinate=self.x + self.w,\n                Vertex_4_Ycoordinate=self.y + self.d,\n                Vertex_4_Zcoordinate=self.zones_height,\n                Zone_Name=\"Attic\",\n            )\n\n        idf.intersect_match()\n        idf.set_default_constructions()\n\n        # Handle Windows\n        window_walls = [\n            w\n            for w in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]\n            if w.Outside_Boundary_Condition.lower() == \"outdoors\"\n            and \"attic\" not in w.Zone_Name.lower()\n            and not w.Zone_Name.lower().endswith(\"-1\")\n            and w.Surface_Type.lower() == \"wall\"\n        ]\n        idf.set_wwr(\n            wwr=self.wwr,\n            construction=\"Project External Window\",\n            force=True,\n            surfaces=window_walls,\n        )\n        return idf\n</code></pre>"},{"location":"modules/#epinterface.geometry.ShoeboxGeometry.basement_storey_count","title":"<code>basement_storey_count: int</code>  <code>property</code>","text":"<p>Return the number of basement stories.</p>"},{"location":"modules/#epinterface.geometry.ShoeboxGeometry.footprint_area","title":"<code>footprint_area: float</code>  <code>property</code>","text":"<p>Return the total floor area of the building.</p>"},{"location":"modules/#epinterface.geometry.ShoeboxGeometry.total_area","title":"<code>total_area: float</code>  <code>property</code>","text":"<p>Return the total area of the building.</p>"},{"location":"modules/#epinterface.geometry.ShoeboxGeometry.total_height_with_gabling","title":"<code>total_height_with_gabling: float</code>  <code>property</code>","text":"<p>Return the total height of the building, including any gabling.</p>"},{"location":"modules/#epinterface.geometry.ShoeboxGeometry.total_living_area","title":"<code>total_living_area: float</code>  <code>property</code>","text":"<p>Return the total living area of the building.</p>"},{"location":"modules/#epinterface.geometry.ShoeboxGeometry.zones_height","title":"<code>zones_height: float</code>  <code>property</code>","text":"<p>Return the total height of the zones, excluding any gabling.</p>"},{"location":"modules/#epinterface.geometry.ShoeboxGeometry.add","title":"<code>add(idf)</code>","text":"<p>Constructs a simple shoebox geometry in the IDF model.</p> <p>Takes advantage of the geomeppy methods to do so.</p> <p>Can create gables, basements, and various zoning strategies.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the geometry to.</p> required <p>Returns:</p> Type Description <code>IDF</code> <p>The IDF model with the added geometry.</p> Source code in <code>epinterface\\geometry.py</code> <pre><code>def add(self, idf: IDF) -&gt; IDF:\n    \"\"\"Constructs a simple shoebox geometry in the IDF model.\n\n    Takes advantage of the geomeppy methods to do so.\n\n    Can create gables, basements, and various zoning strategies.\n\n    Args:\n        idf: The IDF model to add the geometry to.\n\n    Returns:\n        The IDF model with the added geometry.\n    \"\"\"\n    lower_left_corner = (self.x, self.y)\n    lower_right_corner = (self.x + self.w, self.y)\n    upper_right_corner = (self.x + self.w, self.y + self.d)\n    upper_left_corner = (self.x, self.y + self.d)\n    bottom_plane = [\n        lower_left_corner,\n        lower_right_corner,\n        upper_right_corner,\n        upper_left_corner,\n    ]\n    idf.add_block(\n        name=\"shoebox\",\n        coordinates=bottom_plane,\n        height=self.zones_height,\n        num_stories=self.num_stories + self.basement_storey_count,\n        zoning=self.zoning,\n        perim_depth=self.perim_depth,\n        below_ground_stories=self.basement_storey_count,\n        below_ground_storey_height=self.basement_depth or 2.5,\n    )\n\n    if self.roof_height:\n        idf.newidfobject(\"ZONE\", Name=\"Attic\")\n        roof_centerline = self.x + self.w / 2\n        vert_0 = (self.x, self.y + self.d, self.zones_height)\n        vert_1 = (self.x, self.y, self.zones_height)\n        vert_2 = (roof_centerline, self.y, self.total_height_with_gabling)\n        vert_3 = (roof_centerline, self.y + self.d, self.total_height_with_gabling)\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"Gable1\",\n            Surface_Type=\"Roof\",\n            Number_of_Vertices=4,\n            View_Factor_to_Ground=0,\n            Vertex_1_Xcoordinate=vert_0[0],\n            Vertex_1_Ycoordinate=vert_0[1],\n            Vertex_1_Zcoordinate=vert_0[2],\n            Vertex_2_Xcoordinate=vert_1[0],\n            Vertex_2_Ycoordinate=vert_1[1],\n            Vertex_2_Zcoordinate=vert_1[2],\n            Vertex_3_Xcoordinate=vert_2[0],\n            Vertex_3_Ycoordinate=vert_2[1],\n            Vertex_3_Zcoordinate=vert_2[2],\n            Vertex_4_Xcoordinate=vert_3[0],\n            Vertex_4_Ycoordinate=vert_3[1],\n            Vertex_4_Zcoordinate=vert_3[2],\n            Zone_Name=\"Attic\",\n        )\n\n        vert_0 = (self.x + self.w, self.y, self.zones_height)\n        vert_1 = (self.x + self.w, self.y + self.d, self.zones_height)\n        vert_2 = (roof_centerline, self.y + self.d, self.total_height_with_gabling)\n        vert_3 = (roof_centerline, self.y, self.total_height_with_gabling)\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"Gable2\",\n            Surface_Type=\"Roof\",\n            Number_of_Vertices=4,\n            View_Factor_to_Ground=0,\n            Vertex_1_Xcoordinate=vert_0[0],\n            Vertex_1_Ycoordinate=vert_0[1],\n            Vertex_1_Zcoordinate=vert_0[2],\n            Vertex_2_Xcoordinate=vert_1[0],\n            Vertex_2_Ycoordinate=vert_1[1],\n            Vertex_2_Zcoordinate=vert_1[2],\n            Vertex_3_Xcoordinate=vert_2[0],\n            Vertex_3_Ycoordinate=vert_2[1],\n            Vertex_3_Zcoordinate=vert_2[2],\n            Vertex_4_Xcoordinate=vert_3[0],\n            Vertex_4_Ycoordinate=vert_3[1],\n            Vertex_4_Zcoordinate=vert_3[2],\n            Zone_Name=\"Attic\",\n        )\n\n        # make triangular endcaps\n        vert_0 = (self.x, self.y, self.zones_height)\n        vert_1 = (self.x + self.w, self.y, self.zones_height)\n        vert_2 = (roof_centerline, self.y, self.total_height_with_gabling)\n\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"Endcap1\",\n            Surface_Type=\"Wall\",\n            Number_of_Vertices=3,\n            Vertex_1_Xcoordinate=vert_0[0],\n            Vertex_1_Ycoordinate=vert_0[1],\n            Vertex_1_Zcoordinate=vert_0[2],\n            Vertex_2_Xcoordinate=vert_1[0],\n            Vertex_2_Ycoordinate=vert_1[1],\n            Vertex_2_Zcoordinate=vert_1[2],\n            Vertex_3_Xcoordinate=vert_2[0],\n            Vertex_3_Ycoordinate=vert_2[1],\n            Vertex_3_Zcoordinate=vert_2[2],\n            Zone_Name=\"Attic\",\n        )\n\n        vert_0 = (self.x + self.w, self.y + self.d, self.zones_height)\n        vert_1 = (self.x, self.y + self.d, self.zones_height)\n        vert_2 = (roof_centerline, self.y + self.d, self.total_height_with_gabling)\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"Endcap2\",\n            Surface_Type=\"Wall\",\n            Number_of_Vertices=3,\n            Vertex_1_Xcoordinate=vert_0[0],\n            Vertex_1_Ycoordinate=vert_0[1],\n            Vertex_1_Zcoordinate=vert_0[2],\n            Vertex_2_Xcoordinate=vert_1[0],\n            Vertex_2_Ycoordinate=vert_1[1],\n            Vertex_2_Zcoordinate=vert_1[2],\n            Vertex_3_Xcoordinate=vert_2[0],\n            Vertex_3_Ycoordinate=vert_2[1],\n            Vertex_3_Zcoordinate=vert_2[2],\n            Zone_Name=\"Attic\",\n        )\n\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"attic_bottom_plane\",\n            Surface_Type=\"Floor\",\n            Number_of_Vertices=4,\n            Vertex_1_Xcoordinate=self.x + self.w,\n            Vertex_1_Ycoordinate=self.y,\n            Vertex_1_Zcoordinate=self.zones_height,\n            Vertex_2_Xcoordinate=self.x,\n            Vertex_2_Ycoordinate=self.y,\n            Vertex_2_Zcoordinate=self.zones_height,\n            Vertex_3_Xcoordinate=self.x,\n            Vertex_3_Ycoordinate=self.y + self.d,\n            Vertex_3_Zcoordinate=self.zones_height,\n            Vertex_4_Xcoordinate=self.x + self.w,\n            Vertex_4_Ycoordinate=self.y + self.d,\n            Vertex_4_Zcoordinate=self.zones_height,\n            Zone_Name=\"Attic\",\n        )\n\n    idf.intersect_match()\n    idf.set_default_constructions()\n\n    # Handle Windows\n    window_walls = [\n        w\n        for w in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]\n        if w.Outside_Boundary_Condition.lower() == \"outdoors\"\n        and \"attic\" not in w.Zone_Name.lower()\n        and not w.Zone_Name.lower().endswith(\"-1\")\n        and w.Surface_Type.lower() == \"wall\"\n    ]\n    idf.set_wwr(\n        wwr=self.wwr,\n        construction=\"Project External Window\",\n        force=True,\n        surfaces=window_walls,\n    )\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.geometry.ZoneDimensions","title":"<code>ZoneDimensions</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Zone dimensions object which can be used to construct new shoebox zones.</p> Source code in <code>epinterface\\geometry.py</code> <pre><code>class ZoneDimensions(BaseModel):\n    \"\"\"Zone dimensions object which can be used to construct new shoebox zones.\"\"\"\n\n    x: float\n    y: float\n    w: float\n    d: float\n    h: float\n    num_stories: int\n    zoning: ZoningType = \"by_storey\"\n    perim_depth: float = 3\n    roof_height: float | None = None\n\n    def add(self, idf: IDF):\n        \"\"\"Add the zone to the IDF object.\n\n        Creates a new zone in the IDF object which is rectangular with a variable\n        number of stories and optional gabling, as well as different strategies\n        for zoning.\n\n        Args:\n            idf (IDF): The IDF object to add the zone to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        lower_left_corner = (self.x, self.y)\n        lower_right_corner = (self.x + self.w, self.y)\n        upper_right_corner = (self.x + self.w, self.y + self.d)\n        upper_left_corner = (self.x, self.y + self.d)\n        bottom_plane = [\n            lower_left_corner,\n            lower_right_corner,\n            upper_right_corner,\n            upper_left_corner,\n        ]\n        idf.add_block(\n            name=\"shoebox\",\n            coordinates=bottom_plane,\n            height=self.total_height,\n            num_stories=self.num_stories,\n            zoning=self.zoning,\n            perim_depth=self.perim_depth,\n        )\n        if self.roof_height:\n            idf.newidfobject(\"ZONE\", Name=\"Attic\")\n            roof_centerline = self.x + self.w / 2\n            vert_0 = (self.x, self.y + self.d, self.total_height)\n            vert_1 = (self.x, self.y, self.total_height)\n            vert_2 = (\n                roof_centerline,\n                self.y,\n                self.total_height + self.roof_height,\n            )\n            vert_3 = (\n                roof_centerline,\n                self.y + self.d,\n                self.total_height + self.roof_height,\n            )\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"Gable1\",\n                Surface_Type=\"Roof\",\n                Number_of_Vertices=4,\n                View_Factor_to_Ground=0,\n                Vertex_1_Xcoordinate=vert_0[0],\n                Vertex_1_Ycoordinate=vert_0[1],\n                Vertex_1_Zcoordinate=vert_0[2],\n                Vertex_2_Xcoordinate=vert_1[0],\n                Vertex_2_Ycoordinate=vert_1[1],\n                Vertex_2_Zcoordinate=vert_1[2],\n                Vertex_3_Xcoordinate=vert_2[0],\n                Vertex_3_Ycoordinate=vert_2[1],\n                Vertex_3_Zcoordinate=vert_2[2],\n                Vertex_4_Xcoordinate=vert_3[0],\n                Vertex_4_Ycoordinate=vert_3[1],\n                Vertex_4_Zcoordinate=vert_3[2],\n                Zone_Name=\"Attic\",\n            )\n\n            vert_0 = (self.x + self.w, self.y, self.total_height)\n            vert_1 = (self.x + self.w, self.y + self.d, self.total_height)\n            vert_2 = (\n                roof_centerline,\n                self.y + self.d,\n                self.total_height + self.roof_height,\n            )\n            vert_3 = (\n                roof_centerline,\n                self.y,\n                self.total_height + self.roof_height,\n            )\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"Gable2\",\n                Surface_Type=\"Roof\",\n                Number_of_Vertices=4,\n                View_Factor_to_Ground=0,\n                Vertex_1_Xcoordinate=vert_0[0],\n                Vertex_1_Ycoordinate=vert_0[1],\n                Vertex_1_Zcoordinate=vert_0[2],\n                Vertex_2_Xcoordinate=vert_1[0],\n                Vertex_2_Ycoordinate=vert_1[1],\n                Vertex_2_Zcoordinate=vert_1[2],\n                Vertex_3_Xcoordinate=vert_2[0],\n                Vertex_3_Ycoordinate=vert_2[1],\n                Vertex_3_Zcoordinate=vert_2[2],\n                Vertex_4_Xcoordinate=vert_3[0],\n                Vertex_4_Ycoordinate=vert_3[1],\n                Vertex_4_Zcoordinate=vert_3[2],\n                Zone_Name=\"Attic\",\n            )\n\n            # make triangular endcaps\n            vert_0 = (self.x, self.y, self.total_height)\n            vert_1 = (self.x + self.w, self.y, self.total_height)\n            vert_2 = (\n                roof_centerline,\n                self.y,\n                self.total_height + self.roof_height,\n            )\n\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"Endcap1\",\n                Surface_Type=\"Wall\",\n                Number_of_Vertices=3,\n                Vertex_1_Xcoordinate=vert_0[0],\n                Vertex_1_Ycoordinate=vert_0[1],\n                Vertex_1_Zcoordinate=vert_0[2],\n                Vertex_2_Xcoordinate=vert_1[0],\n                Vertex_2_Ycoordinate=vert_1[1],\n                Vertex_2_Zcoordinate=vert_1[2],\n                Vertex_3_Xcoordinate=vert_2[0],\n                Vertex_3_Ycoordinate=vert_2[1],\n                Vertex_3_Zcoordinate=vert_2[2],\n                Zone_Name=\"Attic\",\n            )\n\n            vert_0 = (self.x + self.w, self.y + self.d, self.total_height)\n            vert_1 = (self.x, self.y + self.d, self.total_height)\n            vert_2 = (\n                roof_centerline,\n                self.y + self.d,\n                self.total_height + self.roof_height,\n            )\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"Endcap2\",\n                Surface_Type=\"Wall\",\n                Number_of_Vertices=3,\n                Vertex_1_Xcoordinate=vert_0[0],\n                Vertex_1_Ycoordinate=vert_0[1],\n                Vertex_1_Zcoordinate=vert_0[2],\n                Vertex_2_Xcoordinate=vert_1[0],\n                Vertex_2_Ycoordinate=vert_1[1],\n                Vertex_2_Zcoordinate=vert_1[2],\n                Vertex_3_Xcoordinate=vert_2[0],\n                Vertex_3_Ycoordinate=vert_2[1],\n                Vertex_3_Zcoordinate=vert_2[2],\n                Zone_Name=\"Attic\",\n            )\n\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"attic_bottom_plane\",\n                Surface_Type=\"Floor\",\n                Number_of_Vertices=4,\n                Vertex_1_Xcoordinate=self.x + self.w,\n                Vertex_1_Ycoordinate=self.y,\n                Vertex_1_Zcoordinate=self.total_height,\n                Vertex_2_Xcoordinate=self.x,\n                Vertex_2_Ycoordinate=self.y,\n                Vertex_2_Zcoordinate=self.total_height,\n                Vertex_3_Xcoordinate=self.x,\n                Vertex_3_Ycoordinate=self.y + self.d,\n                Vertex_3_Zcoordinate=self.total_height,\n                Vertex_4_Xcoordinate=self.x + self.w,\n                Vertex_4_Ycoordinate=self.y + self.d,\n                Vertex_4_Zcoordinate=self.total_height,\n                Zone_Name=\"Attic\",\n            )\n\n        return idf\n\n    @property\n    def total_height(self):\n        \"\"\"Return the total height of the zones.\"\"\"\n        return self.h * self.num_stories\n</code></pre>"},{"location":"modules/#epinterface.geometry.ZoneDimensions.total_height","title":"<code>total_height</code>  <code>property</code>","text":"<p>Return the total height of the zones.</p>"},{"location":"modules/#epinterface.geometry.ZoneDimensions.add","title":"<code>add(idf)</code>","text":"<p>Add the zone to the IDF object.</p> <p>Creates a new zone in the IDF object which is rectangular with a variable number of stories and optional gabling, as well as different strategies for zoning.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the zone to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\geometry.py</code> <pre><code>def add(self, idf: IDF):\n    \"\"\"Add the zone to the IDF object.\n\n    Creates a new zone in the IDF object which is rectangular with a variable\n    number of stories and optional gabling, as well as different strategies\n    for zoning.\n\n    Args:\n        idf (IDF): The IDF object to add the zone to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    lower_left_corner = (self.x, self.y)\n    lower_right_corner = (self.x + self.w, self.y)\n    upper_right_corner = (self.x + self.w, self.y + self.d)\n    upper_left_corner = (self.x, self.y + self.d)\n    bottom_plane = [\n        lower_left_corner,\n        lower_right_corner,\n        upper_right_corner,\n        upper_left_corner,\n    ]\n    idf.add_block(\n        name=\"shoebox\",\n        coordinates=bottom_plane,\n        height=self.total_height,\n        num_stories=self.num_stories,\n        zoning=self.zoning,\n        perim_depth=self.perim_depth,\n    )\n    if self.roof_height:\n        idf.newidfobject(\"ZONE\", Name=\"Attic\")\n        roof_centerline = self.x + self.w / 2\n        vert_0 = (self.x, self.y + self.d, self.total_height)\n        vert_1 = (self.x, self.y, self.total_height)\n        vert_2 = (\n            roof_centerline,\n            self.y,\n            self.total_height + self.roof_height,\n        )\n        vert_3 = (\n            roof_centerline,\n            self.y + self.d,\n            self.total_height + self.roof_height,\n        )\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"Gable1\",\n            Surface_Type=\"Roof\",\n            Number_of_Vertices=4,\n            View_Factor_to_Ground=0,\n            Vertex_1_Xcoordinate=vert_0[0],\n            Vertex_1_Ycoordinate=vert_0[1],\n            Vertex_1_Zcoordinate=vert_0[2],\n            Vertex_2_Xcoordinate=vert_1[0],\n            Vertex_2_Ycoordinate=vert_1[1],\n            Vertex_2_Zcoordinate=vert_1[2],\n            Vertex_3_Xcoordinate=vert_2[0],\n            Vertex_3_Ycoordinate=vert_2[1],\n            Vertex_3_Zcoordinate=vert_2[2],\n            Vertex_4_Xcoordinate=vert_3[0],\n            Vertex_4_Ycoordinate=vert_3[1],\n            Vertex_4_Zcoordinate=vert_3[2],\n            Zone_Name=\"Attic\",\n        )\n\n        vert_0 = (self.x + self.w, self.y, self.total_height)\n        vert_1 = (self.x + self.w, self.y + self.d, self.total_height)\n        vert_2 = (\n            roof_centerline,\n            self.y + self.d,\n            self.total_height + self.roof_height,\n        )\n        vert_3 = (\n            roof_centerline,\n            self.y,\n            self.total_height + self.roof_height,\n        )\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"Gable2\",\n            Surface_Type=\"Roof\",\n            Number_of_Vertices=4,\n            View_Factor_to_Ground=0,\n            Vertex_1_Xcoordinate=vert_0[0],\n            Vertex_1_Ycoordinate=vert_0[1],\n            Vertex_1_Zcoordinate=vert_0[2],\n            Vertex_2_Xcoordinate=vert_1[0],\n            Vertex_2_Ycoordinate=vert_1[1],\n            Vertex_2_Zcoordinate=vert_1[2],\n            Vertex_3_Xcoordinate=vert_2[0],\n            Vertex_3_Ycoordinate=vert_2[1],\n            Vertex_3_Zcoordinate=vert_2[2],\n            Vertex_4_Xcoordinate=vert_3[0],\n            Vertex_4_Ycoordinate=vert_3[1],\n            Vertex_4_Zcoordinate=vert_3[2],\n            Zone_Name=\"Attic\",\n        )\n\n        # make triangular endcaps\n        vert_0 = (self.x, self.y, self.total_height)\n        vert_1 = (self.x + self.w, self.y, self.total_height)\n        vert_2 = (\n            roof_centerline,\n            self.y,\n            self.total_height + self.roof_height,\n        )\n\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"Endcap1\",\n            Surface_Type=\"Wall\",\n            Number_of_Vertices=3,\n            Vertex_1_Xcoordinate=vert_0[0],\n            Vertex_1_Ycoordinate=vert_0[1],\n            Vertex_1_Zcoordinate=vert_0[2],\n            Vertex_2_Xcoordinate=vert_1[0],\n            Vertex_2_Ycoordinate=vert_1[1],\n            Vertex_2_Zcoordinate=vert_1[2],\n            Vertex_3_Xcoordinate=vert_2[0],\n            Vertex_3_Ycoordinate=vert_2[1],\n            Vertex_3_Zcoordinate=vert_2[2],\n            Zone_Name=\"Attic\",\n        )\n\n        vert_0 = (self.x + self.w, self.y + self.d, self.total_height)\n        vert_1 = (self.x, self.y + self.d, self.total_height)\n        vert_2 = (\n            roof_centerline,\n            self.y + self.d,\n            self.total_height + self.roof_height,\n        )\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"Endcap2\",\n            Surface_Type=\"Wall\",\n            Number_of_Vertices=3,\n            Vertex_1_Xcoordinate=vert_0[0],\n            Vertex_1_Ycoordinate=vert_0[1],\n            Vertex_1_Zcoordinate=vert_0[2],\n            Vertex_2_Xcoordinate=vert_1[0],\n            Vertex_2_Ycoordinate=vert_1[1],\n            Vertex_2_Zcoordinate=vert_1[2],\n            Vertex_3_Xcoordinate=vert_2[0],\n            Vertex_3_Ycoordinate=vert_2[1],\n            Vertex_3_Zcoordinate=vert_2[2],\n            Zone_Name=\"Attic\",\n        )\n\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"attic_bottom_plane\",\n            Surface_Type=\"Floor\",\n            Number_of_Vertices=4,\n            Vertex_1_Xcoordinate=self.x + self.w,\n            Vertex_1_Ycoordinate=self.y,\n            Vertex_1_Zcoordinate=self.total_height,\n            Vertex_2_Xcoordinate=self.x,\n            Vertex_2_Ycoordinate=self.y,\n            Vertex_2_Zcoordinate=self.total_height,\n            Vertex_3_Xcoordinate=self.x,\n            Vertex_3_Ycoordinate=self.y + self.d,\n            Vertex_3_Zcoordinate=self.total_height,\n            Vertex_4_Xcoordinate=self.x + self.w,\n            Vertex_4_Ycoordinate=self.y + self.d,\n            Vertex_4_Zcoordinate=self.total_height,\n            Zone_Name=\"Attic\",\n        )\n\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.geometry.match_idf_to_building_and_neighbors","title":"<code>match_idf_to_building_and_neighbors(idf, building, neighbor_polys, neighbor_floors, neighbor_f2f_height, target_short_length, target_long_length, rotation_angle)</code>","text":"<p>Match an IDF model to a building and neighbors by scaling and rotating the IDF model and adding shading blocks for neighbors.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to match.</p> required <code>building</code> <code>Polygon | str</code> <p>The building to match.</p> required <code>neighbor_polys</code> <code>list[Polygon | str | None]</code> <p>The neighbors to inject as shading.</p> required <code>neighbor_floors</code> <code>list[float | int | None]</code> <p>The counts of the neighbors.</p> required <code>neighbor_f2f_height</code> <code>float | None</code> <p>The height of the building to match</p> required <code>target_short_length</code> <code>float</code> <p>The target short length of the building.</p> required <code>target_long_length</code> <code>float</code> <p>The target long length of the building.</p> required <code>rotation_angle</code> <code>float</code> <p>The rotation angle of the building (radians).</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The matched IDF model.</p> Source code in <code>epinterface\\geometry.py</code> <pre><code>def match_idf_to_building_and_neighbors(\n    idf: IDF,\n    building: Polygon | str,\n    neighbor_polys: list[Polygon | str | None],\n    neighbor_floors: list[float | int | None],\n    neighbor_f2f_height: float,\n    target_short_length: float,\n    target_long_length: float,\n    rotation_angle: float,\n) -&gt; IDF:\n    \"\"\"Match an IDF model to a building and neighbors by scaling and rotating the IDF model and adding shading blocks for neighbors.\n\n    Args:\n        idf (IDF): The IDF model to match.\n        building (Polygon | str): The building to match.\n        neighbor_polys (list[Polygon | str | None]): The neighbors to inject as shading.\n        neighbor_floors (list[float | int | None]): The counts of the neighbors.\n        neighbor_f2f_height (float | None): The height of the building to match\n        target_short_length (float): The target short length of the building.\n        target_long_length (float): The target long length of the building.\n        rotation_angle (float): The rotation angle of the building (radians).\n\n    Returns:\n        idf (IDF): The matched IDF model.\n    \"\"\"\n    building_geo = (\n        cast(Polygon, from_wkt(building)) if isinstance(building, str) else building\n    )\n    neighbor_geos = [\n        (cast(Polygon, from_wkt(n)), h * neighbor_f2f_height)\n        if isinstance(n, str)\n        else (n, h * neighbor_f2f_height)\n        for n, h in zip(neighbor_polys, neighbor_floors, strict=True)\n        if n is not None and h is not None\n    ]\n    centroid = building_geo.centroid\n    translated_neighbors = [\n        (translate(n, xoff=-centroid.x, yoff=-centroid.y), h) for n, h in neighbor_geos\n    ]\n    idf_lengths = {(e.p1 - e.p2).length for e in idf.bounding_box().edges}\n    if len(idf_lengths) &gt; 2:\n        raise NotImplementedError(\n            \"The IDF model is not a rectangle, which is not yet supported.\"\n        )\n\n    long_length = max(idf_lengths)\n    short_length = min(idf_lengths)\n    idf.scale(target_long_length / long_length, anchor=Vector2D(0, 0), axes=\"x\")\n    idf.scale(target_short_length / short_length, anchor=Vector2D(0, 0), axes=\"y\")\n    idf.translate((-target_long_length / 2, -target_short_length / 2, 0))\n    idf.rotate(rotation_angle * 180 / np.pi)\n    for i, (geom, height) in enumerate(translated_neighbors):\n        if not height:\n            height = 3.5 * 2\n        if np.isnan(height):\n            height = 3.5 * 2\n        idf.add_shading_block(\n            name=f\"shading_{i}\",\n            coordinates=[Vector2D(*coord) for coord in geom.exterior.coords[:-1]],\n            height=height,\n        )\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.geometry.match_idf_to_scene","title":"<code>match_idf_to_scene(idf, gdf_buildings, building_ix, neighbor_threshold=50, apply_z_scale=False)</code>","text":"<p>Match an IDF model to a scene of buildings by scaling and rotating the IDF model.</p> <p>Additionally adds shading blocks for neighboring buildings.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to match.</p> required <code>gdf_buildings</code> <code>GeoDataFrame</code> <p>The scene of buildings.</p> required <code>building_ix</code> <code>int</code> <p>The index of the building in the scene to match.</p> required <code>neighbor_threshold</code> <code>float</code> <p>The distance threshold for a building to be considered a neighbor.</p> <code>50</code> <code>apply_z_scale</code> <code>bool</code> <p>Whether to scale the IDF model in the z direction.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The matched IDF model.</p> Source code in <code>epinterface\\geometry.py</code> <pre><code>def match_idf_to_scene(\n    idf: IDF,\n    gdf_buildings: gpd.GeoDataFrame,\n    building_ix: int,\n    neighbor_threshold: float = 50,\n    apply_z_scale: bool = False,\n):\n    \"\"\"Match an IDF model to a scene of buildings by scaling and rotating the IDF model.\n\n    Additionally adds shading blocks for neighboring buildings.\n\n    Args:\n        idf (IDF): The IDF model to match.\n        gdf_buildings (gpd.GeoDataFrame): The scene of buildings.\n        building_ix (int): The index of the building in the scene to match.\n        neighbor_threshold (float): The distance threshold for a building to be considered a neighbor.\n        apply_z_scale (bool): Whether to scale the IDF model in the z direction.\n\n\n    Returns:\n        idf (IDF): The matched IDF model.\n    \"\"\"\n    # TODO: add PANDERA schema validation\n    center = gdf_buildings.iloc[building_ix].rotated_rectangle\n    is_neighbor_mask = gdf_buildings.rotated_rectangle.apply(\n        lambda x: x.distance(center) &lt; neighbor_threshold\n    )\n    is_neighbor_mask.iloc[building_ix] = False\n    neighbor_intersects = gdf_buildings.rotated_rectangle[is_neighbor_mask].apply(\n        lambda x: x.intersects(center)\n    )\n    is_non_intersecting_neighbor = (\n        ~neighbor_intersects.reindex(gdf_buildings.index, fill_value=False)\n        &amp; is_neighbor_mask\n    )\n    non_intersecting_neighbor_geometry = gdf_buildings.rotated_rectangle[\n        is_non_intersecting_neighbor\n    ]\n    translated_neighbors = non_intersecting_neighbor_geometry.apply(\n        lambda x: translate(x, xoff=-center.centroid.x, yoff=-center.centroid.y)\n    )\n    translated_neighbor_heights = gdf_buildings.height[is_non_intersecting_neighbor]\n\n    idf_lengths = {(e.p1 - e.p2).length for e in idf.bounding_box().edges}\n    # TODO: handle the case where the idf model building is not a rectangle\n    # TODO: errors/warnings on scaling factors being too large or aspect ratio too\n    # TODO: handle cases where the base idf building is rotated\n    # different\n    if len(idf_lengths) != 2:\n        raise NotImplementedError(\n            \"The IDF model is not a rectangle, which is not yet supported.\"\n        )\n    short_length = min(idf_lengths)\n    long_length = max(idf_lengths)\n    z_coords = [\n        obj[f\"Vertex_{i}_Zcoordinate\"]\n        for obj in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]\n        for i in range(1, 5)\n    ]\n    z_coords = [float(z) for z in z_coords if z]\n    model_height = max(z_coords)\n    building_short_length = gdf_buildings.iloc[building_ix].short_edge\n    building_long_length = gdf_buildings.iloc[building_ix].long_edge\n    building_height = gdf_buildings.iloc[building_ix].height\n    idf.scale(building_long_length / long_length, anchor=Vector2D(0, 0), axes=\"x\")\n    idf.scale(building_short_length / short_length, anchor=Vector2D(0, 0), axes=\"y\")\n    if apply_z_scale:\n        idf.scale(building_height / model_height, anchor=Vector2D(0, 0), axes=\"z\")\n\n    idf.translate((-building_long_length / 2, -building_short_length / 2, 0))\n    rotation_angle = gdf_buildings.iloc[building_ix].long_edge_angle\n    idf.rotate(rotation_angle * 180 / np.pi)\n\n    # add the neighbors as shading blocks\n    for i, geom in enumerate(translated_neighbors):\n        height = translated_neighbor_heights.iloc[i]\n        if not height:\n            height = 3.5\n        if np.isnan(height):\n            height = 3.5\n        idf.add_shading_block(\n            name=f\"shading_{i}\",\n            coordinates=[Vector2D(*coord) for coord in geom.exterior.coords[:-1]],\n            height=height,\n        )\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ClimateStudioException","title":"<code>ClimateStudioException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>A base exception for the climate studio library.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ClimateStudioException(Exception):\n    \"\"\"A base exception for the climate studio library.\"\"\"\n\n    def __init__(self, message: str):\n        \"\"\"Initialize the exception with a message.\"\"\"\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ClimateStudioException.__init__","title":"<code>__init__(message)</code>","text":"<p>Initialize the exception with a message.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def __init__(self, message: str):\n    \"\"\"Initialize the exception with a message.\"\"\"\n    self.message = message\n    super().__init__(self.message)\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ClimateStudioLibraryDuplicatesFound","title":"<code>ClimateStudioLibraryDuplicatesFound</code>","text":"<p>               Bases: <code>ClimateStudioException</code></p> <p>An error raised when duplicates are found in a climate studio library.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ClimateStudioLibraryDuplicatesFound(ClimateStudioException):\n    \"\"\"An error raised when duplicates are found in a climate studio library.\"\"\"\n\n    def __init__(self, duplicate_field: str):\n        \"\"\"Initialize the exception with a message.\n\n        Args:\n            duplicate_field (str): The field with duplicates\n        \"\"\"\n        self.duplicate_field = duplicate_field\n        self.message = f\"Duplicate objects found in library: {duplicate_field}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ClimateStudioLibraryDuplicatesFound.__init__","title":"<code>__init__(duplicate_field)</code>","text":"<p>Initialize the exception with a message.</p> <p>Parameters:</p> Name Type Description Default <code>duplicate_field</code> <code>str</code> <p>The field with duplicates</p> required Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def __init__(self, duplicate_field: str):\n    \"\"\"Initialize the exception with a message.\n\n    Args:\n        duplicate_field (str): The field with duplicates\n    \"\"\"\n    self.duplicate_field = duplicate_field\n    self.message = f\"Duplicate objects found in library: {duplicate_field}\"\n    super().__init__(self.message)\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ClimateStudioLibraryV1","title":"<code>ClimateStudioLibraryV1</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Climate Studio library object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ClimateStudioLibraryV1(BaseModel, arbitrary_types_allowed=True):\n    \"\"\"Climate Studio library object.\"\"\"\n\n    # DaySchedules: dict[str, DaySchedule]\n    # DomHotWater: dict[str, DomHotWater]\n    # WindowSettings: dict[str, WindowSettings]\n    # NaturalVentilation: dict[str, NaturalVentilation] ?\n    GasMaterials: dict[str, GasMaterial]\n    GlazingConstructionSimple: dict[str, GlazingConstructionSimple]\n    GlazingMaterials: dict[str, GlazingMaterial]\n    OpaqueMaterials: dict[str, OpaqueMaterial]\n    OpaqueConstructions: dict[str, OpaqueConstruction]\n    ZoneConditioning: dict[str, ZoneConditioning]\n    ZoneConstruction: dict[str, ZoneConstruction]\n    ZoneDefinition: dict[str, ZoneDefinition]\n    ZoneInfiltration: dict[str, ZoneInfiltration]\n    ZoneLoad: dict[str, ZoneLoad]\n    Schedules: dict[str, Schedule]\n\n    @classmethod\n    @validate_call\n    def Load(cls, base_path: Path):\n        \"\"\"Load a Climate Studio library from a directory.\n\n        The directory should have all the necessary named files.\n\n        Args:\n            base_path (Path): The base path to the library directory.\n\n        Returns:\n            lib (ClimateStudioLibrary): The Climate Studio library object.\n        \"\"\"\n        if isinstance(base_path, str):\n            base_path = Path(base_path)\n\n        gas_materials = cls.LoadObjects(base_path, GasMaterial, pluralize=True)\n        glass_consts_simple = cls.LoadObjects(base_path, GlazingConstructionSimple)\n        glazing_materials = cls.LoadObjects(base_path, GlazingMaterial, pluralize=True)\n        opaque_materials = cls.LoadObjects(base_path, OpaqueMaterial, pluralize=True)\n        opaque_consts = cls.LoadObjects(base_path, OpaqueConstruction, pluralize=True)\n        zone_constructions = cls.LoadObjects(base_path, ZoneConstruction)\n        zone_definitions = cls.LoadObjects(base_path, ZoneDefinition)\n        zone_conditioning = cls.LoadObjects(base_path, ZoneConditioning)\n        zone_infiltrations = cls.LoadObjects(base_path, ZoneInfiltration)\n        zone_loads = cls.LoadObjects(base_path, ZoneLoad)\n\n        year_schs = pd.read_csv(base_path / \"YearSchedules.csv\", dtype=str)\n        sch_names = year_schs.columns\n        schedules_list = [extract_sch(year_schs, sch_name) for sch_name in sch_names]\n        schedules = {sch.Name: sch for sch in schedules_list}\n        if len(schedules) != len(schedules_list):\n            raise ClimateStudioLibraryDuplicatesFound(\"Schedules\")\n\n        return cls(\n            GasMaterials=gas_materials,\n            GlazingConstructionSimple=glass_consts_simple,\n            GlazingMaterials=glazing_materials,\n            OpaqueMaterials=opaque_materials,\n            OpaqueConstructions=opaque_consts,\n            ZoneConditioning=zone_conditioning,\n            ZoneConstruction=zone_constructions,\n            ZoneDefinition=zone_definitions,\n            ZoneInfiltration=zone_infiltrations,\n            ZoneLoad=zone_loads,\n            Schedules=schedules,\n        )\n\n    @classmethod\n    def LoadObjects(\n        cls, base_path: Path, obj_class: type[NamedType], pluralize: bool = False\n    ) -&gt; dict[str, NamedType]:\n        \"\"\"Handles deserializing a ClimateStudio CSV to the appropriate class.\n\n        Args:\n            base_path (Path): The base path to the library directory.\n            obj_class (Type[NamedObject]): The class to deserialize to.\n            pluralize (bool, optional): Whether to pluralize the filename. Defaults to False.\n\n        Returns:\n            dict[str, NamedObject]: The deserialized objects.\n        \"\"\"\n        df = pd.read_csv(\n            base_path / f\"{obj_class.__name__}{'s' if pluralize else ''}.csv\"\n        )\n        data = df.to_dict(orient=\"records\")\n        obj_list = [obj_class.model_validate(d) for d in data]\n        obj_dict = {obj.Name: obj for obj in obj_list}\n        if len(obj_dict) != len(obj_list):\n            raise ClimateStudioLibraryDuplicatesFound(obj_class.__name__)\n        return obj_dict\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ClimateStudioLibraryV1.Load","title":"<code>Load(base_path)</code>  <code>classmethod</code>","text":"<p>Load a Climate Studio library from a directory.</p> <p>The directory should have all the necessary named files.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>Path</code> <p>The base path to the library directory.</p> required <p>Returns:</p> Name Type Description <code>lib</code> <code>ClimateStudioLibrary</code> <p>The Climate Studio library object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>@classmethod\n@validate_call\ndef Load(cls, base_path: Path):\n    \"\"\"Load a Climate Studio library from a directory.\n\n    The directory should have all the necessary named files.\n\n    Args:\n        base_path (Path): The base path to the library directory.\n\n    Returns:\n        lib (ClimateStudioLibrary): The Climate Studio library object.\n    \"\"\"\n    if isinstance(base_path, str):\n        base_path = Path(base_path)\n\n    gas_materials = cls.LoadObjects(base_path, GasMaterial, pluralize=True)\n    glass_consts_simple = cls.LoadObjects(base_path, GlazingConstructionSimple)\n    glazing_materials = cls.LoadObjects(base_path, GlazingMaterial, pluralize=True)\n    opaque_materials = cls.LoadObjects(base_path, OpaqueMaterial, pluralize=True)\n    opaque_consts = cls.LoadObjects(base_path, OpaqueConstruction, pluralize=True)\n    zone_constructions = cls.LoadObjects(base_path, ZoneConstruction)\n    zone_definitions = cls.LoadObjects(base_path, ZoneDefinition)\n    zone_conditioning = cls.LoadObjects(base_path, ZoneConditioning)\n    zone_infiltrations = cls.LoadObjects(base_path, ZoneInfiltration)\n    zone_loads = cls.LoadObjects(base_path, ZoneLoad)\n\n    year_schs = pd.read_csv(base_path / \"YearSchedules.csv\", dtype=str)\n    sch_names = year_schs.columns\n    schedules_list = [extract_sch(year_schs, sch_name) for sch_name in sch_names]\n    schedules = {sch.Name: sch for sch in schedules_list}\n    if len(schedules) != len(schedules_list):\n        raise ClimateStudioLibraryDuplicatesFound(\"Schedules\")\n\n    return cls(\n        GasMaterials=gas_materials,\n        GlazingConstructionSimple=glass_consts_simple,\n        GlazingMaterials=glazing_materials,\n        OpaqueMaterials=opaque_materials,\n        OpaqueConstructions=opaque_consts,\n        ZoneConditioning=zone_conditioning,\n        ZoneConstruction=zone_constructions,\n        ZoneDefinition=zone_definitions,\n        ZoneInfiltration=zone_infiltrations,\n        ZoneLoad=zone_loads,\n        Schedules=schedules,\n    )\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ClimateStudioLibraryV1.LoadObjects","title":"<code>LoadObjects(base_path, obj_class, pluralize=False)</code>  <code>classmethod</code>","text":"<p>Handles deserializing a ClimateStudio CSV to the appropriate class.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>Path</code> <p>The base path to the library directory.</p> required <code>obj_class</code> <code>Type[NamedObject]</code> <p>The class to deserialize to.</p> required <code>pluralize</code> <code>bool</code> <p>Whether to pluralize the filename. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, NamedType]</code> <p>dict[str, NamedObject]: The deserialized objects.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>@classmethod\ndef LoadObjects(\n    cls, base_path: Path, obj_class: type[NamedType], pluralize: bool = False\n) -&gt; dict[str, NamedType]:\n    \"\"\"Handles deserializing a ClimateStudio CSV to the appropriate class.\n\n    Args:\n        base_path (Path): The base path to the library directory.\n        obj_class (Type[NamedObject]): The class to deserialize to.\n        pluralize (bool, optional): Whether to pluralize the filename. Defaults to False.\n\n    Returns:\n        dict[str, NamedObject]: The deserialized objects.\n    \"\"\"\n    df = pd.read_csv(\n        base_path / f\"{obj_class.__name__}{'s' if pluralize else ''}.csv\"\n    )\n    data = df.to_dict(orient=\"records\")\n    obj_list = [obj_class.model_validate(d) for d in data]\n    obj_dict = {obj.Name: obj for obj in obj_list}\n    if len(obj_dict) != len(obj_list):\n        raise ClimateStudioLibraryDuplicatesFound(obj_class.__name__)\n    return obj_dict\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ClimateStudioLibraryV2","title":"<code>ClimateStudioLibraryV2</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Climate Studio library object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ClimateStudioLibraryV2(BaseModel, arbitrary_types_allowed=True):\n    \"\"\"Climate Studio library object.\"\"\"\n\n    SpaceUses: dict[str, ZoneUse]\n    Envelopes: dict[str, ZoneEnvelope]\n    GlazingConstructions: dict[str, GlazingConstructionSimple]\n    OpaqueConstructions: dict[str, OpaqueConstruction]\n    OpaqueMaterials: dict[str, OpaqueMaterial]\n    Schedules: dict[str, Schedule]\n\n    @field_validator(\"Schedules\", mode=\"before\")\n    @classmethod\n    def validate_schedules(cls, value: dict[str, Any]):\n        \"\"\"Validate the schedules.\"\"\"\n        for key, val in value.items():\n            if isinstance(val, dict):\n                transfer = ScheduleTransferObject.model_validate(val)\n                limit_type = ScheduleTypeLimits.from_dict(transfer.Type)\n                value[key] = Schedule.from_values(\n                    Name=transfer.Name,\n                    Type=limit_type,  # pyright: ignore [reportArgumentType]\n                    Values=transfer.Values,\n                )\n            elif isinstance(val, ScheduleTransferObject):\n                limit_type = ScheduleTypeLimits.from_dict(val.Type)\n                value[key] = Schedule.from_values(\n                    Name=val.Name,\n                    Type=limit_type,  # pyright: ignore [reportArgumentType]\n                    Values=val.Values,\n                )\n            elif not isinstance(val, Schedule):\n                raise TypeError(f\"SCHEDULE_LOAD_ERROR:{type(val)}\")\n            else:\n                continue\n        return value\n\n    @field_serializer(\"Schedules\")\n    def serialize_schedules(\n        self, schedules: dict[str, Schedule]\n    ) -&gt; dict[str, \"ScheduleTransferObject\"]:\n        \"\"\"Serialize the schedules to a dataframe.\n\n        Args:\n            schedules (dict[str, Schedule]): The schedules to serialize.\n\n        Returns:\n            serialized_schedules (dict[str, list[float]])\n        \"\"\"\n        out_result: dict[str, ScheduleTransferObject] = {}\n        for name, sch in schedules.items():\n            out_result[name] = ScheduleTransferObject(\n                Name=sch.Name,\n                Type=sch.Type.to_dict(),\n                Values=list(cast(np.ndarray, sch.Values)),\n            )\n\n        return out_result\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ClimateStudioLibraryV2.serialize_schedules","title":"<code>serialize_schedules(schedules)</code>","text":"<p>Serialize the schedules to a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>schedules</code> <code>dict[str, Schedule]</code> <p>The schedules to serialize.</p> required <p>Returns:</p> Type Description <code>dict[str, ScheduleTransferObject]</code> <p>serialized_schedules (dict[str, list[float]])</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>@field_serializer(\"Schedules\")\ndef serialize_schedules(\n    self, schedules: dict[str, Schedule]\n) -&gt; dict[str, \"ScheduleTransferObject\"]:\n    \"\"\"Serialize the schedules to a dataframe.\n\n    Args:\n        schedules (dict[str, Schedule]): The schedules to serialize.\n\n    Returns:\n        serialized_schedules (dict[str, list[float]])\n    \"\"\"\n    out_result: dict[str, ScheduleTransferObject] = {}\n    for name, sch in schedules.items():\n        out_result[name] = ScheduleTransferObject(\n            Name=sch.Name,\n            Type=sch.Type.to_dict(),\n            Values=list(cast(np.ndarray, sch.Values)),\n        )\n\n    return out_result\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ClimateStudioLibraryV2.validate_schedules","title":"<code>validate_schedules(value)</code>  <code>classmethod</code>","text":"<p>Validate the schedules.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>@field_validator(\"Schedules\", mode=\"before\")\n@classmethod\ndef validate_schedules(cls, value: dict[str, Any]):\n    \"\"\"Validate the schedules.\"\"\"\n    for key, val in value.items():\n        if isinstance(val, dict):\n            transfer = ScheduleTransferObject.model_validate(val)\n            limit_type = ScheduleTypeLimits.from_dict(transfer.Type)\n            value[key] = Schedule.from_values(\n                Name=transfer.Name,\n                Type=limit_type,  # pyright: ignore [reportArgumentType]\n                Values=transfer.Values,\n            )\n        elif isinstance(val, ScheduleTransferObject):\n            limit_type = ScheduleTypeLimits.from_dict(val.Type)\n            value[key] = Schedule.from_values(\n                Name=val.Name,\n                Type=limit_type,  # pyright: ignore [reportArgumentType]\n                Values=val.Values,\n            )\n        elif not isinstance(val, Schedule):\n            raise TypeError(f\"SCHEDULE_LOAD_ERROR:{type(val)}\")\n        else:\n            continue\n    return value\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ClimateStudioMetadata","title":"<code>ClimateStudioMetadata</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Metadata for a climate studio table object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ClimateStudioMetadata(BaseModel):\n    \"\"\"Metadata for a climate studio table object.\"\"\"\n\n    Category: str = Field(..., title=\"Category of the object\")\n    Comment: NanStr = Field(..., title=\"Comment on the object\")\n    DataSource: NanStr = Field(..., title=\"Data source of the object\")\n    ClimateZone: str = Field(..., title=\"Climate zone of the object\")\n    Standard: str = Field(..., title=\"Standard of the object\")\n    Program: str = Field(..., title=\"Program of the object\")\n    Version: NanStr | None = Field(default=None, title=\"Version of the object\")\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ClimateStudioValueNotFound","title":"<code>ClimateStudioValueNotFound</code>","text":"<p>               Bases: <code>ClimateStudioException</code></p> <p>An error raised when a value is not found in a climate studio library.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ClimateStudioValueNotFound(ClimateStudioException):\n    \"\"\"An error raised when a value is not found in a climate studio library.\"\"\"\n\n    def __init__(self, obj_type: str, value: str):\n        \"\"\"Initialize the exception with a message.\n\n        Args:\n            obj_type (str): The type of object that was not found.\n            value (str): The value that was not found.\n        \"\"\"\n        self.obj_type = obj_type\n        self.value = value\n        self.message = f\"Value not found in library: {obj_type}:{value}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ClimateStudioValueNotFound.__init__","title":"<code>__init__(obj_type, value)</code>","text":"<p>Initialize the exception with a message.</p> <p>Parameters:</p> Name Type Description Default <code>obj_type</code> <code>str</code> <p>The type of object that was not found.</p> required <code>value</code> <code>str</code> <p>The value that was not found.</p> required Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def __init__(self, obj_type: str, value: str):\n    \"\"\"Initialize the exception with a message.\n\n    Args:\n        obj_type (str): The type of object that was not found.\n        value (str): The value that was not found.\n    \"\"\"\n    self.obj_type = obj_type\n    self.value = value\n    self.message = f\"Value not found in library: {obj_type}:{value}\"\n    super().__init__(self.message)\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.CommonMaterialProperties","title":"<code>CommonMaterialProperties</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Common material properties for glazing and opaque materials.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class CommonMaterialProperties(BaseModel):\n    \"\"\"Common material properties for glazing and opaque materials.\"\"\"\n\n    Conductivity: float = Field(\n        ...,\n        title=\"Conductivity [W/mK]\",\n        validation_alias=\"Conductivity [W/m.K]\",\n        ge=0,\n    )\n    Density: float = Field(\n        ...,\n        title=\"Density [kg/m3]\",\n        ge=0,\n        validation_alias=AliasChoices(\n            \"Density [kg/m\u00b3]\",\n            \"Density [kg/m3]\",\n        ),\n    )\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.EmbodiedCarbonData","title":"<code>EmbodiedCarbonData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Embodied carbon data for a material or construction.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class EmbodiedCarbonData(BaseModel):\n    \"\"\"Embodied carbon data for a material or construction.\"\"\"\n\n    EmbodiedEnergy: float = Field(\n        ...,\n        title=\"Embodied energy [MJ/unit]\",\n        validation_alias=AliasChoices(\n            \"EmbodiedEnergy [MJ/Kg]\",\n            \"EmbodiedEnergy\",\n            \"EmbodiedEnergy [MJ/m\u00b2]\",\n            \"EmbodiedEnergy [MJ/m\u00c2\u00b2]\",\n            \"EmbodiedEnergy [MJ/m\u00c3\u201a\u00c2\u00b2]\",  # noqa: RUF001\n        ),\n    )\n    EmbodiedEnergyStdDev: float = Field(\n        0,\n        title=\"Standard deviation of embodied energy [MJ/unit]\",\n        validation_alias=\"EmbodiedEnergyStdDev\",\n        ge=0,\n    )\n    EmbodiedCarbon: float = Field(\n        ...,\n        title=\"Embodied carbon [kgCO2eq/unit]\",\n        validation_alias=AliasChoices(\n            \"EmbodiedCarbon [kgCO2eq/Kg]\",\n            \"EmbodiedCarbon\",\n            \"EmbodiedCarbon [kgCO2eq/m\u00b2]\",\n            \"EmbodiedCarbon [kgCO2eq/m\u00c2\u00b2]\",\n            \"EmbodiedCarbon [kgCO2eq/m\u00c3\u201a\u00c2\u00b2]\",  # noqa: RUF001\n        ),\n    )\n    EmbodiedCarbonStdDev: float = Field(\n        0,\n        title=\"Standard deviation of embodied carbon [kgCO2eq/unit]\",\n        validation_alias=\"EmbodiedCarbonStdDev\",\n        ge=0,\n    )\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.Foundation","title":"<code>Foundation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Foundation object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class Foundation(BaseModel, extra=\"ignore\"):\n    \"\"\"Foundation object.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.GasMaterial","title":"<code>GasMaterial</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MaterialWithThickness</code>, <code>StandardMaterializedMetadata</code></p> <p>Gas Material object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class GasMaterial(\n    NamedObject, MaterialWithThickness, StandardMaterializedMetadata, extra=\"forbid\"\n):\n    \"\"\"Gas Material object.\"\"\"\n\n    Model: Literal[\"Gas\"] = Field(default=\"Gas\", title=\"Model of the gas material\")\n    GasType1: str = Field(..., title=\"Type of the gas material\")\n    GasType2: str = Field(..., title=\"Type of the gas material\")\n    GasType3: str = Field(..., title=\"Type of the gas material\")\n    GasesInMix: int = Field(..., title=\"Number of gases in the mix\", ge=1)\n    Ratio1: float = Field(..., title=\"Ratio of the gas material\", ge=0, le=1)\n    Ratio2: float = Field(..., title=\"Ratio of the gas material\", ge=0, le=1)\n    Ratio3: float = Field(..., title=\"Ratio of the gas material\", ge=0, le=1)\n    ConductivityCoefficientA: float = Field(\n        ..., title=\"Conductivity coefficient A\", ge=0\n    )\n    ConductivityCoefficientB: float = Field(\n        ..., title=\"Conductivity coefficient B\", ge=0\n    )\n    ConductivityCoefficientC: float = Field(\n        ..., title=\"Conductivity coefficient C\", ge=0\n    )\n    MolecularWeight: float = Field(..., title=\"Molecular weight\", ge=0)\n    SpecificHeatCoefficientA: float = Field(\n        ..., title=\"Specific heat coefficient A\", ge=0\n    )\n    SpecificHeatCoefficientB: float = Field(\n        ..., title=\"Specific heat coefficient B\", ge=0\n    )\n    SpecificHeatCoefficientC: float = Field(\n        ..., title=\"Specific heat coefficient C\", ge=0\n    )\n    SpecificHeatRatio: float = Field(..., title=\"Specific heat ratio\", ge=0)\n    ViscosityCoefficientA: float = Field(..., title=\"Viscosity coefficient A\", ge=0)\n    ViscosityCoefficientB: float = Field(..., title=\"Viscosity coefficient B\", ge=0)\n    ViscosityCoefficientC: float = Field(..., title=\"Viscosity coefficient C\", ge=0)\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.GlazingConstructionSimple","title":"<code>GlazingConstructionSimple</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>StandardMaterializedMetadata</code>, <code>ManufacturerData</code></p> <p>Simple glazing construction object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class GlazingConstructionSimple(\n    NamedObject,\n    StandardMaterializedMetadata,\n    ManufacturerData,\n    extra=\"forbid\",\n    populate_by_name=True,\n):\n    \"\"\"Simple glazing construction object.\"\"\"\n\n    SHGF: float = Field(..., title=\"Solar heat gain factor\", ge=0, le=1)\n    UValue: float = Field(\n        ...,\n        title=\"U-value [W/m\u00b2K]\",\n        validation_alias=\"UValue [W/m2-k]\",\n        ge=0,\n    )\n    TVis: float = Field(..., title=\"Visible transmittance\", ge=0, le=1)\n    Type: WindowType = Field(..., title=\"Type of the glazing construction\")\n\n    def add_to_idf(self, idf: IDF) -&gt; IDF:\n        \"\"\"Adds the glazing construction to an IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the construction to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        glazing_mat = SimpleGlazingMaterial(\n            Name=self.Name,\n            UFactor=self.UValue,\n            Solar_Heat_Gain_Coefficient=self.SHGF,\n            Visible_Transmittance=self.TVis,\n        )\n\n        construction = Construction(\n            name=self.Name,\n            layers=[glazing_mat],\n        )\n\n        idf = construction.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.GlazingConstructionSimple.add_to_idf","title":"<code>add_to_idf(idf)</code>","text":"<p>Adds the glazing construction to an IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the construction to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_to_idf(self, idf: IDF) -&gt; IDF:\n    \"\"\"Adds the glazing construction to an IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the construction to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    glazing_mat = SimpleGlazingMaterial(\n        Name=self.Name,\n        UFactor=self.UValue,\n        Solar_Heat_Gain_Coefficient=self.SHGF,\n        Visible_Transmittance=self.TVis,\n    )\n\n    construction = Construction(\n        name=self.Name,\n        layers=[glazing_mat],\n    )\n\n    idf = construction.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.GlazingMaterial","title":"<code>GlazingMaterial</code>","text":"<p>               Bases: <code>GlazingMaterialProperties</code>, <code>MaterialWithThickness</code>, <code>StandardMaterializedMetadata</code>, <code>NamedObject</code></p> <p>Glazing material object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class GlazingMaterial(\n    GlazingMaterialProperties,\n    MaterialWithThickness,\n    StandardMaterializedMetadata,\n    NamedObject,\n    extra=\"forbid\",\n):\n    \"\"\"Glazing material object.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.GlazingMaterialProperties","title":"<code>GlazingMaterialProperties</code>","text":"<p>               Bases: <code>CommonMaterialProperties</code></p> <p>Properties of a glazing material.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class GlazingMaterialProperties(CommonMaterialProperties):\n    \"\"\"Properties of a glazing material.\"\"\"\n\n    Optical: str = Field(..., title=\"Optical properties of the glazing material\")\n    OpticalDataName: NanStr = Field(\n        ..., title=\"Optical data name of the glazing material\"\n    )\n    NFRC_ID: int = Field(..., title=\"NFRC ID of the glazing material\")\n    Glazing_ID: int = Field(..., title=\"Glazing ID of the glazing material\")\n    CoatingSide: NanStr = Field(..., title=\"Coating side of the glazing material\")\n    SpectralDataPointWavelength: FloatListStr = Field(\n        ...,\n        title=\"Spectral data point wavelength\",\n        validation_alias=\"SpectralDataPointWavelength [Microns]\",\n    )\n    SpectralDataPointTransmittance: FloatListStr = Field(\n        ...,\n        title=\"Spectral data point transmittance\",\n        validation_alias=\"SpectralDataPointTransmittance [0-1]\",\n    )\n    SpectralDataPointFrontReflectance: FloatListStr = Field(\n        ...,\n        title=\"Spectral data point front reflectance\",\n        validation_alias=\"SpectralDataPointFrontReflectance [0-1]\",\n    )\n    SpectralDataPointBackReflectance: FloatListStr = Field(\n        ...,\n        title=\"Spectral data point back reflectance\",\n        validation_alias=\"SpectralDataPointBackReflectance [0-1]\",\n    )\n    SolarTransmittance: float = Field(\n        ...,\n        title=\"Solar transmittance of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"SolarTransmittance [0-1]\",\n    )\n    SolarReflectanceFront: float = Field(\n        ...,\n        title=\"Solar reflectance front of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"SolarReflectanceFront [0-1]\",\n    )\n    SolarReflectanceBack: float = Field(\n        ...,\n        title=\"Solar reflectance back of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"SolarReflectanceBack [0-1]\",\n    )\n    VisibleTransmittance: float = Field(\n        ...,\n        title=\"Visible transmittance of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"VisibleTransmittance [0-1]\",\n    )\n    VisibleReflectanceFront: float = Field(\n        ...,\n        title=\"Visible reflectance front of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"VisibleReflectanceFront [0-1]\",\n    )\n    VisibleReflectanceBack: float = Field(\n        ...,\n        title=\"Visible reflectance back of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"VisibleReflectanceBack [0-1]\",\n    )\n    IRTransmittance: float = Field(\n        ...,\n        title=\"IR transmittance of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"IRTransmittance [0-1]\",\n    )\n    IREmissivityFront: float = Field(\n        ...,\n        title=\"IR emissivity front of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"IREmissivityFront [0-1]\",\n    )\n    IREmissivityBack: float = Field(\n        ...,\n        title=\"IR emissivity back of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"IREmissivityBack [0-1]\",\n    )\n    DirtFactor: float = Field(\n        ...,\n        title=\"Dirt factor of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"DirtFactor [0-1]\",\n    )\n    Type: str = Field(..., title=\"Type of the glazing material\")\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.LifecycleData","title":"<code>LifecycleData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Lifecycle data for a material or construction.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class LifecycleData(BaseModel):\n    \"\"\"Lifecycle data for a material or construction.\"\"\"\n\n    Cost: float = Field(\n        ...,\n        title=\"Cost [$/unit]\",\n        # a superscript 3 looks like this:\n        validation_alias=AliasChoices(\n            \"Cost [$/m\u00b3]\",\n            \"Cost [$/m3]\",\n            \"Cost [$/m\u00b2]\",\n            \"Cost [$/m2]\",\n            \"Cost [$/m]\",\n            \"Cost [$/kg]\",\n            \"Cost [$/m\u00c2\u00b2]\",\n            \"Cost [$/m\u00c3\u201a\u00c2\u00b2]\",  # noqa: RUF001\n        ),\n        ge=0,\n    )\n    Life: float = Field(\n        ...,\n        title=\"Life [years]\",\n        validation_alias=\"Life [yr]\",\n        ge=0,\n    )\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ManufacturerData","title":"<code>ManufacturerData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Manufacturer data for a construction.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ManufacturerData(BaseModel):\n    \"\"\"Manufacturer data for a construction.\"\"\"\n\n    Manufacturer: NanStr = Field(..., title=\"Manufacturer of the object\")\n    ProductName: NanStr = Field(..., title=\"Product name of the object\")\n    Appearance: NanStr = Field(..., title=\"Appearance of the glazing construction\")\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.MaterialWithThickness","title":"<code>MaterialWithThickness</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Material with a thickness.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class MaterialWithThickness(BaseModel, populate_by_name=True):\n    \"\"\"Material with a thickness.\"\"\"\n\n    Thickness: float = Field(\n        ...,\n        title=\"Thickness of the material [m]\",\n        validation_alias=\"Thickness [m]\",\n        ge=0,\n    )\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.NamedObject","title":"<code>NamedObject</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A Named object (with a name field).</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class NamedObject(BaseModel):\n    \"\"\"A Named object (with a name field).\"\"\"\n\n    Name: str = Field(..., title=\"Name of the object used in referencing.\")\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.NotImplementedClimateStudioParameter","title":"<code>NotImplementedClimateStudioParameter</code>","text":"<p>               Bases: <code>ClimateStudioException</code></p> <p>An error raised when a climate studio parameter is not implemented.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class NotImplementedClimateStudioParameter(ClimateStudioException):\n    \"\"\"An error raised when a climate studio parameter is not implemented.\"\"\"\n\n    def __init__(self, parameter_name: str, obj_name: str, obj_type: str):\n        \"\"\"Initialize the exception with a message.\n\n        Args:\n            parameter_name (str): The name of the parameter.\n            obj_name (str): The name of the object.\n            obj_type (str): The type of the object.\n        \"\"\"\n        self.parameter_name = parameter_name\n        self.obj_name = obj_name\n        self.obj_type = obj_type\n        self.message = f\"Parameter {parameter_name} not implemented for {obj_type.upper()}:{obj_name}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.NotImplementedClimateStudioParameter.__init__","title":"<code>__init__(parameter_name, obj_name, obj_type)</code>","text":"<p>Initialize the exception with a message.</p> <p>Parameters:</p> Name Type Description Default <code>parameter_name</code> <code>str</code> <p>The name of the parameter.</p> required <code>obj_name</code> <code>str</code> <p>The name of the object.</p> required <code>obj_type</code> <code>str</code> <p>The type of the object.</p> required Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def __init__(self, parameter_name: str, obj_name: str, obj_type: str):\n    \"\"\"Initialize the exception with a message.\n\n    Args:\n        parameter_name (str): The name of the parameter.\n        obj_name (str): The name of the object.\n        obj_type (str): The type of the object.\n    \"\"\"\n    self.parameter_name = parameter_name\n    self.obj_name = obj_name\n    self.obj_type = obj_type\n    self.message = f\"Parameter {parameter_name} not implemented for {obj_type.upper()}:{obj_name}\"\n    super().__init__(self.message)\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.OpaqueConstruction","title":"<code>OpaqueConstruction</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>StandardMaterializedMetadata</code>, <code>ManufacturerData</code></p> <p>Opaque construction object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class OpaqueConstruction(\n    NamedObject,\n    StandardMaterializedMetadata,\n    ManufacturerData,\n    extra=\"forbid\",\n    populate_by_name=True,\n):\n    \"\"\"Opaque construction object.\"\"\"\n\n    Layers: LayerListStr = Field(..., title=\"Layers of the opaque construction\")\n    VegetationLayer: NanStr = Field(\n        ..., title=\"Vegetation layer of the opaque construction\"\n    )\n    Type: OpaqueConstructionType = Field(..., title=\"Type of the opaque construction\")\n\n    def add_to_idf(self, idf: IDF, material_defs: dict[str, OpaqueMaterial]) -&gt; IDF:\n        \"\"\"Adds an opaque construction to an IDF object.\n\n        Note that this will add the individual materials as well.\n\n        Args:\n            idf (IDF): The IDF object to add the construction to.\n            material_defs (list[OpaqueMaterial]): List of opaque material definitions.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        layers = [layer.dereference_to_material(material_defs) for layer in self.Layers]\n\n        construction = Construction(\n            name=self.Name,\n            layers=layers,\n        )\n        idf = construction.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.OpaqueConstruction.add_to_idf","title":"<code>add_to_idf(idf, material_defs)</code>","text":"<p>Adds an opaque construction to an IDF object.</p> <p>Note that this will add the individual materials as well.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the construction to.</p> required <code>material_defs</code> <code>list[OpaqueMaterial]</code> <p>List of opaque material definitions.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_to_idf(self, idf: IDF, material_defs: dict[str, OpaqueMaterial]) -&gt; IDF:\n    \"\"\"Adds an opaque construction to an IDF object.\n\n    Note that this will add the individual materials as well.\n\n    Args:\n        idf (IDF): The IDF object to add the construction to.\n        material_defs (list[OpaqueMaterial]): List of opaque material definitions.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    layers = [layer.dereference_to_material(material_defs) for layer in self.Layers]\n\n    construction = Construction(\n        name=self.Name,\n        layers=layers,\n    )\n    idf = construction.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.OpaqueConstructionLayer","title":"<code>OpaqueConstructionLayer</code>","text":"<p>               Bases: <code>MaterialWithThickness</code>, <code>NamedObject</code></p> <p>Layer of an opaque construction.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class OpaqueConstructionLayer(MaterialWithThickness, NamedObject, extra=\"forbid\"):\n    \"\"\"Layer of an opaque construction.\"\"\"\n\n    def dereference_to_material(\n        self, material_defs: dict[str, OpaqueMaterial]\n    ) -&gt; Material:\n        \"\"\"Converts a referenced material into a direct EP material object.\n\n        Args:\n            material_defs (list[OpaqueMaterial]): List of opaque material definitions.\n\n        Returns:\n            Material: The material object.\n        \"\"\"\n        if self.Name not in material_defs:\n            raise ClimateStudioValueNotFound(\"Material\", self.Name)\n\n        mat_def = material_defs[self.Name]\n\n        material = Material(\n            Name=self.Name,\n            Thickness=self.Thickness,\n            Conductivity=mat_def.Conductivity,\n            Density=mat_def.Density,\n            Specific_Heat=mat_def.SpecificHeat,\n            Thermal_Absorptance=mat_def.ThermalAbsorptance,\n            Solar_Absorptance=mat_def.SolarAbsorptance,\n            Visible_Absorptance=mat_def.VisibleAbsorptance,\n            Roughness=mat_def.Roughness,\n        )\n        return material\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.OpaqueConstructionLayer.dereference_to_material","title":"<code>dereference_to_material(material_defs)</code>","text":"<p>Converts a referenced material into a direct EP material object.</p> <p>Parameters:</p> Name Type Description Default <code>material_defs</code> <code>list[OpaqueMaterial]</code> <p>List of opaque material definitions.</p> required <p>Returns:</p> Name Type Description <code>Material</code> <code>Material</code> <p>The material object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def dereference_to_material(\n    self, material_defs: dict[str, OpaqueMaterial]\n) -&gt; Material:\n    \"\"\"Converts a referenced material into a direct EP material object.\n\n    Args:\n        material_defs (list[OpaqueMaterial]): List of opaque material definitions.\n\n    Returns:\n        Material: The material object.\n    \"\"\"\n    if self.Name not in material_defs:\n        raise ClimateStudioValueNotFound(\"Material\", self.Name)\n\n    mat_def = material_defs[self.Name]\n\n    material = Material(\n        Name=self.Name,\n        Thickness=self.Thickness,\n        Conductivity=mat_def.Conductivity,\n        Density=mat_def.Density,\n        Specific_Heat=mat_def.SpecificHeat,\n        Thermal_Absorptance=mat_def.ThermalAbsorptance,\n        Solar_Absorptance=mat_def.SolarAbsorptance,\n        Visible_Absorptance=mat_def.VisibleAbsorptance,\n        Roughness=mat_def.Roughness,\n    )\n    return material\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.OpaqueMaterial","title":"<code>OpaqueMaterial</code>","text":"<p>               Bases: <code>OpaqueMaterialProperties</code>, <code>StandardMaterializedMetadata</code>, <code>NamedObject</code></p> <p>Opaque material object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class OpaqueMaterial(\n    OpaqueMaterialProperties,\n    StandardMaterializedMetadata,\n    NamedObject,\n    extra=\"forbid\",\n):\n    \"\"\"Opaque material object.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.OpaqueMaterialProperties","title":"<code>OpaqueMaterialProperties</code>","text":"<p>               Bases: <code>CommonMaterialProperties</code></p> <p>Properties of an opaque material.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class OpaqueMaterialProperties(CommonMaterialProperties, populate_by_name=True):\n    \"\"\"Properties of an opaque material.\"\"\"\n\n    Roughness: str = Field(..., title=\"Roughness of the opaque material\")\n    SpecificHeat: float = Field(\n        ...,\n        title=\"Specific heat [J/kgK]\",\n        validation_alias=\"SpecificHeat [J/kg.K]\",\n        ge=0,\n    )\n    ThermalAbsorptance: float = Field(\n        ...,\n        title=\"Thermal absorptance\",\n        ge=0,\n        le=1,\n        validation_alias=\"ThermalAbsorptance [0-1]\",\n    )\n    SolarAbsorptance: float = Field(\n        ...,\n        title=\"Solar absorptance\",\n        ge=0,\n        le=1,\n        validation_alias=\"SolarAbsorptance [0-1]\",\n    )\n    VisibleAbsorptance: float = Field(\n        ...,\n        title=\"Visible absorptance\",\n        ge=0,\n        le=1,\n        validation_alias=\"VisibleAbsorptance [0-1]\",\n    )\n    PhaseChange: BoolStr = Field(\n        ...,\n        title=\"Phase change\",\n        validation_alias=\"PhaseChange [Bool]\",\n    )\n    VariableConductivity: BoolStr = Field(\n        ...,\n        title=\"Variable conductivity\",\n        validation_alias=\"VariableConductivity [Bool]\",\n    )\n    TemperatureCoefficientThermalConductivity: float = Field(\n        ...,\n        # a superscript 2 looks like this:\n        title=\"Temperature coefficient of thermal conductivity [W/m.K2\u00b2]\",\n        ge=0,\n        validation_alias=\"TemperatureCoefficientThermalConductivity [W/m-K2]\",\n    )\n    TemperatureArray: FloatListStr = Field(\n        ...,\n        title=\"Temperature array\",\n        validation_alias=\"TemperatureArray [C]\",\n    )\n    EnthalpyArray: FloatListStr = Field(\n        ...,\n        title=\"Enthalpy array\",\n        validation_alias=\"EnthalpyArray [J/kg]\",\n    )\n    VariableConductivityArray: FloatListStr = Field(\n        ...,\n        title=\"Variable conductivity array\",\n        validation_alias=\"VariableConductivityArray [W/m-K]\",\n    )\n    Type: OpaqueMaterialType = Field(\n        ..., title=\"Type of the opaque material\", validation_alias=\"Type [enum]\"\n    )\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.OtherSettings","title":"<code>OtherSettings</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Other settings object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class OtherSettings(BaseModel, extra=\"ignore\"):\n    \"\"\"Other settings object.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ScheduleParseError","title":"<code>ScheduleParseError</code>","text":"<p>               Bases: <code>ClimateStudioException</code></p> <p>An error raised when a schedule cannot be parsed.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ScheduleParseError(ClimateStudioException):\n    \"\"\"An error raised when a schedule cannot be parsed.\"\"\"\n\n    def __init__(self, schedule_name: str):\n        \"\"\"Initialize the exception with a message.\n\n        Args:\n            schedule_name (str): The name of the schedule.\n        \"\"\"\n        self.schedule_name = schedule_name\n        super().__init__(f\"Failed to parse schedule {schedule_name}\")\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ScheduleParseError.__init__","title":"<code>__init__(schedule_name)</code>","text":"<p>Initialize the exception with a message.</p> <p>Parameters:</p> Name Type Description Default <code>schedule_name</code> <code>str</code> <p>The name of the schedule.</p> required Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def __init__(self, schedule_name: str):\n    \"\"\"Initialize the exception with a message.\n\n    Args:\n        schedule_name (str): The name of the schedule.\n    \"\"\"\n    self.schedule_name = schedule_name\n    super().__init__(f\"Failed to parse schedule {schedule_name}\")\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ScheduleTransferObject","title":"<code>ScheduleTransferObject</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schedule transfer object for help with de/serialization.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ScheduleTransferObject(BaseModel):\n    \"\"\"Schedule transfer object for help with de/serialization.\"\"\"\n\n    Name: str\n    Type: dict\n    Values: list[float]\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.StandardMaterializedMetadata","title":"<code>StandardMaterializedMetadata</code>","text":"<p>               Bases: <code>EmbodiedCarbonData</code>, <code>LifecycleData</code>, <code>ClimateStudioMetadata</code></p> <p>Standard metadata for a climate studio table.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class StandardMaterializedMetadata(\n    EmbodiedCarbonData, LifecycleData, ClimateStudioMetadata\n):\n    \"\"\"Standard metadata for a climate studio table.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.WindowDefinition","title":"<code>WindowDefinition</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Window definition object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class WindowDefinition(NamedObject, ClimateStudioMetadata, extra=\"ignore\"):\n    \"\"\"Window definition object.\"\"\"\n\n    Construction: str = Field(..., title=\"Construction object name\")\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        return set()\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.WindowDefinition.schedule_names","title":"<code>schedule_names: set[str]</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneConditioning","title":"<code>ZoneConditioning</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone conditioning object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ZoneConditioning(\n    NamedObject, ClimateStudioMetadata, extra=\"forbid\", populate_by_name=True\n):\n    \"\"\"Zone conditioning object.\"\"\"\n\n    HeatingSetpoint: float = Field(\n        ...,\n        title=\"Heating setpoint [\u00b0C]\",\n        validation_alias=\"HeatingSetpoint [\u00b0C]\",\n        ge=0,\n        le=100,\n    )\n    CoolingSetpoint: float = Field(\n        ...,\n        title=\"Cooling setpoint [\u00b0C]\",\n        validation_alias=\"CoolingSetpoint [\u00b0C]\",\n        ge=0,\n        le=100,\n    )\n    # TODO: should we validate heating &lt; cooling?\n    HeatingSetpointConstant: BoolStr = Field(..., title=\"Heating setpoint constant\")\n    CoolingSetpointConstant: BoolStr = Field(..., title=\"Cooling setpoint constant\")\n    HeatingSetpointSchedule: str = Field(..., title=\"Heating setpoint schedule\")\n    CoolingSetpointSchedule: str = Field(..., title=\"Cooling setpoint schedule\")\n    MinFreshAirPerson: float = Field(\n        ...,\n        title=\"Minimum fresh air per person [L/s/p]\",\n        validation_alias=\"MinFreshAirPerson [L/s/p]\",\n        ge=0,\n    )\n    MinFreshAirArea: float = Field(\n        ...,\n        title=\"Minimum fresh air per area [L/s/m\u00b2]\",\n        validation_alias=\"MinFreshAirArea [L/s/m\u00b2]\",\n        ge=0,\n    )\n    CoolingCOP: float = Field(\n        ...,\n        title=\"Cooling Coefficient of Performance\",\n        ge=0,\n    )\n    HeatingCOP: float = Field(\n        ...,\n        title=\"Heating Coefficient of Performance\",\n        ge=0,\n    )\n    HeatIsOn: BoolStr = Field(..., title=\"Heat is on\")\n    CoolIsOn: BoolStr = Field(..., title=\"Cool is on\")\n    MechVentIsOn: BoolStr = Field(..., title=\"Mechanical ventilation is on\")\n    HumidistatIsOn: BoolStr = Field(\n        ...,\n        title=\"Humidistat is on\",\n        validation_alias=\"HumidistatIsOn [Bool]\",\n    )\n    HeatingLimitType: IdealLoadsLimitType = Field(\n        ...,\n        title=\"Heating limit type\",\n        validation_alias=\"HeatingLimitType [enum]\",\n    )\n    CoolingLimitType: IdealLoadsLimitType = Field(\n        ...,\n        title=\"Cooling limit type\",\n        validation_alias=\"CoolingLimitType [enum]\",\n    )\n    MaxHeatingCapacity: float = Field(\n        ...,\n        title=\"Maximum heating capacity [W/m\u00b2]\",\n        validation_alias=\"MaxHeatingCapacity [W/m\u00b2]\",\n        ge=0,\n    )\n    MaxCoolingCapacity: float = Field(\n        ...,\n        title=\"Maximum cooling capacity [W/m\u00b2]\",\n        validation_alias=\"MaxCoolingCapacity [W/m\u00b2]\",\n        ge=0,\n    )\n    MaxHeatFlow: float = Field(\n        ...,\n        title=\"Maximum volumetric heat flow per flow area [m\u00b3/s/m\u00b2]\",\n        validation_alias=\"MaxHeatFlow [m\u00b3/s/m\u00b2]\",\n        ge=0,\n    )\n    MaxCoolFlow: float = Field(\n        ...,\n        title=\"Maximum volumetric cool flow per flow area [m\u00b3/s/m\u00b2]\",\n        validation_alias=\"MaxCoolFlow [m\u00b3/s/m\u00b2]\",\n        ge=0,\n    )\n    HeatingSchedule: str = Field(\n        ...,\n        title=\"Heating schedule\",\n        validation_alias=\"HeatingSchedule [Schedule name]\",\n    )\n    CoolingSchedule: str = Field(\n        ...,\n        title=\"Cooling schedule\",\n        validation_alias=\"CoolingSchedule [Schedule name]\",\n    )\n    MechVentSchedule: str = Field(\n        ...,\n        title=\"Mechanical ventilation schedule\",\n        validation_alias=\"MechVentSchedule [Schedule name]\",\n    )\n    EconomizerType: OutdoorAirEconomizerTypeType = Field(\n        ...,\n        title=\"Economizer type\",\n        validation_alias=\"EconomizerType [enum]\",\n    )\n    HeatRecoveryType: HeatRecoveryTypeType = Field(\n        ...,\n        title=\"Heat recovery type\",\n        validation_alias=\"HeatRecoveryType [enum]\",\n    )\n    HeatRecoveryEfficiencySensible: float = Field(\n        ...,\n        title=\"Heat recovery efficiency sensible\",\n        ge=0,\n        le=1,\n        validation_alias=\"HeatRecoveryEfficiencySensible [0-1]\",\n    )\n    HeatRecoveryEfficiencyLatent: float = Field(\n        ...,\n        title=\"Heat recovery efficiency latent\",\n        ge=0,\n        le=1,\n        validation_alias=\"HeatRecoveryEfficiencyLatent [0-1]\",\n    )\n    MinHumidity: float = Field(\n        ...,\n        title=\"Minimum humidity [%]\",\n        ge=0,\n        le=100,\n        validation_alias=\"MinHumidity [RH%]\",\n    )\n    MaxHumidity: float = Field(\n        ...,\n        title=\"Maximum humidity [%]\",\n        ge=0,\n        le=100,\n        validation_alias=\"MaxHumidity [RH%]\",\n    )\n    EMSFanEnergyIsOn: BoolStr = Field(..., title=\"EMS fan energy is on\")\n    FanPressureRise: float = Field(\n        ...,\n        title=\"Fan pressure rise [Pa]\",\n        ge=0,\n        validation_alias=\"FanPressureRise [Pa]\",\n    )\n    MaxHeatSupplyAirTemp: float = Field(\n        ...,\n        title=\"Maximum heat supply air temperature [\u00b0C]\",\n        ge=0,\n        validation_alias=\"MaxHeatSupplyAirTemp [\u00b0C]\",\n    )\n    MinCoolSupplyAirTemp: float = Field(\n        ...,\n        title=\"Minimum cool supply air temperature [\u00b0C]\",\n        ge=0,\n        validation_alias=\"MinCoolSupplyAirTemp [\u00b0C]\",\n    )\n    HeatingSizingFactor: float = Field(\n        ...,\n        title=\"Heating sizing factor\",\n        ge=0,\n        validation_alias=\"HeatingSizingFactor [Unitless]\",\n    )\n    CoolingSizingFactor: float = Field(\n        ...,\n        title=\"Cooling sizing factor\",\n        ge=0,\n        validation_alias=\"CoolingSizingFactor [Unitless]\",\n    )\n    Autosize: BoolStr = Field(\n        ...,\n        title=\"Autosize\",\n        validation_alias=\"Autosize [Bool]\",\n    )\n    HeatingFuelType: FuelType = Field(\n        ...,\n        title=\"Heating fuel type\",\n        validation_alias=\"HeatingFuelType [enum]\",\n    )\n    CoolingFuelType: FuelType = Field(\n        ...,\n        title=\"Cooling fuel type\",\n        validation_alias=\"CoolingFuelType [enum]\",\n    )\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        return {\n            self.HeatingSchedule,\n            self.CoolingSchedule,\n            self.MechVentSchedule,\n            self.HeatingSetpointSchedule,\n            self.CoolingSetpointSchedule,\n        }\n\n    def add_conditioning_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n        \"\"\"Add conditioning to an IDF zone.\n\n        This constructs HVAC template objects which get assigned to the zone.\n\n        NB: currently, many of the climate studio parameters are ignored -\n        particularly the ones related to humidity control.\n\n        Args:\n            idf (IDF): The IDF object to add the conditioning to.\n            target_zone_name (str): The name of the zone to add the conditioning to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if self.HumidistatIsOn:\n            raise NotImplementedClimateStudioParameter(\n                \"HumidistatIsOn\",\n                self.Name,\n                \"Conditioning\",\n            )\n\n        if self.EMSFanEnergyIsOn:\n            raise NotImplementedClimateStudioParameter(\n                \"EMSFanEnergyIsOn\",\n                self.Name,\n                \"Conditioning\",\n            )\n\n        thermostat = HVACTemplateThermostat(\n            Name=f\"{self.Name}_{target_zone_name}_Thermostat\",\n            Heating_Setpoint_Schedule_Name=(\n                self.HeatingSetpointSchedule\n                if not self.HeatingSetpointConstant\n                else None\n            ),\n            Cooling_Setpoint_Schedule_Name=(\n                self.CoolingSetpointSchedule\n                if not self.CoolingSetpointConstant\n                else None\n            ),\n            Constant_Cooling_Setpoint=(\n                self.CoolingSetpoint if self.CoolingSetpointConstant else None\n            ),\n            Constant_Heating_Setpoint=(\n                self.HeatingSetpoint if self.HeatingSetpointConstant else None\n            ),\n        )\n\n        # TODO: better handling of alwayson/off schedule names\n        # TODO: better handling of mech vent schedule\n        logger.warning(\n            f\"Mechanical ventilation schedule is being ignored in zone {target_zone_name}.\"\n        )\n        hvac_template = HVACTemplateZoneIdealLoadsAirSystem(\n            Zone_Name=target_zone_name,\n            Template_Thermostat_Name=thermostat.Name,\n            System_Availability_Schedule_Name=\"AlwaysOn\",\n            Heating_Availability_Schedule_Name=(\n                self.HeatingSchedule if self.HeatIsOn else \"AlwaysOff\"\n            ),\n            Cooling_Availability_Schedule_Name=(\n                self.CoolingSchedule if self.CoolIsOn else None\n            ),\n            Maximum_Heating_Supply_Air_Temperature=self.MaxHeatSupplyAirTemp,\n            Maximum_Heating_Air_Flow_Rate=self.MaxHeatFlow,\n            Maximum_Sensible_Heating_Capacity=self.MaxHeatingCapacity,\n            Minimum_Cooling_Supply_Air_Temperature=self.MinCoolSupplyAirTemp,\n            Maximum_Cooling_Air_Flow_Rate=self.MaxCoolFlow,\n            Maximum_Total_Cooling_Capacity=self.MaxCoolingCapacity,\n            Heating_Limit=self.HeatingLimitType,\n            Cooling_Limit=self.CoolingLimitType,\n            Humidification_Control_Type=\"None\",\n            Outdoor_Air_Method=\"Sum\" if self.MechVentIsOn else \"None\",\n            Outdoor_Air_Flow_Rate_per_Person=self.MinFreshAirPerson,\n            Outdoor_Air_Flow_Rate_per_Zone_Floor_Area=self.MinFreshAirArea,\n            Outdoor_Air_Flow_Rate_per_Zone=0,\n            Demand_Controlled_Ventilation_Type=\"None\",\n            Outdoor_Air_Economizer_Type=self.EconomizerType,\n            Heat_Recovery_Type=self.HeatRecoveryType,\n            Sensible_Heat_Recovery_Effectiveness=self.HeatRecoveryEfficiencySensible,\n            Latent_Heat_Recovery_Effectiveness=self.HeatRecoveryEfficiencyLatent,\n        )\n\n        idf = thermostat.add(idf)\n        idf = hvac_template.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneConditioning.schedule_names","title":"<code>schedule_names: set[str]</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneConditioning.add_conditioning_to_idf_zone","title":"<code>add_conditioning_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Add conditioning to an IDF zone.</p> <p>This constructs HVAC template objects which get assigned to the zone.</p> <p>NB: currently, many of the climate studio parameters are ignored - particularly the ones related to humidity control.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the conditioning to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the conditioning to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_conditioning_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n    \"\"\"Add conditioning to an IDF zone.\n\n    This constructs HVAC template objects which get assigned to the zone.\n\n    NB: currently, many of the climate studio parameters are ignored -\n    particularly the ones related to humidity control.\n\n    Args:\n        idf (IDF): The IDF object to add the conditioning to.\n        target_zone_name (str): The name of the zone to add the conditioning to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if self.HumidistatIsOn:\n        raise NotImplementedClimateStudioParameter(\n            \"HumidistatIsOn\",\n            self.Name,\n            \"Conditioning\",\n        )\n\n    if self.EMSFanEnergyIsOn:\n        raise NotImplementedClimateStudioParameter(\n            \"EMSFanEnergyIsOn\",\n            self.Name,\n            \"Conditioning\",\n        )\n\n    thermostat = HVACTemplateThermostat(\n        Name=f\"{self.Name}_{target_zone_name}_Thermostat\",\n        Heating_Setpoint_Schedule_Name=(\n            self.HeatingSetpointSchedule\n            if not self.HeatingSetpointConstant\n            else None\n        ),\n        Cooling_Setpoint_Schedule_Name=(\n            self.CoolingSetpointSchedule\n            if not self.CoolingSetpointConstant\n            else None\n        ),\n        Constant_Cooling_Setpoint=(\n            self.CoolingSetpoint if self.CoolingSetpointConstant else None\n        ),\n        Constant_Heating_Setpoint=(\n            self.HeatingSetpoint if self.HeatingSetpointConstant else None\n        ),\n    )\n\n    # TODO: better handling of alwayson/off schedule names\n    # TODO: better handling of mech vent schedule\n    logger.warning(\n        f\"Mechanical ventilation schedule is being ignored in zone {target_zone_name}.\"\n    )\n    hvac_template = HVACTemplateZoneIdealLoadsAirSystem(\n        Zone_Name=target_zone_name,\n        Template_Thermostat_Name=thermostat.Name,\n        System_Availability_Schedule_Name=\"AlwaysOn\",\n        Heating_Availability_Schedule_Name=(\n            self.HeatingSchedule if self.HeatIsOn else \"AlwaysOff\"\n        ),\n        Cooling_Availability_Schedule_Name=(\n            self.CoolingSchedule if self.CoolIsOn else None\n        ),\n        Maximum_Heating_Supply_Air_Temperature=self.MaxHeatSupplyAirTemp,\n        Maximum_Heating_Air_Flow_Rate=self.MaxHeatFlow,\n        Maximum_Sensible_Heating_Capacity=self.MaxHeatingCapacity,\n        Minimum_Cooling_Supply_Air_Temperature=self.MinCoolSupplyAirTemp,\n        Maximum_Cooling_Air_Flow_Rate=self.MaxCoolFlow,\n        Maximum_Total_Cooling_Capacity=self.MaxCoolingCapacity,\n        Heating_Limit=self.HeatingLimitType,\n        Cooling_Limit=self.CoolingLimitType,\n        Humidification_Control_Type=\"None\",\n        Outdoor_Air_Method=\"Sum\" if self.MechVentIsOn else \"None\",\n        Outdoor_Air_Flow_Rate_per_Person=self.MinFreshAirPerson,\n        Outdoor_Air_Flow_Rate_per_Zone_Floor_Area=self.MinFreshAirArea,\n        Outdoor_Air_Flow_Rate_per_Zone=0,\n        Demand_Controlled_Ventilation_Type=\"None\",\n        Outdoor_Air_Economizer_Type=self.EconomizerType,\n        Heat_Recovery_Type=self.HeatRecoveryType,\n        Sensible_Heat_Recovery_Effectiveness=self.HeatRecoveryEfficiencySensible,\n        Latent_Heat_Recovery_Effectiveness=self.HeatRecoveryEfficiencyLatent,\n    )\n\n    idf = thermostat.add(idf)\n    idf = hvac_template.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneConstruction","title":"<code>ZoneConstruction</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone construction object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ZoneConstruction(\n    NamedObject, ClimateStudioMetadata, extra=\"forbid\", populate_by_name=True\n):\n    \"\"\"Zone construction object.\"\"\"\n\n    RoofConstruction: str = Field(..., title=\"Roof construction object name\")\n    FacadeConstruction: str = Field(..., title=\"Facade construction object name\")\n    SlabConstruction: str = Field(..., title=\"Slab construction object name\")\n    PartitionConstruction: str = Field(..., title=\"Partition construction object name\")\n    ExternalFloorConstruction: str = Field(\n        ..., title=\"External floor construction object name\"\n    )\n    GroundSlabConstruction: str = Field(\n        ..., title=\"Ground slab construction object name\"\n    )\n    GroundWallConstruction: str = Field(\n        ..., title=\"Ground wall construction object name\"\n    )\n    InternalMassConstruction: str = Field(\n        ..., title=\"Internal mass construction object name\"\n    )\n    InternalMassIsOn: BoolStr = Field(..., title=\"Internal mass is on\")\n    InternalMassExposedAreaPerArea: float = Field(\n        ...,\n        title=\"Internal mass exposed area per area [m\u00b2/m\u00b2]\",\n        validation_alias=\"InternalMassExposedAreaPerArea [area / floor (m2/m2)]\",\n    )\n    GroundIsAdiabatic: BoolStr = Field(..., title=\"Ground is adiabatic\")\n    RoofIsAdiabatic: BoolStr = Field(..., title=\"Roof is adiabatic\")\n    FacadeIsAdiabatic: BoolStr = Field(..., title=\"Facade is adiabatic\")\n    SlabIsAdiabatic: BoolStr = Field(..., title=\"Slab is adiabatic\")\n    PartitionIsAdiabatic: BoolStr = Field(..., title=\"Partition is adiabatic\")\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneDefinition","title":"<code>ZoneDefinition</code>","text":"<p>               Bases: <code>NamedObject</code></p> <p>Zone definition object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ZoneDefinition(NamedObject, extra=\"forbid\"):\n    \"\"\"Zone definition object.\"\"\"\n\n    Loads: str = Field(..., title=\"Loads object name\")\n    Conditioning: str = Field(..., title=\"Conditioning object name\")\n    NaturalVentilation: str = Field(..., title=\"Natural ventilation object name\")\n    Constructions: str = Field(..., title=\"Construction object name\")\n    HotWater: str = Field(..., title=\"Hot water object name\")\n    Infiltration: str = Field(..., title=\"Infiltration object name\")\n    DataSource: NanStr = Field(\n        ..., title=\"Data source of the object\", validation_alias=\"Data Source\"\n    )\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneEnvelope","title":"<code>ZoneEnvelope</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone envelope object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ZoneEnvelope(NamedObject, ClimateStudioMetadata, extra=\"forbid\"):\n    \"\"\"Zone envelope object.\"\"\"\n\n    Constructions: ZoneConstruction\n    Infiltration: ZoneInfiltration\n    WindowDefinition: WindowDefinition | None\n    WWR: float | None = Field(\n        default=0.1, description=\"Window to wall ratio\", ge=0, le=1\n    )\n    Foundation: Foundation | None\n    OtherSettings: OtherSettings | None\n    BuildingType: str | int = Field(..., title=\"Building type\")\n\n    # TODO: add envelope to idf zone\n    # (currently in builder)\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        win_sch = (\n            self.WindowDefinition.schedule_names if self.WindowDefinition else set()\n        )\n        return win_sch\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneEnvelope.schedule_names","title":"<code>schedule_names: set[str]</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneHotWater","title":"<code>ZoneHotWater</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone Hot Water object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ZoneHotWater(\n    NamedObject, ClimateStudioMetadata, extra=\"ignore\", populate_by_name=True\n):\n    \"\"\"Zone Hot Water object.\"\"\"\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        return set()\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneHotWater.schedule_names","title":"<code>schedule_names: set[str]</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneInfiltration","title":"<code>ZoneInfiltration</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone infiltration object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ZoneInfiltration(\n    NamedObject, ClimateStudioMetadata, extra=\"forbid\", populate_by_name=True\n):\n    \"\"\"Zone infiltration object.\"\"\"\n\n    InfiltrationIsOn: BoolStr = Field(..., title=\"Infiltration is on\")\n    InfiltrationConstantCoefficient: float = Field(\n        ...,\n        title=\"Infiltration constant coefficient\",\n    )\n    InfiltrationTemperatureCoefficient: float = Field(\n        ...,\n        title=\"Infiltration temperature coefficient\",\n    )\n    InfiltrationWindVelocityCoefficient: float = Field(\n        ...,\n        title=\"Infiltration wind velocity coefficient\",\n    )\n    InfiltrationWindVelocitySquaredCoefficient: float = Field(\n        ...,\n        title=\"Infiltration wind velocity squared coefficient\",\n    )\n    AFN_AirMassFlowCoefficient_Crack: float = Field(\n        ...,\n        title=\"AFN air mass flow coefficient crack\",\n    )\n\n    InfiltrationAch: float = Field(\n        ...,\n        title=\"Infiltration air changes per hour\",\n        ge=0,\n        validation_alias=\"InfiltrationAch [ACH]\",\n    )\n    InfiltrationFlowPerExteriorSurfaceArea: float = Field(\n        ...,\n        title=\"Infiltration flow per exterior surface area\",\n        ge=0,\n        validation_alias=\"InfiltrationFlowPerExteriorSurfaceArea [m3/s/m2]\",\n    )\n    CalculationMethod: InfDesignFlowRateCalculationMethodType = Field(\n        ...,\n        title=\"Calculation method\",\n    )\n\n    def add_infiltration_to_idf_zone(\n        self, idf: IDF, target_zone_or_zone_list_name: str\n    ):\n        \"\"\"Add infiltration to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the infiltration to.\n            target_zone_or_zone_list_name (str): The name of the zone or zone list to add the infiltration to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        if not self.InfiltrationIsOn:\n            return idf\n\n        infiltration_schedule_name = (\n            f\"{target_zone_or_zone_list_name}_{self.Name}_Infiltration_Schedule\"\n        )\n        schedule = Schedule.constant_schedule(\n            value=1, Name=infiltration_schedule_name, Type=\"Fraction\"\n        )\n        inf_schedule, *_ = schedule.to_year_week_day()\n        inf_schedule.to_epbunch(idf)\n        inf = ZoneInfiltrationDesignFlowRate(\n            Name=f\"{target_zone_or_zone_list_name}_{self.Name}_Infiltration\",\n            Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n            Schedule_Name=inf_schedule.Name,\n            Design_Flow_Rate_Calculation_Method=self.CalculationMethod,\n            Flow_Rate_per_Exterior_Surface_Area=self.InfiltrationFlowPerExteriorSurfaceArea,\n            Air_Changes_per_Hour=self.InfiltrationAch,\n            Flow_Rate_per_Floor_Area=None,\n            Design_Flow_Rate=None,\n            Constant_Term_Coefficient=self.InfiltrationConstantCoefficient,\n            Temperature_Term_Coefficient=self.InfiltrationTemperatureCoefficient,\n            Velocity_Term_Coefficient=self.InfiltrationWindVelocityCoefficient,\n            Velocity_Squared_Term_Coefficient=self.InfiltrationWindVelocitySquaredCoefficient,\n        )\n        idf = inf.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneInfiltration.add_infiltration_to_idf_zone","title":"<code>add_infiltration_to_idf_zone(idf, target_zone_or_zone_list_name)</code>","text":"<p>Add infiltration to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the infiltration to.</p> required <code>target_zone_or_zone_list_name</code> <code>str</code> <p>The name of the zone or zone list to add the infiltration to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_infiltration_to_idf_zone(\n    self, idf: IDF, target_zone_or_zone_list_name: str\n):\n    \"\"\"Add infiltration to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the infiltration to.\n        target_zone_or_zone_list_name (str): The name of the zone or zone list to add the infiltration to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    if not self.InfiltrationIsOn:\n        return idf\n\n    infiltration_schedule_name = (\n        f\"{target_zone_or_zone_list_name}_{self.Name}_Infiltration_Schedule\"\n    )\n    schedule = Schedule.constant_schedule(\n        value=1, Name=infiltration_schedule_name, Type=\"Fraction\"\n    )\n    inf_schedule, *_ = schedule.to_year_week_day()\n    inf_schedule.to_epbunch(idf)\n    inf = ZoneInfiltrationDesignFlowRate(\n        Name=f\"{target_zone_or_zone_list_name}_{self.Name}_Infiltration\",\n        Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n        Schedule_Name=inf_schedule.Name,\n        Design_Flow_Rate_Calculation_Method=self.CalculationMethod,\n        Flow_Rate_per_Exterior_Surface_Area=self.InfiltrationFlowPerExteriorSurfaceArea,\n        Air_Changes_per_Hour=self.InfiltrationAch,\n        Flow_Rate_per_Floor_Area=None,\n        Design_Flow_Rate=None,\n        Constant_Term_Coefficient=self.InfiltrationConstantCoefficient,\n        Temperature_Term_Coefficient=self.InfiltrationTemperatureCoefficient,\n        Velocity_Term_Coefficient=self.InfiltrationWindVelocityCoefficient,\n        Velocity_Squared_Term_Coefficient=self.InfiltrationWindVelocitySquaredCoefficient,\n    )\n    idf = inf.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneLoad","title":"<code>ZoneLoad</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone load object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ZoneLoad(\n    NamedObject, ClimateStudioMetadata, extra=\"forbid\", populate_by_name=True\n):\n    \"\"\"Zone load object.\"\"\"\n\n    BuildingType: str | int = Field(..., title=\"Building type\")\n    PeopleDensity: float = Field(\n        ...,\n        title=\"People density [people/m\u00b2]\",\n        ge=0,\n        validation_alias=\"PeopleDensity [P/m\u00b2]\",\n    )\n    MetabolicRate: float = Field(\n        ...,\n        title=\"Metabolic rate [met]\",\n        ge=0,\n        validation_alias=\"MetabolicRate [met]\",\n    )\n    AirspeedSchedule: str = Field(\n        ..., title=\"Airspeed schedule\", validation_alias=\"AirspeedSchedule [m/s]\"\n    )\n    EquipmentPowerDensity: float = Field(\n        ...,\n        title=\"Equipment power density [W/m\u00b2]\",\n        ge=0,\n        validation_alias=\"EquipmentPowerDensity [W/m\u00b2]\",\n    )\n    LightingPowerDensity: float = Field(\n        ...,\n        title=\"Lighting power density [W/m\u00b2]\",\n        ge=0,\n        validation_alias=\"LightingPowerDensity [W/m\u00b2]\",\n    )\n    IlluminanceTarget: float = Field(\n        ...,\n        title=\"Illuminance target [lux]\",\n        ge=0,\n        validation_alias=\"IlluminanceTarget [Lux]\",\n    )\n    OccupancySchedule: str = Field(..., title=\"Occupancy schedule\")\n    EquipmentAvailabilitySchedule: str = Field(\n        ...,\n        title=\"Equipment availability schedule\",\n        validation_alias=\"EquipmentAvailibilitySchedule\",  # known typo in cs\n    )\n    LightsAvailabilitySchedule: str = Field(\n        ...,\n        title=\"Lighting availability schedule\",\n        validation_alias=\"LightsAvailibilitySchedule\",  # known typo in cs\n    )\n    DimmingType: DimmingTypeType = Field(\n        ...,\n        title=\"Dimming type\",\n    )\n    PeopleIsOn: BoolStr = Field(..., title=\"People are on\")\n    EquipmentIsOn: BoolStr = Field(..., title=\"Equipment is on\")\n    LightsIsOn: BoolStr = Field(..., title=\"Lights are on\")\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        return {\n            # self.AirspeedSchedule,\n            self.OccupancySchedule,\n            self.EquipmentAvailabilitySchedule,\n            self.LightsAvailabilitySchedule,\n        }\n\n    @property\n    def MetabolicRate_W(self):\n        \"\"\"Get the metabolic rate in Watts.\"\"\"\n        avg_human_weight_kg = 80\n        conversion_factor = 1.162  # W/kg\n        return self.MetabolicRate * avg_human_weight_kg * conversion_factor\n\n    def add_lights_to_idf_zone(\n        self, idf: IDF, target_zone_or_zone_list_name: str\n    ) -&gt; IDF:\n        \"\"\"Add lights to an IDF zone.\n\n        Note that this makes some assumptions about the fraction visible/radiant/replaceable.\n\n        Args:\n            idf (IDF): The IDF object to add the lights to.\n            target_zone_or_zone_list_name (str): The name of the zone or zone list to add the lights to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if not self.LightsIsOn:\n            return idf\n\n        if self.DimmingType != \"Off\":\n            raise NotImplementedClimateStudioParameter(\n                \"DimmingType:On\", self.Name, \"Lights\"\n            )\n\n        logger.warning(\n            f\"Adding lights to zone with schedule {self.LightsAvailabilitySchedule}.  Make sure this schedule exists.\"\n        )\n\n        logger.warning(\n            f\"Ignoring IlluminanceTarget for zone(s) {target_zone_or_zone_list_name}.\"\n        )\n        lights = Lights(\n            Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_Lights\",\n            Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n            Schedule_Name=self.LightsAvailabilitySchedule,\n            Design_Level_Calculation_Method=\"Watts/Area\",\n            Watts_per_Zone_Floor_Area=self.LightingPowerDensity,\n            Watts_per_Person=None,\n            Lighting_Level=None,\n            Return_Air_Fraction=0,\n            Fraction_Radiant=0.42,\n            Fraction_Visible=0.18,\n            Fraction_Replaceable=1,\n            EndUse_Subcategory=None,\n        )\n        idf = lights.add(idf)\n        return idf\n\n    def add_people_to_idf_zone(\n        self, idf: IDF, target_zone_or_zone_list_name: str\n    ) -&gt; IDF:\n        \"\"\"Add people to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the people to.\n            target_zone_or_zone_list_name (str): The name of the zone or zone list to add the people to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if not self.PeopleIsOn:\n            return idf\n\n        activity_sch_name = (\n            f\"{target_zone_or_zone_list_name}_{self.Name}_Activity_Schedule\"\n        )\n        lim = \"AnyNumber\"\n        if not idf.getobject(\"SCHEDULETYPELIMITS\", lim):\n            lim = ScheduleTypeLimits(\n                Name=\"AnyNumber\",\n                LowerLimit=None,\n                UpperLimit=None,\n            )\n            lim.to_epbunch(idf)\n        activity_sch = Schedule.from_values(\n            Values=[self.MetabolicRate_W] * 8760,\n            Name=activity_sch_name,\n            Type=lim,  # pyright: ignore [reportArgumentType]\n        )\n        activity_sch_year, *_ = activity_sch.to_year_week_day()\n        activity_sch_year.to_epbunch(idf)\n\n        logger.warning(\n            f\"Adding people to zone with schedule {self.OccupancySchedule}.  Make sure this schedule exists.\"\n        )\n        logger.warning(\n            f\"Ignoring AirspeedSchedule for zone(s) {target_zone_or_zone_list_name}.\"\n        )\n        people = People(\n            Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_People\",\n            Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n            Number_of_People_Schedule_Name=self.OccupancySchedule,\n            Number_of_People_Calculation_Method=\"People/Area\",\n            Number_of_People=None,\n            Floor_Area_per_Person=None,\n            People_per_Floor_Area=self.PeopleDensity,\n            Fraction_Radiant=0.3,\n            Sensible_Heat_Fraction=\"autocalculate\",\n            Activity_Level_Schedule_Name=activity_sch_year.Name,\n        )\n\n        idf = people.add(idf)\n        return idf\n\n    def add_equipment_to_idf_zone(\n        self, idf: IDF, target_zone_or_zone_list_name: str\n    ) -&gt; IDF:\n        \"\"\"Add equipment to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the equipment to.\n            target_zone_or_zone_list_name (str): The name of the zone or zone list to add the equipment to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if not self.EquipmentIsOn:\n            return idf\n\n        logger.warning(\n            f\"Adding equipment to zone with schedule {self.EquipmentAvailabilitySchedule}.  Make sure this schedule exists.\"\n        )\n\n        equipment = ElectricEquipment(\n            Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_Equipment\",\n            Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n            Schedule_Name=self.EquipmentAvailabilitySchedule,\n            Design_Level_Calculation_Method=\"Watts/Area\",\n            Watts_per_Zone_Floor_Area=self.EquipmentPowerDensity,\n            Watts_per_Person=None,\n            Fraction_Latent=0,\n            Fraction_Radiant=0.2,\n            Fraction_Lost=0,\n            EndUse_Subcategory=None,\n        )\n        idf = equipment.add(idf)\n        return idf\n\n    def add_loads_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n        \"\"\"Add the loads to an IDF zone.\n\n        This will add the people, equipment, and lights to the zone.\n\n        nb: remember to add the schedules.\n\n        Args:\n            idf (IDF): The IDF object to add the loads to.\n            target_zone_name (str): The name of the zone to add the loads to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        idf = self.add_lights_to_idf_zone(idf, target_zone_name)\n        idf = self.add_people_to_idf_zone(idf, target_zone_name)\n        idf = self.add_equipment_to_idf_zone(idf, target_zone_name)\n        return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneLoad.MetabolicRate_W","title":"<code>MetabolicRate_W</code>  <code>property</code>","text":"<p>Get the metabolic rate in Watts.</p>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneLoad.schedule_names","title":"<code>schedule_names: set[str]</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneLoad.add_equipment_to_idf_zone","title":"<code>add_equipment_to_idf_zone(idf, target_zone_or_zone_list_name)</code>","text":"<p>Add equipment to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the equipment to.</p> required <code>target_zone_or_zone_list_name</code> <code>str</code> <p>The name of the zone or zone list to add the equipment to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_equipment_to_idf_zone(\n    self, idf: IDF, target_zone_or_zone_list_name: str\n) -&gt; IDF:\n    \"\"\"Add equipment to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the equipment to.\n        target_zone_or_zone_list_name (str): The name of the zone or zone list to add the equipment to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if not self.EquipmentIsOn:\n        return idf\n\n    logger.warning(\n        f\"Adding equipment to zone with schedule {self.EquipmentAvailabilitySchedule}.  Make sure this schedule exists.\"\n    )\n\n    equipment = ElectricEquipment(\n        Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_Equipment\",\n        Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n        Schedule_Name=self.EquipmentAvailabilitySchedule,\n        Design_Level_Calculation_Method=\"Watts/Area\",\n        Watts_per_Zone_Floor_Area=self.EquipmentPowerDensity,\n        Watts_per_Person=None,\n        Fraction_Latent=0,\n        Fraction_Radiant=0.2,\n        Fraction_Lost=0,\n        EndUse_Subcategory=None,\n    )\n    idf = equipment.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneLoad.add_lights_to_idf_zone","title":"<code>add_lights_to_idf_zone(idf, target_zone_or_zone_list_name)</code>","text":"<p>Add lights to an IDF zone.</p> <p>Note that this makes some assumptions about the fraction visible/radiant/replaceable.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the lights to.</p> required <code>target_zone_or_zone_list_name</code> <code>str</code> <p>The name of the zone or zone list to add the lights to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_lights_to_idf_zone(\n    self, idf: IDF, target_zone_or_zone_list_name: str\n) -&gt; IDF:\n    \"\"\"Add lights to an IDF zone.\n\n    Note that this makes some assumptions about the fraction visible/radiant/replaceable.\n\n    Args:\n        idf (IDF): The IDF object to add the lights to.\n        target_zone_or_zone_list_name (str): The name of the zone or zone list to add the lights to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if not self.LightsIsOn:\n        return idf\n\n    if self.DimmingType != \"Off\":\n        raise NotImplementedClimateStudioParameter(\n            \"DimmingType:On\", self.Name, \"Lights\"\n        )\n\n    logger.warning(\n        f\"Adding lights to zone with schedule {self.LightsAvailabilitySchedule}.  Make sure this schedule exists.\"\n    )\n\n    logger.warning(\n        f\"Ignoring IlluminanceTarget for zone(s) {target_zone_or_zone_list_name}.\"\n    )\n    lights = Lights(\n        Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_Lights\",\n        Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n        Schedule_Name=self.LightsAvailabilitySchedule,\n        Design_Level_Calculation_Method=\"Watts/Area\",\n        Watts_per_Zone_Floor_Area=self.LightingPowerDensity,\n        Watts_per_Person=None,\n        Lighting_Level=None,\n        Return_Air_Fraction=0,\n        Fraction_Radiant=0.42,\n        Fraction_Visible=0.18,\n        Fraction_Replaceable=1,\n        EndUse_Subcategory=None,\n    )\n    idf = lights.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneLoad.add_loads_to_idf_zone","title":"<code>add_loads_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Add the loads to an IDF zone.</p> <p>This will add the people, equipment, and lights to the zone.</p> <p>nb: remember to add the schedules.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the loads to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the loads to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_loads_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n    \"\"\"Add the loads to an IDF zone.\n\n    This will add the people, equipment, and lights to the zone.\n\n    nb: remember to add the schedules.\n\n    Args:\n        idf (IDF): The IDF object to add the loads to.\n        target_zone_name (str): The name of the zone to add the loads to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    idf = self.add_lights_to_idf_zone(idf, target_zone_name)\n    idf = self.add_people_to_idf_zone(idf, target_zone_name)\n    idf = self.add_equipment_to_idf_zone(idf, target_zone_name)\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneLoad.add_people_to_idf_zone","title":"<code>add_people_to_idf_zone(idf, target_zone_or_zone_list_name)</code>","text":"<p>Add people to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the people to.</p> required <code>target_zone_or_zone_list_name</code> <code>str</code> <p>The name of the zone or zone list to add the people to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_people_to_idf_zone(\n    self, idf: IDF, target_zone_or_zone_list_name: str\n) -&gt; IDF:\n    \"\"\"Add people to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the people to.\n        target_zone_or_zone_list_name (str): The name of the zone or zone list to add the people to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if not self.PeopleIsOn:\n        return idf\n\n    activity_sch_name = (\n        f\"{target_zone_or_zone_list_name}_{self.Name}_Activity_Schedule\"\n    )\n    lim = \"AnyNumber\"\n    if not idf.getobject(\"SCHEDULETYPELIMITS\", lim):\n        lim = ScheduleTypeLimits(\n            Name=\"AnyNumber\",\n            LowerLimit=None,\n            UpperLimit=None,\n        )\n        lim.to_epbunch(idf)\n    activity_sch = Schedule.from_values(\n        Values=[self.MetabolicRate_W] * 8760,\n        Name=activity_sch_name,\n        Type=lim,  # pyright: ignore [reportArgumentType]\n    )\n    activity_sch_year, *_ = activity_sch.to_year_week_day()\n    activity_sch_year.to_epbunch(idf)\n\n    logger.warning(\n        f\"Adding people to zone with schedule {self.OccupancySchedule}.  Make sure this schedule exists.\"\n    )\n    logger.warning(\n        f\"Ignoring AirspeedSchedule for zone(s) {target_zone_or_zone_list_name}.\"\n    )\n    people = People(\n        Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_People\",\n        Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n        Number_of_People_Schedule_Name=self.OccupancySchedule,\n        Number_of_People_Calculation_Method=\"People/Area\",\n        Number_of_People=None,\n        Floor_Area_per_Person=None,\n        People_per_Floor_Area=self.PeopleDensity,\n        Fraction_Radiant=0.3,\n        Sensible_Heat_Fraction=\"autocalculate\",\n        Activity_Level_Schedule_Name=activity_sch_year.Name,\n    )\n\n    idf = people.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneUse","title":"<code>ZoneUse</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone use object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ZoneUse(\n    NamedObject, ClimateStudioMetadata, extra=\"forbid\", populate_by_name=True\n):\n    \"\"\"Zone use object.\"\"\"\n\n    Conditioning: ZoneConditioning\n    Loads: ZoneLoad\n    HotWater: ZoneHotWater\n\n    def add_loads_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n        \"\"\"Add the loads to an IDF zone.\n\n        This will add the people, equipment, and lights to the zone.\n\n        nb: remember to add the schedules.\n\n        Args:\n            idf (IDF): The IDF object to add the loads to.\n            target_zone_name (str): The name of the zone to add the loads to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        idf = self.Loads.add_loads_to_idf_zone(idf, target_zone_name)\n        return idf\n\n    def add_conditioning_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n        \"\"\"Add the conditioning to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the conditioning to.\n            target_zone_name (str): The name of the zone to add the conditioning to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        idf = self.Conditioning.add_conditioning_to_idf_zone(idf, target_zone_name)\n        return idf\n\n    def add_space_use_to_idf_zone(self, idf: IDF, target_zone: str | ZoneList) -&gt; IDF:\n        \"\"\"Add the use to an IDF zone.\n\n        This will add the loads and conditioning to the zone.\n\n        Args:\n            idf (IDF): The IDF object to add the use to.\n            target_zone (str | ZoneList): The name of the zone to add the use to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        loads_target = target_zone if isinstance(target_zone, str) else target_zone.Name\n        idf = self.add_loads_to_idf_zone(idf, loads_target)\n        if isinstance(target_zone, str):\n            idf = self.add_conditioning_to_idf_zone(idf, target_zone)\n        else:\n            for zone in target_zone.Names:\n                idf = self.add_conditioning_to_idf_zone(idf, zone)\n        return idf\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        return (\n            self.Loads.schedule_names\n            | self.Conditioning.schedule_names\n            | self.HotWater.schedule_names\n        )\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneUse.schedule_names","title":"<code>schedule_names: set[str]</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneUse.add_conditioning_to_idf_zone","title":"<code>add_conditioning_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Add the conditioning to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the conditioning to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the conditioning to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_conditioning_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n    \"\"\"Add the conditioning to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the conditioning to.\n        target_zone_name (str): The name of the zone to add the conditioning to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    idf = self.Conditioning.add_conditioning_to_idf_zone(idf, target_zone_name)\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneUse.add_loads_to_idf_zone","title":"<code>add_loads_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Add the loads to an IDF zone.</p> <p>This will add the people, equipment, and lights to the zone.</p> <p>nb: remember to add the schedules.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the loads to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the loads to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_loads_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n    \"\"\"Add the loads to an IDF zone.\n\n    This will add the people, equipment, and lights to the zone.\n\n    nb: remember to add the schedules.\n\n    Args:\n        idf (IDF): The IDF object to add the loads to.\n        target_zone_name (str): The name of the zone to add the loads to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    idf = self.Loads.add_loads_to_idf_zone(idf, target_zone_name)\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.ZoneUse.add_space_use_to_idf_zone","title":"<code>add_space_use_to_idf_zone(idf, target_zone)</code>","text":"<p>Add the use to an IDF zone.</p> <p>This will add the loads and conditioning to the zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the use to.</p> required <code>target_zone</code> <code>str | ZoneList</code> <p>The name of the zone to add the use to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_space_use_to_idf_zone(self, idf: IDF, target_zone: str | ZoneList) -&gt; IDF:\n    \"\"\"Add the use to an IDF zone.\n\n    This will add the loads and conditioning to the zone.\n\n    Args:\n        idf (IDF): The IDF object to add the use to.\n        target_zone (str | ZoneList): The name of the zone to add the use to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    loads_target = target_zone if isinstance(target_zone, str) else target_zone.Name\n    idf = self.add_loads_to_idf_zone(idf, loads_target)\n    if isinstance(target_zone, str):\n        idf = self.add_conditioning_to_idf_zone(idf, target_zone)\n    else:\n        for zone in target_zone.Names:\n            idf = self.add_conditioning_to_idf_zone(idf, zone)\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.extract_sch","title":"<code>extract_sch(year_schedules, schedule_name)</code>","text":"<p>Extract a schedule from a climate studio schedule dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>year_schedules</code> <code>DataFrame</code> <p>Dataframe of year schedules</p> required <code>schedule_name</code> <code>str</code> <p>Name of the schedule</p> required <p>Returns:</p> Name Type Description <code>Schedule</code> <code>Schedule</code> <p>Extracted schedule</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def extract_sch(year_schedules: pd.DataFrame, schedule_name: str) -&gt; Schedule:\n    \"\"\"Extract a schedule from a climate studio schedule dataframe.\n\n    Args:\n        year_schedules (pd.DataFrame): Dataframe of year schedules\n        schedule_name (str): Name of the schedule\n\n    Returns:\n        Schedule: Extracted schedule\n    \"\"\"\n    sched_meta = year_schedules.head(5)\n    sched_meta.index = pd.Index([\n        \"Type\",\n        \"Periodicity\",\n        \"Category\",\n        \"Data Source\",\n        \"Comment\",\n    ])\n    meta = sched_meta[schedule_name]\n    sched_type = cast(str, meta[\"Type\"])\n    last_ix = (\n        8760\n        if meta[\"Periodicity\"] == \"FullYear\"\n        else (\n            24 * 7\n            if meta[\"Periodicity\"] == \"RepeatingWeek\"\n            else (24 if meta[\"Periodicity\"] == \"RepeatingDay\" else 1)\n        )\n    )\n    sched = year_schedules[schedule_name]\n    sched_vals = sched.iloc[5:]\n    sched_vals = np.array(sched_vals[:last_ix].astype(float).values)\n    if len(sched_vals) not in [1, 24, 24 * 7, 8760]:\n        raise ScheduleParseError(schedule_name)\n    if sched_type.lower() not in [\n        \"fraction\",\n        \"temperature\",\n        \"any number\",\n        \"anynumber\",\n        \"on/off\",\n    ]:\n        raise ScheduleParseError(f\"{schedule_name}:{meta['Type']}\")\n    if sched_type.lower() in [\"any number\", \"anynumber\"]:\n        meta[\"Type\"] = ScheduleTypeLimits(\n            Name=meta[\"Type\"], LowerLimit=None, UpperLimit=None\n        )\n    n_repeats_needed = 8760 // len(sched_vals) + 1\n    repeated_schedule = np.tile(sched_vals, n_repeats_needed)[:8760]\n    sched = Schedule.from_values(\n        Name=schedule_name,\n        Values=repeated_schedule.tolist(),\n        Type=meta[\"Type\"],  # pyright: ignore [reportArgumentType]\n    )\n    return sched\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.nan_to_none_or_str","title":"<code>nan_to_none_or_str(v)</code>","text":"<p>Converts NaN to None and leaves strings as is.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Any</code> <p>Value to convert</p> required <p>Returns:</p> Name Type Description <code>v</code> <code>None | str | Any</code> <p>Converted value</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def nan_to_none_or_str(v: Any) -&gt; str | None | Any:\n    \"\"\"Converts NaN to None and leaves strings as is.\n\n    Args:\n        v (Any): Value to convert\n\n    Returns:\n        v (None | str | Any): Converted value\n    \"\"\"\n    if isinstance(v, str):\n        return v\n    if v is None:\n        return None\n    if np.isnan(v):\n        return None\n    return v\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.str_to_bool","title":"<code>str_to_bool(v)</code>","text":"<p>Converts a string to a boolean if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str | bool</code> <p>Value to convert</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Converted value</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def str_to_bool(v: str | bool) -&gt; bool:\n    \"\"\"Converts a string to a boolean if necessary.\n\n    Args:\n        v (str | bool): Value to convert\n\n    Returns:\n        bool: Converted value\n    \"\"\"\n    if isinstance(v, bool):\n        return v\n    elif v.lower() == \"true\":\n        return True\n    elif v.lower() == \"false\":\n        return False\n    else:\n        return False\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.str_to_float_list","title":"<code>str_to_float_list(v)</code>","text":"<p>Converts a string to a list of floats.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>String to convert</p> required <p>Returns:</p> Name Type Description <code>vals</code> <code>list[float]</code> <p>List of floats</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def str_to_float_list(v: str | list):\n    \"\"\"Converts a string to a list of floats.\n\n    Args:\n        v (str): String to convert\n\n    Returns:\n        vals (list[float]): List of floats\n    \"\"\"\n    if v == \"[]\":\n        return []\n    if isinstance(v, str):\n        # re should be used to parse the string -\n        # check that it starts with \"[\"  and ends with \"]\"\n        # and the elements are separated by \", \"\n        # and the elements are all ints or floats\n\n        if not re.match(r\"^\\[.*\\]$\", v):\n            raise ValueError(f\"STRING:NOT_LIST:{v}\")\n        v = v[1:-1]\n        if not re.match(r\"^[\\-0-9\\., ]*$\", v):\n            raise ValueError(f\"STRING:NOT_LIST:{v}\")\n        v = v.replace(\" \", \"\").split(\",\")\n    return [float(x) for x in v]\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.interface.str_to_opaque_layer_list","title":"<code>str_to_opaque_layer_list(v)</code>","text":"<p>Converts a string to a list of opaque construction layers.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def str_to_opaque_layer_list(v: str | list):\n    \"\"\"Converts a string to a list of opaque construction layers.\"\"\"\n    if isinstance(v, list):\n        return v\n    if v == \"[]\":\n        return []\n    list_content = v[1:-1].split(\", \")\n    names = list_content[::2]\n    thicknesses = list(map(float, list_content[1::2]))\n    return [\n        OpaqueConstructionLayer(Name=name, Thickness=thickness)\n        for name, thickness in zip(names, thicknesses, strict=False)\n    ]\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.ClimateStudioBuilderNotImplementedError","title":"<code>ClimateStudioBuilderNotImplementedError</code>","text":"<p>               Bases: <code>NotImplementedError</code></p> <p>Raised when a parameter is not yet implemented in the climate studio shoebox builder.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>class ClimateStudioBuilderNotImplementedError(NotImplementedError):\n    \"\"\"Raised when a parameter is not yet implemented in the climate studio shoebox builder.\"\"\"\n\n    def __init__(self, parameter: str):\n        \"\"\"Initialize the error.\n\n        Args:\n            parameter (str): The parameter that is not yet implemented.\n        \"\"\"\n        self.parameter = parameter\n        super().__init__(\n            f\"Parameter {parameter} is not yet implemented in the climate studio shoebox builder.\"\n        )\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.ClimateStudioBuilderNotImplementedError.__init__","title":"<code>__init__(parameter)</code>","text":"<p>Initialize the error.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>str</code> <p>The parameter that is not yet implemented.</p> required Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def __init__(self, parameter: str):\n    \"\"\"Initialize the error.\n\n    Args:\n        parameter (str): The parameter that is not yet implemented.\n    \"\"\"\n    self.parameter = parameter\n    super().__init__(\n        f\"Parameter {parameter} is not yet implemented in the climate studio shoebox builder.\"\n    )\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>BaseWeather</code></p> <p>A simple model constructor for the IDF model.</p> <p>Creates geometry as well as zone definitions.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>class Model(BaseWeather, validate_assignment=True):\n    \"\"\"A simple model constructor for the IDF model.\n\n    Creates geometry as well as zone definitions.\n    \"\"\"\n\n    geometry: ShoeboxGeometry\n    space_use_name: str\n    envelope_name: str\n    lib: ClimateStudioLibraryV2\n\n    @property\n    def space_use(self) -&gt; ZoneUse:\n        \"\"\"The space use definition for the model.\"\"\"\n        if self.space_use_name not in self.lib.SpaceUses:\n            raise KeyError(f\"MISSING:SPACE_USE:{self.space_use_name}\")\n        return self.lib.SpaceUses[self.space_use_name]\n\n    @property\n    def envelope(self) -&gt; ZoneEnvelope:\n        \"\"\"The envelope definition for the model.\"\"\"\n        if self.envelope_name not in self.lib.Envelopes:\n            raise KeyError(f\"MISSING:ENVELOPE:{self.envelope_name}\")\n\n        return self.lib.Envelopes[self.envelope_name]\n\n    async def build(self, config: SimulationPathConfig) -&gt; IDF:\n        \"\"\"Build the energy model using the Climate Studio API.\n\n        Args:\n            config (SimulationConfig): The configuration for the simulation.\n\n        Returns:\n            IDF: The built energy model.\n        \"\"\"\n        if self.geometry.basement_depth:\n            raise ClimateStudioBuilderNotImplementedError(\"basement_depth\")\n\n        if self.geometry.roof_height:\n            raise ClimateStudioBuilderNotImplementedError(\"roof_height\")\n\n        config.output_dir.mkdir(parents=True, exist_ok=True)\n        base_filepath = EnergyPlusArtifactDir / \"Minimal.idf\"\n        target_base_filepath = config.output_dir / \"Minimal.idf\"\n        shutil.copy(base_filepath, target_base_filepath)\n        epw_path, ddy_path = await self.fetch_weather(config.weather_dir)\n        idf = IDF(\n            target_base_filepath.as_posix(),\n            as_version=None,  # pyright: ignore [reportArgumentType]\n            prep_outputs=True,\n            epw=epw_path.as_posix(),\n            output_directory=config.output_dir.as_posix(),\n        )\n        ddy = IDF(\n            ddy_path.as_posix(),\n            as_version=\"9.2.0\",\n            file_version=\"9.2.0\",\n            prep_outputs=False,\n        )\n        ddy_spec = DDYSizingSpec(\n            match=False, conditions_types=[\"Summer Extreme\", \"Winter Extreme\"]\n        )\n        ddy_spec.inject_ddy(idf, ddy)\n\n        idf = add_default_sim_controls(idf)\n        idf = add_default_schedules(idf)\n\n        idf = self.geometry.add(idf)\n\n        # construct zone lists\n        idf, conditioned_zone_list, all_zones_list = self.add_zone_lists(idf)\n\n        # TODO: Handle separately ventilated attic/basement?\n        idf = self.add_space_use(idf, self.space_use, conditioned_zone_list)\n        idf = self.add_envelope(idf, self.envelope, all_zones_list)\n\n        return idf\n\n    def add_envelope(\n        self, idf: IDF, envelope: ZoneEnvelope, inf_zone_list: ZoneList\n    ) -&gt; IDF:\n        \"\"\"Add the envelope to the IDF model.\n\n        Takes care of both the constructions and infiltration and windows.\n\n        Args:\n            idf (IDF): The IDF model to add the envelope to.\n            envelope (ZoneEnvelope): The envelope template.\n            inf_zone_list (ZoneList): The list of zones to add the infiltration to.\n\n\n        Returns:\n            IDF: The IDF model with the added envelope.\n        \"\"\"\n        constructions = envelope.Constructions\n        infiltration = envelope.Infiltration\n        window_def = envelope.WindowDefinition\n        _other_settings = envelope.OtherSettings\n        _foundation_settings = envelope.Foundation\n        # TODO: other settings\n\n        self.add_srf_constructions(idf, constructions, window_def)\n        self.add_infiltration(idf, infiltration, inf_zone_list)\n\n        sch_names = self.envelope.schedule_names\n        idf = self.add_schedules_by_name(idf, sch_names)\n\n        return idf\n\n    def add_srf_constructions(\n        self,\n        idf: IDF,\n        constructions: ZoneConstruction,\n        window_def: WindowDefinition | None,\n    ) -&gt; IDF:\n        \"\"\"Assigns the constructions to the surfaces in the model.\n\n        Args:\n            idf (IDF): The IDF model to select the surfaces from.\n            constructions (ZoneConstruction): The construction template.\n            window_def (WindowDefinition): The window definition template.\n\n        Returns:\n            IDF: The IDF model with the selected surfaces.\n        \"\"\"\n        if self.geometry.basement_depth:\n            raise ClimateStudioBuilderNotImplementedError(\"basement_depth\")\n\n        if self.geometry.roof_height:\n            raise ClimateStudioBuilderNotImplementedError(\"roof_height\")\n\n        if (\n            constructions.FacadeIsAdiabatic\n            or constructions.RoofIsAdiabatic\n            or constructions.GroundIsAdiabatic\n            or constructions.PartitionIsAdiabatic\n            or constructions.SlabIsAdiabatic\n        ):\n            raise ClimateStudioBuilderNotImplementedError(\"_IsAdiabatic\")\n\n        if constructions.InternalMassIsOn:\n            raise ClimateStudioBuilderNotImplementedError(\"InternalMassIsOn\")\n\n        # outside walls are the ones with outdoor boundary condition and vertical orientation\n        def make_reversed(const: OpaqueConstruction):\n            new_const = const.model_copy(deep=True)\n            new_const.Layers = new_const.Layers[::-1]\n            new_const.Name = f\"{const.Name}_Reversed\"\n            return new_const\n\n        def reverse_construction(const_name: str, lib: ClimateStudioLibraryV2):\n            const = lib.OpaqueConstructions[const_name]\n            new_const = make_reversed(const)\n            return new_const\n\n        slab_reversed = reverse_construction(constructions.SlabConstruction, self.lib)\n        self.lib.OpaqueConstructions[slab_reversed.Name] = slab_reversed\n\n        actions = [\n            (\n                constructions.FacadeConstruction,\n                SurfaceHandler(\n                    boundary_condition=\"outdoors\",\n                    original_construction_name=\"Project Wall\",\n                    surface_type=\"opaque\",\n                ),\n            ),\n            (\n                constructions.RoofConstruction,\n                SurfaceHandler(\n                    boundary_condition=\"outdoors\",\n                    original_construction_name=\"Project Flat Roof\",\n                    surface_type=\"opaque\",\n                ),\n            ),\n            (\n                constructions.PartitionConstruction,\n                SurfaceHandler(\n                    boundary_condition=\"surface\",\n                    original_construction_name=\"Project Partition\",\n                    surface_type=\"opaque\",\n                ),\n            ),\n            (\n                slab_reversed.Name,\n                SurfaceHandler(\n                    boundary_condition=\"surface\",\n                    original_construction_name=\"Project Floor\",\n                    surface_type=\"opaque\",\n                ),\n            ),\n            (\n                constructions.SlabConstruction,\n                SurfaceHandler(\n                    boundary_condition=\"surface\",\n                    original_construction_name=\"Project Ceiling\",\n                    surface_type=\"opaque\",\n                ),\n            ),\n            (\n                constructions.GroundSlabConstruction,\n                SurfaceHandler(\n                    boundary_condition=\"ground\",\n                    original_construction_name=\"Project Floor\",\n                    surface_type=\"opaque\",\n                ),\n            ),\n        ]\n\n        # TODO: External floors, basements, etc\n\n        if window_def:\n            actions.append((\n                window_def.Construction,\n                SurfaceHandler(\n                    boundary_condition=None,\n                    original_construction_name=\"Project External Window\",\n                    surface_type=\"glazing\",\n                ),\n            ))\n\n        for const_name, action in actions:\n            idf = action.asssign_srfs(idf, self.lib, const_name)\n\n        return idf\n\n    def add_zone_lists(\n        self,\n        idf: IDF,\n    ):\n        \"\"\"Add the zone lists to the IDF model.\n\n        Note that this attempts to automatically determine\n        the zones from the IDF model which are conditioned\n        as well as a separate list for all zones.\n\n        Args:\n            idf (IDF): The IDF model to add the zone lists to.\n\n        Returns:\n            idf (IDF): The IDF model with the added zone lists\n            conditioned_zone_list (ZoneList): The list of conditioned zones\n            all_zones_list (ZoneList): The list of all zones\n        \"\"\"\n        all_zone_names = [zone.Name for zone in idf.idfobjects[\"ZONE\"]]\n        all_zones_list = ZoneList(Name=\"All_Zones\", Names=all_zone_names)\n        zone_names = [\n            zone.Name\n            for zone in idf.idfobjects[\"ZONE\"]\n            if \"attic\" not in zone.Name.lower() and not zone.Name.endswith(\"-1\")\n        ]\n\n        expected_zone_count = self.geometry.num_stories * (\n            1 if self.geometry.zoning == \"by_storey\" else 5\n        )\n        if len(zone_names) != expected_zone_count:\n            msg = f\"Expected {expected_zone_count} zones, but found {len(zone_names)}.\"\n            raise ValueError(msg)\n\n        conditioned_zone_list = ZoneList(Name=\"Conditioned_Zones\", Names=zone_names)\n        idf = conditioned_zone_list.add(idf)\n        idf = all_zones_list.add(idf)\n        return idf, conditioned_zone_list, all_zones_list\n\n    def add_infiltration(\n        self, idf: IDF, infiltration: ZoneInfiltration, zone_list: ZoneList\n    ):\n        \"\"\"Add the infiltration to the IDF model.\n\n        Args:\n            idf (IDF): The IDF model to add the infiltration to.\n            infiltration: The infiltration object.\n            zone_list (ZoneList): The list of zones to add the infiltration to.\n\n        Returns:\n            idf (IDF): The IDF model with the added infiltration.\n        \"\"\"\n        idf = infiltration.add_infiltration_to_idf_zone(idf, zone_list.Name)\n        # idf = self.add_schedules_by_name(idf, infiltration.schedule_names)\n        return idf\n\n    def add_space_use(self, idf: IDF, space_use: ZoneUse, zone_list: ZoneList) -&gt; IDF:\n        \"\"\"Add the space use to the IDF model.\n\n        Args:\n            idf (IDF): The IDF model to add the space use to.\n            space_use (ZoneUse): The zone use template.\n            zone_list (ZoneList): The list of zones to add the space use to.\n\n        Returns:\n            IDF: The IDF model with the added space use.\n        \"\"\"\n        idf = space_use.add_space_use_to_idf_zone(idf, zone_list)\n        idf = self.add_schedules_by_name(idf, space_use.schedule_names)\n        return idf\n\n    def add_schedules_by_name(self, idf: IDF, schedule_names: set[str]) -&gt; IDF:\n        \"\"\"Add schedules to the IDF model by name.\n\n        Args:\n            idf (IDF): The IDF model to add the schedules to.\n            schedule_names (set[str]): The names of the schedules to add.\n\n        Returns:\n            IDF: The IDF model with the added schedules.\n        \"\"\"\n        schedules = [self.lib.Schedules[s] for s in schedule_names]\n        for schedule in schedules:\n            yr_sch, *_ = schedule.to_year_week_day()\n            yr_sch.to_epbunch(idf)\n        return idf\n\n    async def simulate(\n        self,\n        config: SimulationPathConfig,\n        post_build_callback: Callable[[IDF], IDF] | None = None,\n    ) -&gt; tuple[IDF, Sql]:\n        \"\"\"Build and simualte the idf model.\n\n        Args:\n            config (SimulationConfig): The configuration for the simulation.\n            post_build_callback (Callable[[IDF],IDF] | None): A callback to run after the model is built.\n\n        Returns:\n            tuple[IDF, Sql]: The built energy model and the sql file.\n        \"\"\"\n        idf = await self.build(config)\n        if post_build_callback is not None:\n            idf = post_build_callback(idf)\n        idf.simulate()\n        sql = Sql(idf.sql_file)\n        return idf, sql\n\n    def get_warnings(self, idf: IDF) -&gt; str:\n        \"\"\"Get the warning text from the idf model.\n\n        Args:\n            idf (IDF): The IDF model to get the warning text from.\n\n        Returns:\n            str: The warning text.\n        \"\"\"\n        err_files = filter(\n            lambda x: x.suffix == \".err\",\n            [idf.output_directory / Path(f) for f in idf.simulation_files],\n        )\n        err_text = \"\\n\".join([f.read_text() for f in err_files])\n        return err_text\n\n    def standard_results_postprocess(self, sql: Sql, move_energy: bool) -&gt; pd.Series:\n        \"\"\"Postprocess the sql file to get the standard results.\n\n        Args:\n            sql (Sql): The sql file to postprocess.\n            move_energy (bool): Whether to move the energy to fuels based off of the CoP/Fuel Types.\n\n        Returns:\n            pd.DataFrame: The postprocessed results.\n        \"\"\"\n        res_df = sql.tabular_data_by_name(\n            \"AnnualBuildingUtilityPerformanceSummary\", \"End Uses\"\n        )\n        kWh_per_GJ = 277.778\n        res_series = (\n            res_df[\n                [\n                    \"Electricity\",\n                    \"District Cooling\",\n                    \"District Heating\",\n                ]\n            ].droplevel(-1, axis=1)\n            * kWh_per_GJ\n        ).loc[\"Total End Uses\"] / self.geometry.total_living_area\n\n        res_series.name = \"kWh/m2\"\n\n        if move_energy:\n            heat_cop = self.space_use.Conditioning.HeatingCOP\n            cool_cop = self.space_use.Conditioning.CoolingCOP\n            heat_fuel = self.space_use.Conditioning.HeatingFuelType\n            cool_fuel = self.space_use.Conditioning.CoolingFuelType\n            heat_energy = res_series[\"District Heating\"] / heat_cop\n            cool_energy = res_series[\"District Cooling\"] / cool_cop\n            if heat_fuel not in res_series.index:\n                res_series[heat_fuel] = 0\n            if cool_fuel not in res_series.index:\n                res_series[cool_fuel] = 0\n            res_series[heat_fuel] += heat_energy\n            res_series[cool_fuel] += cool_energy\n            res_series = res_series.drop([\"District Cooling\", \"District Heating\"])\n\n        return cast(pd.Series, res_series)\n\n    async def run(\n        self,\n        weather_dir: Path | None = None,\n        post_build_callback: Callable[[IDF], IDF] | None = None,\n        move_energy: bool = False,\n    ) -&gt; tuple[IDF, pd.Series, str]:\n        \"\"\"Build and simualte the idf model.\n\n        Args:\n            weather_dir (Path): The directory to store the weather files.\n            post_build_callback (Callable[[IDF],IDF] | None): A callback to run after the model is built.\n            move_energy (bool): Whether to move the energy to fuels based off of the CoP/Fuel Types.\n\n        Returns:\n            idf (IDF): The built energy model.\n            results (pd.Series): The postprocessed results.\n            err_text (str): The warning text.\n        \"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            output_dir = Path(temp_dir)\n            config = (\n                SimulationPathConfig(\n                    output_dir=output_dir,\n                    weather_dir=weather_dir,\n                )\n                if weather_dir is not None\n                else SimulationPathConfig(output_dir=output_dir)\n            )\n\n            idf, sql = await self.simulate(\n                config,\n                post_build_callback=post_build_callback,\n            )\n            results = self.standard_results_postprocess(sql, move_energy=move_energy)\n            err_text = self.get_warnings(idf)\n            return idf, results, err_text\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.Model.envelope","title":"<code>envelope: ZoneEnvelope</code>  <code>property</code>","text":"<p>The envelope definition for the model.</p>"},{"location":"modules/#epinterface.climate_studio.builder.Model.space_use","title":"<code>space_use: ZoneUse</code>  <code>property</code>","text":"<p>The space use definition for the model.</p>"},{"location":"modules/#epinterface.climate_studio.builder.Model.add_envelope","title":"<code>add_envelope(idf, envelope, inf_zone_list)</code>","text":"<p>Add the envelope to the IDF model.</p> <p>Takes care of both the constructions and infiltration and windows.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the envelope to.</p> required <code>envelope</code> <code>ZoneEnvelope</code> <p>The envelope template.</p> required <code>inf_zone_list</code> <code>ZoneList</code> <p>The list of zones to add the infiltration to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The IDF model with the added envelope.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def add_envelope(\n    self, idf: IDF, envelope: ZoneEnvelope, inf_zone_list: ZoneList\n) -&gt; IDF:\n    \"\"\"Add the envelope to the IDF model.\n\n    Takes care of both the constructions and infiltration and windows.\n\n    Args:\n        idf (IDF): The IDF model to add the envelope to.\n        envelope (ZoneEnvelope): The envelope template.\n        inf_zone_list (ZoneList): The list of zones to add the infiltration to.\n\n\n    Returns:\n        IDF: The IDF model with the added envelope.\n    \"\"\"\n    constructions = envelope.Constructions\n    infiltration = envelope.Infiltration\n    window_def = envelope.WindowDefinition\n    _other_settings = envelope.OtherSettings\n    _foundation_settings = envelope.Foundation\n    # TODO: other settings\n\n    self.add_srf_constructions(idf, constructions, window_def)\n    self.add_infiltration(idf, infiltration, inf_zone_list)\n\n    sch_names = self.envelope.schedule_names\n    idf = self.add_schedules_by_name(idf, sch_names)\n\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.Model.add_infiltration","title":"<code>add_infiltration(idf, infiltration, zone_list)</code>","text":"<p>Add the infiltration to the IDF model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the infiltration to.</p> required <code>infiltration</code> <code>ZoneInfiltration</code> <p>The infiltration object.</p> required <code>zone_list</code> <code>ZoneList</code> <p>The list of zones to add the infiltration to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The IDF model with the added infiltration.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def add_infiltration(\n    self, idf: IDF, infiltration: ZoneInfiltration, zone_list: ZoneList\n):\n    \"\"\"Add the infiltration to the IDF model.\n\n    Args:\n        idf (IDF): The IDF model to add the infiltration to.\n        infiltration: The infiltration object.\n        zone_list (ZoneList): The list of zones to add the infiltration to.\n\n    Returns:\n        idf (IDF): The IDF model with the added infiltration.\n    \"\"\"\n    idf = infiltration.add_infiltration_to_idf_zone(idf, zone_list.Name)\n    # idf = self.add_schedules_by_name(idf, infiltration.schedule_names)\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.Model.add_schedules_by_name","title":"<code>add_schedules_by_name(idf, schedule_names)</code>","text":"<p>Add schedules to the IDF model by name.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the schedules to.</p> required <code>schedule_names</code> <code>set[str]</code> <p>The names of the schedules to add.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The IDF model with the added schedules.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def add_schedules_by_name(self, idf: IDF, schedule_names: set[str]) -&gt; IDF:\n    \"\"\"Add schedules to the IDF model by name.\n\n    Args:\n        idf (IDF): The IDF model to add the schedules to.\n        schedule_names (set[str]): The names of the schedules to add.\n\n    Returns:\n        IDF: The IDF model with the added schedules.\n    \"\"\"\n    schedules = [self.lib.Schedules[s] for s in schedule_names]\n    for schedule in schedules:\n        yr_sch, *_ = schedule.to_year_week_day()\n        yr_sch.to_epbunch(idf)\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.Model.add_space_use","title":"<code>add_space_use(idf, space_use, zone_list)</code>","text":"<p>Add the space use to the IDF model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the space use to.</p> required <code>space_use</code> <code>ZoneUse</code> <p>The zone use template.</p> required <code>zone_list</code> <code>ZoneList</code> <p>The list of zones to add the space use to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The IDF model with the added space use.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def add_space_use(self, idf: IDF, space_use: ZoneUse, zone_list: ZoneList) -&gt; IDF:\n    \"\"\"Add the space use to the IDF model.\n\n    Args:\n        idf (IDF): The IDF model to add the space use to.\n        space_use (ZoneUse): The zone use template.\n        zone_list (ZoneList): The list of zones to add the space use to.\n\n    Returns:\n        IDF: The IDF model with the added space use.\n    \"\"\"\n    idf = space_use.add_space_use_to_idf_zone(idf, zone_list)\n    idf = self.add_schedules_by_name(idf, space_use.schedule_names)\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.Model.add_srf_constructions","title":"<code>add_srf_constructions(idf, constructions, window_def)</code>","text":"<p>Assigns the constructions to the surfaces in the model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to select the surfaces from.</p> required <code>constructions</code> <code>ZoneConstruction</code> <p>The construction template.</p> required <code>window_def</code> <code>WindowDefinition</code> <p>The window definition template.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The IDF model with the selected surfaces.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def add_srf_constructions(\n    self,\n    idf: IDF,\n    constructions: ZoneConstruction,\n    window_def: WindowDefinition | None,\n) -&gt; IDF:\n    \"\"\"Assigns the constructions to the surfaces in the model.\n\n    Args:\n        idf (IDF): The IDF model to select the surfaces from.\n        constructions (ZoneConstruction): The construction template.\n        window_def (WindowDefinition): The window definition template.\n\n    Returns:\n        IDF: The IDF model with the selected surfaces.\n    \"\"\"\n    if self.geometry.basement_depth:\n        raise ClimateStudioBuilderNotImplementedError(\"basement_depth\")\n\n    if self.geometry.roof_height:\n        raise ClimateStudioBuilderNotImplementedError(\"roof_height\")\n\n    if (\n        constructions.FacadeIsAdiabatic\n        or constructions.RoofIsAdiabatic\n        or constructions.GroundIsAdiabatic\n        or constructions.PartitionIsAdiabatic\n        or constructions.SlabIsAdiabatic\n    ):\n        raise ClimateStudioBuilderNotImplementedError(\"_IsAdiabatic\")\n\n    if constructions.InternalMassIsOn:\n        raise ClimateStudioBuilderNotImplementedError(\"InternalMassIsOn\")\n\n    # outside walls are the ones with outdoor boundary condition and vertical orientation\n    def make_reversed(const: OpaqueConstruction):\n        new_const = const.model_copy(deep=True)\n        new_const.Layers = new_const.Layers[::-1]\n        new_const.Name = f\"{const.Name}_Reversed\"\n        return new_const\n\n    def reverse_construction(const_name: str, lib: ClimateStudioLibraryV2):\n        const = lib.OpaqueConstructions[const_name]\n        new_const = make_reversed(const)\n        return new_const\n\n    slab_reversed = reverse_construction(constructions.SlabConstruction, self.lib)\n    self.lib.OpaqueConstructions[slab_reversed.Name] = slab_reversed\n\n    actions = [\n        (\n            constructions.FacadeConstruction,\n            SurfaceHandler(\n                boundary_condition=\"outdoors\",\n                original_construction_name=\"Project Wall\",\n                surface_type=\"opaque\",\n            ),\n        ),\n        (\n            constructions.RoofConstruction,\n            SurfaceHandler(\n                boundary_condition=\"outdoors\",\n                original_construction_name=\"Project Flat Roof\",\n                surface_type=\"opaque\",\n            ),\n        ),\n        (\n            constructions.PartitionConstruction,\n            SurfaceHandler(\n                boundary_condition=\"surface\",\n                original_construction_name=\"Project Partition\",\n                surface_type=\"opaque\",\n            ),\n        ),\n        (\n            slab_reversed.Name,\n            SurfaceHandler(\n                boundary_condition=\"surface\",\n                original_construction_name=\"Project Floor\",\n                surface_type=\"opaque\",\n            ),\n        ),\n        (\n            constructions.SlabConstruction,\n            SurfaceHandler(\n                boundary_condition=\"surface\",\n                original_construction_name=\"Project Ceiling\",\n                surface_type=\"opaque\",\n            ),\n        ),\n        (\n            constructions.GroundSlabConstruction,\n            SurfaceHandler(\n                boundary_condition=\"ground\",\n                original_construction_name=\"Project Floor\",\n                surface_type=\"opaque\",\n            ),\n        ),\n    ]\n\n    # TODO: External floors, basements, etc\n\n    if window_def:\n        actions.append((\n            window_def.Construction,\n            SurfaceHandler(\n                boundary_condition=None,\n                original_construction_name=\"Project External Window\",\n                surface_type=\"glazing\",\n            ),\n        ))\n\n    for const_name, action in actions:\n        idf = action.asssign_srfs(idf, self.lib, const_name)\n\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.Model.add_zone_lists","title":"<code>add_zone_lists(idf)</code>","text":"<p>Add the zone lists to the IDF model.</p> <p>Note that this attempts to automatically determine the zones from the IDF model which are conditioned as well as a separate list for all zones.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the zone lists to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The IDF model with the added zone lists</p> <code>conditioned_zone_list</code> <code>ZoneList</code> <p>The list of conditioned zones</p> <code>all_zones_list</code> <code>ZoneList</code> <p>The list of all zones</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def add_zone_lists(\n    self,\n    idf: IDF,\n):\n    \"\"\"Add the zone lists to the IDF model.\n\n    Note that this attempts to automatically determine\n    the zones from the IDF model which are conditioned\n    as well as a separate list for all zones.\n\n    Args:\n        idf (IDF): The IDF model to add the zone lists to.\n\n    Returns:\n        idf (IDF): The IDF model with the added zone lists\n        conditioned_zone_list (ZoneList): The list of conditioned zones\n        all_zones_list (ZoneList): The list of all zones\n    \"\"\"\n    all_zone_names = [zone.Name for zone in idf.idfobjects[\"ZONE\"]]\n    all_zones_list = ZoneList(Name=\"All_Zones\", Names=all_zone_names)\n    zone_names = [\n        zone.Name\n        for zone in idf.idfobjects[\"ZONE\"]\n        if \"attic\" not in zone.Name.lower() and not zone.Name.endswith(\"-1\")\n    ]\n\n    expected_zone_count = self.geometry.num_stories * (\n        1 if self.geometry.zoning == \"by_storey\" else 5\n    )\n    if len(zone_names) != expected_zone_count:\n        msg = f\"Expected {expected_zone_count} zones, but found {len(zone_names)}.\"\n        raise ValueError(msg)\n\n    conditioned_zone_list = ZoneList(Name=\"Conditioned_Zones\", Names=zone_names)\n    idf = conditioned_zone_list.add(idf)\n    idf = all_zones_list.add(idf)\n    return idf, conditioned_zone_list, all_zones_list\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.Model.build","title":"<code>build(config)</code>  <code>async</code>","text":"<p>Build the energy model using the Climate Studio API.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SimulationConfig</code> <p>The configuration for the simulation.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The built energy model.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>async def build(self, config: SimulationPathConfig) -&gt; IDF:\n    \"\"\"Build the energy model using the Climate Studio API.\n\n    Args:\n        config (SimulationConfig): The configuration for the simulation.\n\n    Returns:\n        IDF: The built energy model.\n    \"\"\"\n    if self.geometry.basement_depth:\n        raise ClimateStudioBuilderNotImplementedError(\"basement_depth\")\n\n    if self.geometry.roof_height:\n        raise ClimateStudioBuilderNotImplementedError(\"roof_height\")\n\n    config.output_dir.mkdir(parents=True, exist_ok=True)\n    base_filepath = EnergyPlusArtifactDir / \"Minimal.idf\"\n    target_base_filepath = config.output_dir / \"Minimal.idf\"\n    shutil.copy(base_filepath, target_base_filepath)\n    epw_path, ddy_path = await self.fetch_weather(config.weather_dir)\n    idf = IDF(\n        target_base_filepath.as_posix(),\n        as_version=None,  # pyright: ignore [reportArgumentType]\n        prep_outputs=True,\n        epw=epw_path.as_posix(),\n        output_directory=config.output_dir.as_posix(),\n    )\n    ddy = IDF(\n        ddy_path.as_posix(),\n        as_version=\"9.2.0\",\n        file_version=\"9.2.0\",\n        prep_outputs=False,\n    )\n    ddy_spec = DDYSizingSpec(\n        match=False, conditions_types=[\"Summer Extreme\", \"Winter Extreme\"]\n    )\n    ddy_spec.inject_ddy(idf, ddy)\n\n    idf = add_default_sim_controls(idf)\n    idf = add_default_schedules(idf)\n\n    idf = self.geometry.add(idf)\n\n    # construct zone lists\n    idf, conditioned_zone_list, all_zones_list = self.add_zone_lists(idf)\n\n    # TODO: Handle separately ventilated attic/basement?\n    idf = self.add_space_use(idf, self.space_use, conditioned_zone_list)\n    idf = self.add_envelope(idf, self.envelope, all_zones_list)\n\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.Model.get_warnings","title":"<code>get_warnings(idf)</code>","text":"<p>Get the warning text from the idf model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to get the warning text from.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The warning text.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def get_warnings(self, idf: IDF) -&gt; str:\n    \"\"\"Get the warning text from the idf model.\n\n    Args:\n        idf (IDF): The IDF model to get the warning text from.\n\n    Returns:\n        str: The warning text.\n    \"\"\"\n    err_files = filter(\n        lambda x: x.suffix == \".err\",\n        [idf.output_directory / Path(f) for f in idf.simulation_files],\n    )\n    err_text = \"\\n\".join([f.read_text() for f in err_files])\n    return err_text\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.Model.run","title":"<code>run(weather_dir=None, post_build_callback=None, move_energy=False)</code>  <code>async</code>","text":"<p>Build and simualte the idf model.</p> <p>Parameters:</p> Name Type Description Default <code>weather_dir</code> <code>Path</code> <p>The directory to store the weather files.</p> <code>None</code> <code>post_build_callback</code> <code>Callable[[IDF], IDF] | None</code> <p>A callback to run after the model is built.</p> <code>None</code> <code>move_energy</code> <code>bool</code> <p>Whether to move the energy to fuels based off of the CoP/Fuel Types.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The built energy model.</p> <code>results</code> <code>Series</code> <p>The postprocessed results.</p> <code>err_text</code> <code>str</code> <p>The warning text.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>async def run(\n    self,\n    weather_dir: Path | None = None,\n    post_build_callback: Callable[[IDF], IDF] | None = None,\n    move_energy: bool = False,\n) -&gt; tuple[IDF, pd.Series, str]:\n    \"\"\"Build and simualte the idf model.\n\n    Args:\n        weather_dir (Path): The directory to store the weather files.\n        post_build_callback (Callable[[IDF],IDF] | None): A callback to run after the model is built.\n        move_energy (bool): Whether to move the energy to fuels based off of the CoP/Fuel Types.\n\n    Returns:\n        idf (IDF): The built energy model.\n        results (pd.Series): The postprocessed results.\n        err_text (str): The warning text.\n    \"\"\"\n    with tempfile.TemporaryDirectory() as temp_dir:\n        output_dir = Path(temp_dir)\n        config = (\n            SimulationPathConfig(\n                output_dir=output_dir,\n                weather_dir=weather_dir,\n            )\n            if weather_dir is not None\n            else SimulationPathConfig(output_dir=output_dir)\n        )\n\n        idf, sql = await self.simulate(\n            config,\n            post_build_callback=post_build_callback,\n        )\n        results = self.standard_results_postprocess(sql, move_energy=move_energy)\n        err_text = self.get_warnings(idf)\n        return idf, results, err_text\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.Model.simulate","title":"<code>simulate(config, post_build_callback=None)</code>  <code>async</code>","text":"<p>Build and simualte the idf model.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SimulationConfig</code> <p>The configuration for the simulation.</p> required <code>post_build_callback</code> <code>Callable[[IDF], IDF] | None</code> <p>A callback to run after the model is built.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[IDF, Sql]</code> <p>tuple[IDF, Sql]: The built energy model and the sql file.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>async def simulate(\n    self,\n    config: SimulationPathConfig,\n    post_build_callback: Callable[[IDF], IDF] | None = None,\n) -&gt; tuple[IDF, Sql]:\n    \"\"\"Build and simualte the idf model.\n\n    Args:\n        config (SimulationConfig): The configuration for the simulation.\n        post_build_callback (Callable[[IDF],IDF] | None): A callback to run after the model is built.\n\n    Returns:\n        tuple[IDF, Sql]: The built energy model and the sql file.\n    \"\"\"\n    idf = await self.build(config)\n    if post_build_callback is not None:\n        idf = post_build_callback(idf)\n    idf.simulate()\n    sql = Sql(idf.sql_file)\n    return idf, sql\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.Model.standard_results_postprocess","title":"<code>standard_results_postprocess(sql, move_energy)</code>","text":"<p>Postprocess the sql file to get the standard results.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>Sql</code> <p>The sql file to postprocess.</p> required <code>move_energy</code> <code>bool</code> <p>Whether to move the energy to fuels based off of the CoP/Fuel Types.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.DataFrame: The postprocessed results.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def standard_results_postprocess(self, sql: Sql, move_energy: bool) -&gt; pd.Series:\n    \"\"\"Postprocess the sql file to get the standard results.\n\n    Args:\n        sql (Sql): The sql file to postprocess.\n        move_energy (bool): Whether to move the energy to fuels based off of the CoP/Fuel Types.\n\n    Returns:\n        pd.DataFrame: The postprocessed results.\n    \"\"\"\n    res_df = sql.tabular_data_by_name(\n        \"AnnualBuildingUtilityPerformanceSummary\", \"End Uses\"\n    )\n    kWh_per_GJ = 277.778\n    res_series = (\n        res_df[\n            [\n                \"Electricity\",\n                \"District Cooling\",\n                \"District Heating\",\n            ]\n        ].droplevel(-1, axis=1)\n        * kWh_per_GJ\n    ).loc[\"Total End Uses\"] / self.geometry.total_living_area\n\n    res_series.name = \"kWh/m2\"\n\n    if move_energy:\n        heat_cop = self.space_use.Conditioning.HeatingCOP\n        cool_cop = self.space_use.Conditioning.CoolingCOP\n        heat_fuel = self.space_use.Conditioning.HeatingFuelType\n        cool_fuel = self.space_use.Conditioning.CoolingFuelType\n        heat_energy = res_series[\"District Heating\"] / heat_cop\n        cool_energy = res_series[\"District Cooling\"] / cool_cop\n        if heat_fuel not in res_series.index:\n            res_series[heat_fuel] = 0\n        if cool_fuel not in res_series.index:\n            res_series[cool_fuel] = 0\n        res_series[heat_fuel] += heat_energy\n        res_series[cool_fuel] += cool_energy\n        res_series = res_series.drop([\"District Cooling\", \"District Heating\"])\n\n    return cast(pd.Series, res_series)\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.SimulationPathConfig","title":"<code>SimulationPathConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The configuration for the simulation's pathing.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>class SimulationPathConfig(BaseModel):\n    \"\"\"The configuration for the simulation's pathing.\"\"\"\n\n    output_dir: Path = Field(\n        default_factory=lambda: EnergyPlusArtifactDir / \"cache\" / str(uuid4())[:8],\n        description=\"The output directory for the IDF model.\",\n    )\n    weather_dir: Path = Field(\n        default_factory=lambda: EnergyPlusArtifactDir / \"cache\" / \"weather\",\n        description=\"The directory to store the weather files.\",\n    )\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.SurfaceHandler","title":"<code>SurfaceHandler</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A handler for filtering and adding surfaces to a model.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>class SurfaceHandler(BaseModel):\n    \"\"\"A handler for filtering and adding surfaces to a model.\"\"\"\n\n    boundary_condition: str | None\n    original_construction_name: str | None\n    surface_type: Literal[\"glazing\", \"opaque\"]\n\n    def asssign_srfs(\n        self, idf: IDF, lib: ClimateStudioLibraryV2, construction_name: str\n    ) -&gt; IDF:\n        \"\"\"Adds a construction (and its materials) to an IDF and assigns it to matching surfaces.\n\n        Args:\n            idf (IDF): The IDF model to add the construction to.\n            lib (ClimateStudioLibraryV2): The library of constructions.\n            construction_name (str): The name of the construction to add.\n        \"\"\"\n        srf_key = (\n            \"FENESTRATIONSURFACE:DETAILED\"\n            if self.surface_type == \"glazing\"\n            else \"BUILDINGSURFACE:DETAILED\"\n        )\n        if self.boundary_condition is not None and self.surface_type == \"glazing\":\n            raise ClimateStudioBuilderNotImplementedError(\n                f\"{self.surface_type}:BOUNDARY_CONDITON:{self.boundary_condition}\"\n            )\n\n        srfs = [\n            srf\n            for srf in idf.idfobjects[srf_key]\n            if self.check_boundary(srf) and self.check_construction_name(srf)\n        ]\n        construction_lib = (\n            lib.OpaqueConstructions\n            if self.surface_type != \"glazing\"\n            else lib.GlazingConstructions\n        )\n        if construction_name not in construction_lib:\n            raise KeyError(\n                f\"MISSING_CONSTRUCTION:{construction_name}:TARGET={self.__repr__()}\"\n            )\n        construction = construction_lib[construction_name]\n        idf = (\n            construction.add_to_idf(idf)\n            if isinstance(construction, GlazingConstructionSimple)\n            else construction.add_to_idf(idf, lib.OpaqueMaterials)\n        )\n        for srf in srfs:\n            srf.Construction_Name = construction.Name\n        return idf\n\n    def check_boundary(self, srf):\n        \"\"\"Check if the surface matches the boundary condition.\n\n        Args:\n            srf (eppy.IDF.BLOCK): The surface to check.\n\n        Returns:\n            match (bool): True if the surface matches the boundary condition.\n        \"\"\"\n        if self.surface_type == \"glazing\":\n            # Ignore the bc filter check for windows\n            return True\n        if self.boundary_condition is None:\n            # Ignore the bc filter when filter not provided\n            return True\n        # Check the boundary condition\n        return srf.Outside_Boundary_Condition == self.boundary_condition\n\n    def check_construction_name(self, srf):\n        \"\"\"Check if the surface matches the original construction name.\n\n        Args:\n            srf (eppy.IDF.BLOCK): The surface to check.\n\n        Returns:\n            match (bool): True if the surface matches the original construction name.\n        \"\"\"\n        if self.original_construction_name is None:\n            # Ignore the original construction name check when filter not provided\n            return True\n        # Check the original construction name\n        return srf.Construction_Name == self.original_construction_name\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.SurfaceHandler.asssign_srfs","title":"<code>asssign_srfs(idf, lib, construction_name)</code>","text":"<p>Adds a construction (and its materials) to an IDF and assigns it to matching surfaces.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the construction to.</p> required <code>lib</code> <code>ClimateStudioLibraryV2</code> <p>The library of constructions.</p> required <code>construction_name</code> <code>str</code> <p>The name of the construction to add.</p> required Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def asssign_srfs(\n    self, idf: IDF, lib: ClimateStudioLibraryV2, construction_name: str\n) -&gt; IDF:\n    \"\"\"Adds a construction (and its materials) to an IDF and assigns it to matching surfaces.\n\n    Args:\n        idf (IDF): The IDF model to add the construction to.\n        lib (ClimateStudioLibraryV2): The library of constructions.\n        construction_name (str): The name of the construction to add.\n    \"\"\"\n    srf_key = (\n        \"FENESTRATIONSURFACE:DETAILED\"\n        if self.surface_type == \"glazing\"\n        else \"BUILDINGSURFACE:DETAILED\"\n    )\n    if self.boundary_condition is not None and self.surface_type == \"glazing\":\n        raise ClimateStudioBuilderNotImplementedError(\n            f\"{self.surface_type}:BOUNDARY_CONDITON:{self.boundary_condition}\"\n        )\n\n    srfs = [\n        srf\n        for srf in idf.idfobjects[srf_key]\n        if self.check_boundary(srf) and self.check_construction_name(srf)\n    ]\n    construction_lib = (\n        lib.OpaqueConstructions\n        if self.surface_type != \"glazing\"\n        else lib.GlazingConstructions\n    )\n    if construction_name not in construction_lib:\n        raise KeyError(\n            f\"MISSING_CONSTRUCTION:{construction_name}:TARGET={self.__repr__()}\"\n        )\n    construction = construction_lib[construction_name]\n    idf = (\n        construction.add_to_idf(idf)\n        if isinstance(construction, GlazingConstructionSimple)\n        else construction.add_to_idf(idf, lib.OpaqueMaterials)\n    )\n    for srf in srfs:\n        srf.Construction_Name = construction.Name\n    return idf\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.SurfaceHandler.check_boundary","title":"<code>check_boundary(srf)</code>","text":"<p>Check if the surface matches the boundary condition.</p> <p>Parameters:</p> Name Type Description Default <code>srf</code> <code>BLOCK</code> <p>The surface to check.</p> required <p>Returns:</p> Name Type Description <code>match</code> <code>bool</code> <p>True if the surface matches the boundary condition.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def check_boundary(self, srf):\n    \"\"\"Check if the surface matches the boundary condition.\n\n    Args:\n        srf (eppy.IDF.BLOCK): The surface to check.\n\n    Returns:\n        match (bool): True if the surface matches the boundary condition.\n    \"\"\"\n    if self.surface_type == \"glazing\":\n        # Ignore the bc filter check for windows\n        return True\n    if self.boundary_condition is None:\n        # Ignore the bc filter when filter not provided\n        return True\n    # Check the boundary condition\n    return srf.Outside_Boundary_Condition == self.boundary_condition\n</code></pre>"},{"location":"modules/#epinterface.climate_studio.builder.SurfaceHandler.check_construction_name","title":"<code>check_construction_name(srf)</code>","text":"<p>Check if the surface matches the original construction name.</p> <p>Parameters:</p> Name Type Description Default <code>srf</code> <code>BLOCK</code> <p>The surface to check.</p> required <p>Returns:</p> Name Type Description <code>match</code> <code>bool</code> <p>True if the surface matches the original construction name.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def check_construction_name(self, srf):\n    \"\"\"Check if the surface matches the original construction name.\n\n    Args:\n        srf (eppy.IDF.BLOCK): The surface to check.\n\n    Returns:\n        match (bool): True if the surface matches the original construction name.\n    \"\"\"\n    if self.original_construction_name is None:\n        # Ignore the original construction name check when filter not provided\n        return True\n    # Check the original construction name\n    return srf.Construction_Name == self.original_construction_name\n</code></pre>"}]}