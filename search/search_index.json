{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"epinterface","text":"<p>This is a repository for dynamically generating energy models within Python, relying on Archetypal and Eppy for most of its functionality.</p>"},{"location":"modules/actions/","title":"Actions","text":"<p>Actions are a way to mutate an object, typically used for defining retrofits for building energy models in this library.</p> <p>Actions to modify a library object.</p>"},{"location":"modules/actions/#epinterface.climate_studio.actions.Action","title":"<code>Action</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>An action to modify a library object.</p> <p>This base class should be inherited by classes that represent actions to modify a library object. It provides an abstract method <code>run</code> that should be implemented by subclasses to perform the modification.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>class Action(BaseModel, Generic[T]):\n    \"\"\"An action to modify a library object.\n\n    This base class should be inherited by classes that represent actions to modify\n    a library object. It provides an abstract method `run` that should be implemented\n    by subclasses to perform the modification.\n    \"\"\"\n\n    target: ParameterPath[T] = Field(\n        ..., description=\"The path to the parameter to modify.\"\n    )\n    priority: Priority | None = Field(\n        default=None,\n        description=\"The priority of the action (low will execute if the new value is less than the old value).\",\n    )\n\n    def run(self, lib: LibT) -&gt; LibT:\n        \"\"\"Run the action to modify the library object.\n\n        Args:\n            lib (LibT): The library object to modify.\n\n        Returns:\n            lib (LibT): The modified library object.\n        \"\"\"\n        new_val = self.new_val(lib)\n        original_val = self.get_original_val(lib)\n        if self.check_priority(original_val, new_val):\n            original_obj = self.get_original_obj(lib)\n            key = self.original_key\n            set_dict_val_or_attr(original_obj, key, new_val)\n        return lib\n\n    def check_priority(self, original: T, new: T) -&gt; bool:\n        \"\"\"Check if the new value should be applied based on the action priority.\n\n        Args:\n            original (T): The original value in the library object.\n            new (T): The new value to apply.\n\n        Returns:\n            apply (bool): True if the new value should be applied, False otherwise.\n        \"\"\"\n        if self.priority is None:\n            return True\n\n        if not isinstance(original, int | float) or not isinstance(new, int | float):\n            msg = \"priority comparison only supported for numerical values.\"\n            raise TypeError(msg)\n\n        if self.priority == \"low\":\n            return original &gt; new\n\n        elif self.priority == \"high\":\n            return original &lt; new\n        else:\n            msg = f\"Invalid priority value: {self.priority}\"\n            raise ValueError(msg)\n\n    def get_original_val(self, lib: LibT) -&gt; T:\n        \"\"\"Retrieve the original value from the library object.\n\n        Args:\n            lib (LibT): The library object from which to retrieve the original value.\n\n        Returns:\n            val (T): The original value from the library object.\n        \"\"\"\n        return self.target.get_lib_val(lib)\n\n    @property\n    def original_key(self) -&gt; str | int | ParameterPath:\n        \"\"\"Retrieve the key of the original value in the library object.\n\n        Returns:\n            key (str | int | ParameterPath): The key of the original value in the library object.\n        \"\"\"\n        # TODO: handle cases where final key is a ParameterPath!!\n        return self.target.path[-1]\n\n    def get_original_obj(self, lib: LibT):\n        \"\"\"Retrieve the object containing the original value in the library object.\n\n        Args:\n            lib (LibT): The library object from which to retrieve the original object.\n\n        Returns:\n            obj (Any): The object containing the original value in the library object.\n        \"\"\"\n        return self.target.parent_path.get_lib_val(lib)\n\n    @abstractmethod\n    def new_val(self, lib: LibT) -&gt; T:\n        \"\"\"Calculate the new value to apply to the library object.\n\n        NB: This method should be implemented by subclasses to calculate the new value.\n\n        Args:\n            lib (LibT): The library object on which to apply the new value.\n\n        Returns:\n            val (T): The new value to apply to the library object.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.Action.original_key","title":"<code>original_key: str | int | ParameterPath</code>  <code>property</code>","text":"<p>Retrieve the key of the original value in the library object.</p> <p>Returns:</p> Name Type Description <code>key</code> <code>str | int | ParameterPath</code> <p>The key of the original value in the library object.</p>"},{"location":"modules/actions/#epinterface.climate_studio.actions.Action.check_priority","title":"<code>check_priority(original, new)</code>","text":"<p>Check if the new value should be applied based on the action priority.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>T</code> <p>The original value in the library object.</p> required <code>new</code> <code>T</code> <p>The new value to apply.</p> required <p>Returns:</p> Name Type Description <code>apply</code> <code>bool</code> <p>True if the new value should be applied, False otherwise.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>def check_priority(self, original: T, new: T) -&gt; bool:\n    \"\"\"Check if the new value should be applied based on the action priority.\n\n    Args:\n        original (T): The original value in the library object.\n        new (T): The new value to apply.\n\n    Returns:\n        apply (bool): True if the new value should be applied, False otherwise.\n    \"\"\"\n    if self.priority is None:\n        return True\n\n    if not isinstance(original, int | float) or not isinstance(new, int | float):\n        msg = \"priority comparison only supported for numerical values.\"\n        raise TypeError(msg)\n\n    if self.priority == \"low\":\n        return original &gt; new\n\n    elif self.priority == \"high\":\n        return original &lt; new\n    else:\n        msg = f\"Invalid priority value: {self.priority}\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.Action.get_original_obj","title":"<code>get_original_obj(lib)</code>","text":"<p>Retrieve the object containing the original value in the library object.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library object from which to retrieve the original object.</p> required <p>Returns:</p> Name Type Description <code>obj</code> <code>Any</code> <p>The object containing the original value in the library object.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>def get_original_obj(self, lib: LibT):\n    \"\"\"Retrieve the object containing the original value in the library object.\n\n    Args:\n        lib (LibT): The library object from which to retrieve the original object.\n\n    Returns:\n        obj (Any): The object containing the original value in the library object.\n    \"\"\"\n    return self.target.parent_path.get_lib_val(lib)\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.Action.get_original_val","title":"<code>get_original_val(lib)</code>","text":"<p>Retrieve the original value from the library object.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library object from which to retrieve the original value.</p> required <p>Returns:</p> Name Type Description <code>val</code> <code>T</code> <p>The original value from the library object.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>def get_original_val(self, lib: LibT) -&gt; T:\n    \"\"\"Retrieve the original value from the library object.\n\n    Args:\n        lib (LibT): The library object from which to retrieve the original value.\n\n    Returns:\n        val (T): The original value from the library object.\n    \"\"\"\n    return self.target.get_lib_val(lib)\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.Action.new_val","title":"<code>new_val(lib)</code>  <code>abstractmethod</code>","text":"<p>Calculate the new value to apply to the library object.</p> <p>NB: This method should be implemented by subclasses to calculate the new value.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library object on which to apply the new value.</p> required <p>Returns:</p> Name Type Description <code>val</code> <code>T</code> <p>The new value to apply to the library object.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>@abstractmethod\ndef new_val(self, lib: LibT) -&gt; T:\n    \"\"\"Calculate the new value to apply to the library object.\n\n    NB: This method should be implemented by subclasses to calculate the new value.\n\n    Args:\n        lib (LibT): The library object on which to apply the new value.\n\n    Returns:\n        val (T): The new value to apply to the library object.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.Action.run","title":"<code>run(lib)</code>","text":"<p>Run the action to modify the library object.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library object to modify.</p> required <p>Returns:</p> Name Type Description <code>lib</code> <code>LibT</code> <p>The modified library object.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>def run(self, lib: LibT) -&gt; LibT:\n    \"\"\"Run the action to modify the library object.\n\n    Args:\n        lib (LibT): The library object to modify.\n\n    Returns:\n        lib (LibT): The modified library object.\n    \"\"\"\n    new_val = self.new_val(lib)\n    original_val = self.get_original_val(lib)\n    if self.check_priority(original_val, new_val):\n        original_obj = self.get_original_obj(lib)\n        key = self.original_key\n        set_dict_val_or_attr(original_obj, key, new_val)\n    return lib\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.ActionSequence","title":"<code>ActionSequence</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A sequence of actions to perform on a library object.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>class ActionSequence(BaseModel):\n    \"\"\"A sequence of actions to perform on a library object.\"\"\"\n\n    name: str = Field(..., description=\"The name of the action sequence.\")\n    actions: list[\"DeltaVal | ReplaceWithExisting | ReplaceWithVal\"] = (\n        Field(  # TODO: should we allow nested actionsequences?\n            ..., description=\"A sequence of actions to perform on a library object.\"\n        )\n    )\n\n    def run(self, lib: LibT) -&gt; LibT:\n        \"\"\"Run the sequence of actions on the library object.\n\n        Args:\n            lib (LibT): The library object to modify.\n\n        Returns:\n            lib (LibT): The modified library object.\n        \"\"\"\n        for action in self.actions:\n            lib = action.run(lib)\n        return lib\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.ActionSequence.run","title":"<code>run(lib)</code>","text":"<p>Run the sequence of actions on the library object.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library object to modify.</p> required <p>Returns:</p> Name Type Description <code>lib</code> <code>LibT</code> <p>The modified library object.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>def run(self, lib: LibT) -&gt; LibT:\n    \"\"\"Run the sequence of actions on the library object.\n\n    Args:\n        lib (LibT): The library object to modify.\n\n    Returns:\n        lib (LibT): The modified library object.\n    \"\"\"\n    for action in self.actions:\n        lib = action.run(lib)\n    return lib\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.DeltaVal","title":"<code>DeltaVal</code>","text":"<p>               Bases: <code>Action[Numeric]</code></p> <p>Add a value to a parameter in a library object.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>class DeltaVal(Action[Numeric]):\n    \"\"\"Add a value to a parameter in a library object.\"\"\"\n\n    delta: Numeric = Field(\n        ..., description=\"The value to modify to the original value.\"\n    )\n    op: Operation = Field(\n        ..., description=\"The operation to perform on the original value.\"\n    )\n\n    def new_val(self, lib: LibT) -&gt; Numeric:\n        \"\"\"Calculate a new value by combining the original value from the given library with a delta.\n\n        Args:\n            lib (LibT): The library from which to retrieve the original value.\n\n        Returns:\n            new_val (Numeric): The new value obtained by combining the original value with the delta.\n        \"\"\"\n        original_val = self.get_original_val(lib)\n\n        return self.combine(original_val, self.delta)\n\n    @property\n    def combine(self) -&gt; Callable[[Numeric, Numeric], Numeric]:\n        \"\"\"Combines two numeric values based on the specified operation.\n\n        Supported operations:\n            - \"+\": Addition\n            - \"*\": Multiplication\n\n        Returns:\n            fn (Callable[[Numeric, Numeric], Numeric]): A function that takes two numeric arguments and returns a numeric result.\n\n        Raises:\n            ValueError: If the operation specified by `self.op` is not supported.\n\n        \"\"\"\n        if self.op == \"+\":\n            return lambda x, y: x + y\n        elif self.op == \"*\":\n            return lambda x, y: x * y\n        else:\n            msg = f\"Invalid operation: {self.op}\"\n            raise ValueError(msg)\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.DeltaVal.combine","title":"<code>combine: Callable[[Numeric, Numeric], Numeric]</code>  <code>property</code>","text":"<p>Combines two numeric values based on the specified operation.</p> Supported operations <ul> <li>\"+\": Addition</li> <li>\"*\": Multiplication</li> </ul> <p>Returns:</p> Name Type Description <code>fn</code> <code>Callable[[Numeric, Numeric], Numeric]</code> <p>A function that takes two numeric arguments and returns a numeric result.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operation specified by <code>self.op</code> is not supported.</p>"},{"location":"modules/actions/#epinterface.climate_studio.actions.DeltaVal.new_val","title":"<code>new_val(lib)</code>","text":"<p>Calculate a new value by combining the original value from the given library with a delta.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library from which to retrieve the original value.</p> required <p>Returns:</p> Name Type Description <code>new_val</code> <code>Numeric</code> <p>The new value obtained by combining the original value with the delta.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>def new_val(self, lib: LibT) -&gt; Numeric:\n    \"\"\"Calculate a new value by combining the original value from the given library with a delta.\n\n    Args:\n        lib (LibT): The library from which to retrieve the original value.\n\n    Returns:\n        new_val (Numeric): The new value obtained by combining the original value with the delta.\n    \"\"\"\n    original_val = self.get_original_val(lib)\n\n    return self.combine(original_val, self.delta)\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.ParameterPath","title":"<code>ParameterPath</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>Pathing to find a parameter in a library/object.</p> <p>ParameterPath is a generic class that represents a path consisting of strings, integers, or other ParameterPath instances. It provides methods to resolve the path and retrieve values from a given library.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>class ParameterPath(BaseModel, Generic[T]):\n    \"\"\"Pathing to find a parameter in a library/object.\n\n    ParameterPath is a generic class that represents a path consisting of strings, integers,\n    or other ParameterPath instances. It provides methods to resolve the path and retrieve\n    values from a given library.\n    \"\"\"\n\n    path: list[\"str | int | ParameterPath[str] | ParameterPath[int]\"] = Field(\n        ..., description=\"The path to the parameter to select.\"\n    )\n\n    def resolved_path(self, lib: LibT):\n        \"\"\"Resolve the path to the parameter in the library.\n\n        Args:\n            lib (LibT): The library to search for the parameter.\n\n        Returns:\n            path (list[Any]): The resolved path to the parameter in the library.\n        \"\"\"\n        return [\n            p if isinstance(p, str | int) else p.get_lib_val(lib) for p in self.path\n        ]\n\n    def get_lib_val(self, lib: LibT) -&gt; T:\n        \"\"\"Retrieves a value from a nested dictionary or object attribute path.\n\n        Args:\n            lib (LibT): The library object from which to retrieve the value.\n\n        Returns:\n            val (T): The value retrieved from the nested dictionary or object attribute path.\n        \"\"\"\n        return cast(T, reduce(get_dict_val_or_attr, self.resolved_path(lib), lib))\n\n    @property\n    def parent_path(self):\n        \"\"\"Returns the parent path of the current path.\n\n        Returns:\n            parent_path (ParameterPath): The parent path of the current path.\n        \"\"\"\n        # TODO: how can we type-narrow the generic parameterpath here?\n        # get the parent using the similar reduction technique as before\n        return ParameterPath[Any](path=self.path[:-1])\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.ParameterPath.parent_path","title":"<code>parent_path</code>  <code>property</code>","text":"<p>Returns the parent path of the current path.</p> <p>Returns:</p> Name Type Description <code>parent_path</code> <code>ParameterPath</code> <p>The parent path of the current path.</p>"},{"location":"modules/actions/#epinterface.climate_studio.actions.ParameterPath.get_lib_val","title":"<code>get_lib_val(lib)</code>","text":"<p>Retrieves a value from a nested dictionary or object attribute path.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library object from which to retrieve the value.</p> required <p>Returns:</p> Name Type Description <code>val</code> <code>T</code> <p>The value retrieved from the nested dictionary or object attribute path.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>def get_lib_val(self, lib: LibT) -&gt; T:\n    \"\"\"Retrieves a value from a nested dictionary or object attribute path.\n\n    Args:\n        lib (LibT): The library object from which to retrieve the value.\n\n    Returns:\n        val (T): The value retrieved from the nested dictionary or object attribute path.\n    \"\"\"\n    return cast(T, reduce(get_dict_val_or_attr, self.resolved_path(lib), lib))\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.ParameterPath.resolved_path","title":"<code>resolved_path(lib)</code>","text":"<p>Resolve the path to the parameter in the library.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library to search for the parameter.</p> required <p>Returns:</p> Name Type Description <code>path</code> <code>list[Any]</code> <p>The resolved path to the parameter in the library.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>def resolved_path(self, lib: LibT):\n    \"\"\"Resolve the path to the parameter in the library.\n\n    Args:\n        lib (LibT): The library to search for the parameter.\n\n    Returns:\n        path (list[Any]): The resolved path to the parameter in the library.\n    \"\"\"\n    return [\n        p if isinstance(p, str | int) else p.get_lib_val(lib) for p in self.path\n    ]\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.ReplaceWithExisting","title":"<code>ReplaceWithExisting</code>","text":"<p>               Bases: <code>Action[T]</code></p> <p>Replace a value in a library object with a value from another location in the library.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>class ReplaceWithExisting(Action[T]):\n    \"\"\"Replace a value in a library object with a value from another location in the library.\"\"\"\n\n    source: ParameterPath[T]\n\n    def new_val(self, lib: LibT) -&gt; T:\n        \"\"\"Retrieve the value from the source path to replace the target value.\n\n        Args:\n            lib (LibT): The library object from which to retrieve the new value.\n\n        Returns:\n            val (T): The new value to replace the target value.\n        \"\"\"\n        return self.source.get_lib_val(lib)\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.ReplaceWithExisting.new_val","title":"<code>new_val(lib)</code>","text":"<p>Retrieve the value from the source path to replace the target value.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library object from which to retrieve the new value.</p> required <p>Returns:</p> Name Type Description <code>val</code> <code>T</code> <p>The new value to replace the target value.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>def new_val(self, lib: LibT) -&gt; T:\n    \"\"\"Retrieve the value from the source path to replace the target value.\n\n    Args:\n        lib (LibT): The library object from which to retrieve the new value.\n\n    Returns:\n        val (T): The new value to replace the target value.\n    \"\"\"\n    return self.source.get_lib_val(lib)\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.ReplaceWithVal","title":"<code>ReplaceWithVal</code>","text":"<p>               Bases: <code>Action[T]</code></p> <p>Replace a value in a library object with a new value.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>class ReplaceWithVal(Action[T]):\n    \"\"\"Replace a value in a library object with a new value.\"\"\"\n\n    val: T\n\n    def new_val(self, lib: LibT) -&gt; T:\n        \"\"\"Returns the current value of the instance to use for updating.\n\n        Args:\n            lib (LibT): A library instance of type LibT.\n\n        Returns:\n            val (T): The current value of the instance.\n        \"\"\"\n        return self.val\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.ReplaceWithVal.new_val","title":"<code>new_val(lib)</code>","text":"<p>Returns the current value of the instance to use for updating.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>A library instance of type LibT.</p> required <p>Returns:</p> Name Type Description <code>val</code> <code>T</code> <p>The current value of the instance.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>def new_val(self, lib: LibT) -&gt; T:\n    \"\"\"Returns the current value of the instance to use for updating.\n\n    Args:\n        lib (LibT): A library instance of type LibT.\n\n    Returns:\n        val (T): The current value of the instance.\n    \"\"\"\n    return self.val\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.get_dict_val_or_attr","title":"<code>get_dict_val_or_attr(obj, key)</code>","text":"<p>Retrieve a value from a dictionary or list, or an attribute from an object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[dict, list, Any]</code> <p>The object from which to retrieve the value or attribute.</p> required <code>key</code> <code>Any</code> <p>The key or attribute name to retrieve.</p> required <p>Returns:</p> Name Type Description <code>val</code> <code>Any</code> <p>The value associated with the key if <code>obj</code> is a dictionary or list,  or the attribute value if <code>obj</code> is an object.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>def get_dict_val_or_attr(obj, key):\n    \"\"\"Retrieve a value from a dictionary or list, or an attribute from an object.\n\n    Args:\n        obj (Union[dict, list, Any]): The object from which to retrieve the value or attribute.\n        key (Any): The key or attribute name to retrieve.\n\n    Returns:\n        val (Any): The value associated with the key if `obj` is a dictionary or list,\n             or the attribute value if `obj` is an object.\n    \"\"\"\n    if isinstance(obj, dict | list):\n        return obj[key]\n    else:\n        return getattr(obj, key)\n</code></pre>"},{"location":"modules/actions/#epinterface.climate_studio.actions.set_dict_val_or_attr","title":"<code>set_dict_val_or_attr(obj, key, val)</code>","text":"<p>Sets a value in a dictionary or list, or sets an attribute on an object.</p> <p>If the provided object is a dictionary or list, the function sets the value at the specified key or index. If the object is not a dictionary or list, the function sets an attribute on the object with the specified key and value.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[dict, list, object]</code> <p>The object to modify.</p> required <code>key</code> <code>Union[str, int]</code> <p>The key or attribute name to set.</p> required <code>val</code> <code>Any</code> <p>The value to set.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the object is a list and the key is not an integer.</p> Source code in <code>epinterface\\climate_studio\\actions.py</code> <pre><code>def set_dict_val_or_attr(obj, key, val):\n    \"\"\"Sets a value in a dictionary or list, or sets an attribute on an object.\n\n    If the provided object is a dictionary or list, the function sets the value\n    at the specified key or index. If the object is not a dictionary or list,\n    the function sets an attribute on the object with the specified key and value.\n\n    Args:\n        obj (Union[dict, list, object]): The object to modify.\n        key (Union[str, int]): The key or attribute name to set.\n        val (Any): The value to set.\n\n    Raises:\n        TypeError: If the object is a list and the key is not an integer.\n    \"\"\"\n    if isinstance(obj, dict | list):\n        obj[key] = val\n    else:\n        setattr(obj, key, val)\n</code></pre>"},{"location":"modules/builder/","title":"ClimateStudio Model Builder","text":"<p>A module for building the energy model using the Climate Studio API.</p>"},{"location":"modules/builder/#epinterface.climate_studio.builder.ClimateStudioBuilderNotImplementedError","title":"<code>ClimateStudioBuilderNotImplementedError</code>","text":"<p>               Bases: <code>NotImplementedError</code></p> <p>Raised when a parameter is not yet implemented in the climate studio shoebox builder.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>class ClimateStudioBuilderNotImplementedError(NotImplementedError):\n    \"\"\"Raised when a parameter is not yet implemented in the climate studio shoebox builder.\"\"\"\n\n    def __init__(self, parameter: str):\n        \"\"\"Initialize the error.\n\n        Args:\n            parameter (str): The parameter that is not yet implemented.\n        \"\"\"\n        self.parameter = parameter\n        super().__init__(\n            f\"Parameter {parameter} is not yet implemented in the climate studio shoebox builder.\"\n        )\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.ClimateStudioBuilderNotImplementedError.__init__","title":"<code>__init__(parameter)</code>","text":"<p>Initialize the error.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>str</code> <p>The parameter that is not yet implemented.</p> required Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def __init__(self, parameter: str):\n    \"\"\"Initialize the error.\n\n    Args:\n        parameter (str): The parameter that is not yet implemented.\n    \"\"\"\n    self.parameter = parameter\n    super().__init__(\n        f\"Parameter {parameter} is not yet implemented in the climate studio shoebox builder.\"\n    )\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>BaseWeather</code></p> <p>A simple model constructor for the IDF model.</p> <p>Creates geometry as well as zone definitions.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>class Model(BaseWeather, validate_assignment=True):\n    \"\"\"A simple model constructor for the IDF model.\n\n    Creates geometry as well as zone definitions.\n    \"\"\"\n\n    geometry: ShoeboxGeometry\n    space_use_name: str\n    envelope_name: str\n    conditioned_basement: bool = False\n    lib: ClimateStudioLibraryV2\n\n    @property\n    def space_use(self) -&gt; ZoneUse:\n        \"\"\"The space use definition for the model.\"\"\"\n        if self.space_use_name not in self.lib.SpaceUses:\n            raise KeyError(f\"MISSING:SPACE_USE:{self.space_use_name}\")\n        return self.lib.SpaceUses[self.space_use_name]\n\n    @property\n    def envelope(self) -&gt; ZoneEnvelope:\n        \"\"\"The envelope definition for the model.\"\"\"\n        if self.envelope_name not in self.lib.Envelopes:\n            raise KeyError(f\"MISSING:ENVELOPE:{self.envelope_name}\")\n\n        return self.lib.Envelopes[self.envelope_name]\n\n    @property\n    def total_conditioned_area(self) -&gt; float:\n        \"\"\"The total conditioned area of the model.\n\n        Returns:\n            float: The total conditioned area of the model.\n        \"\"\"\n        return self.geometry.total_living_area + (\n            self.geometry.footprint_area\n            if self.geometry.basement and self.conditioned_basement\n            else 0\n        )\n\n    @property\n    def total_people(self) -&gt; float:\n        \"\"\"The total number of people in the model.\n\n        Returns:\n            ppl (float): The total number of people in the model\n\n        \"\"\"\n        ppl_per_m2 = (\n            self.space_use.Loads.PeopleDensity if self.space_use.Loads.PeopleIsOn else 0\n        )\n        total_area = self.total_conditioned_area\n        total_ppl = ppl_per_m2 * total_area\n        return total_ppl\n\n    def compute_dhw(self) -&gt; float:\n        \"\"\"Compute the domestic hot water energy demand.\n\n        Returns:\n            energy (float): The domestic hot water energy demand (kWh/m2)\n        \"\"\"\n        # TODO: this should be computed from the DHW schedule\n        if not self.space_use.HotWater.IsOn:\n            return 0\n        flow_rate_per_person = self.space_use.HotWater.FlowRatePerPerson  # m3/hr/person\n        temperature_rise = (\n            self.space_use.HotWater.WaterSupplyTemperature\n            - self.space_use.HotWater.WaterTemperatureInlet\n        )  # K\n        water_density = 1000  # kg/m3\n        c = 4186  # J/kg.K\n        total_flow_rate = flow_rate_per_person * self.total_people  # m3/hr\n        total_volume = total_flow_rate * 8760  # m3 / yr\n        total_energy = total_volume * temperature_rise * water_density * c  # J / yr\n        total_energy_kWh = total_energy / 3600000  # kWh / yr\n        total_energy_kWh_per_m2 = (\n            total_energy_kWh / self.total_conditioned_area\n        )  # kWh/m2 / yr\n        return total_energy_kWh_per_m2\n\n    def build(self, config: SimulationPathConfig) -&gt; IDF:\n        \"\"\"Build the energy model using the Climate Studio API.\n\n        Args:\n            config (SimulationConfig): The configuration for the simulation.\n\n        Returns:\n            IDF: The built energy model.\n        \"\"\"\n        if (not self.geometry.basement) and self.conditioned_basement:\n            raise ValueError(\"CONDITIONEDBASEMENT:TRUE:BASEMENT:FALSE\")\n\n        if self.geometry.roof_height:\n            raise ClimateStudioBuilderNotImplementedError(\"roof_height\")\n        config.output_dir.mkdir(parents=True, exist_ok=True)\n        base_filepath = EnergyPlusArtifactDir / \"Minimal.idf\"\n        target_base_filepath = config.output_dir / \"Minimal.idf\"\n        shutil.copy(base_filepath, target_base_filepath)\n        epw_path, ddy_path = asyncio.run(self.fetch_weather(config.weather_dir))\n        idf = IDF(\n            target_base_filepath.as_posix(),\n            as_version=None,  # pyright: ignore [reportArgumentType]\n            prep_outputs=True,\n            epw=epw_path.as_posix(),\n            output_directory=config.output_dir.as_posix(),\n        )\n        ddy = IDF(\n            ddy_path.as_posix(),\n            as_version=\"9.2.0\",\n            file_version=\"9.2.0\",\n            prep_outputs=False,\n        )\n        ddy_spec = DDYSizingSpec(\n            match=False, conditions_types=[\"Summer Extreme\", \"Winter Extreme\"]\n        )\n        ddy_spec.inject_ddy(idf, ddy)\n\n        idf = add_default_sim_controls(idf)\n        idf, scheds = add_default_schedules(idf)\n        self.lib.Schedules.update(scheds)\n\n        idf = SiteGroundTemperature.FromValues([\n            18.3,\n            18.2,\n            18.3,\n            18.4,\n            20.1,\n            22.0,\n            22.3,\n            22.5,\n            22.5,\n            20.7,\n            18.9,\n            18.5,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 7.9,\n            # 6.05,\n            # 5.65,\n            # 6.21,\n            # 8.98,\n            # 11.97,\n            # 14.71,\n            # 16.62,\n            # 17.06,\n            # 15.98,\n            # 13.61,\n            # 10.71,\n            # 1.11,\n            # 0.1,\n            # 1.89,\n            # 4.69,\n            # 12.02,\n            # 17.68,\n            # 21.5,\n            # 22.66,\n            # 20.68,\n            # 16.29,\n            # 10.42,\n            # 4.97,\n        ]).add(idf)\n\n        idf = self.geometry.add(idf)\n\n        # construct zone lists\n        idf, conditioned_zone_list, all_zones_list = self.add_zone_lists(idf)\n\n        # TODO: Handle separately ventilated attic/basement?\n        idf = self.add_space_use(idf, self.space_use, conditioned_zone_list)\n        idf = self.add_envelope(idf, self.envelope, all_zones_list)\n\n        return idf\n\n    def add_hot_water_to_zone_list(\n        self, idf: IDF, space_use: ZoneUse, zone_list: ZoneList\n    ) -&gt; IDF:\n        \"\"\"Add the hot water to the zone list.\n\n        Args:\n            idf (IDF): The IDF model to add the hot water to.\n            space_use (ZoneUse): The zone use template.\n            zone_list (ZoneList): The list of zones to add the hot water to.\n\n        Returns:\n            idf (IDF): The IDF model with the added hot water.\n        \"\"\"\n        for zone_name in zone_list.Names:\n            idf = self.add_hot_water_to_zone(idf, space_use, zone_name)\n        return idf\n\n    def add_hot_water_to_zone(\n        self, idf: IDF, space_use: ZoneUse, zone_name: str\n    ) -&gt; IDF:\n        \"\"\"Add the hot water to the zone.\n\n        Args:\n            idf (IDF): The IDF model to add the hot water to.\n            space_use (ZoneUse): The zone use template.\n            zone_name (str): The name of the zone to add the hot water to.\n\n        Returns:\n            idf (IDF): The IDF model with the added hot water.\n        \"\"\"\n        zone = next(filter(lambda x: x.Name == zone_name, idf.idfobjects[\"ZONE\"]), None)\n        if zone is None:\n            raise ValueError(f\"NO_ZONE:{zone_name}\")\n        area = 0\n        area_ct = 0\n        for srf in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]:\n            if srf.Zone_Name == zone.Name and srf.Surface_Type.lower() == \"floor\":\n                poly = Polygon(srf.coords)\n                area += poly.area\n                area_ct += 1\n        if area_ct &gt; 1:\n            raise ValueError(f\"TOO_MANY_FLOORS:{zone.Name}\")\n        if area == 0 or area_ct == 0:\n            raise ValueError(f\"NO_AREA:{zone.Name}\")\n        ppl_density = space_use.Loads.PeopleDensity\n        total_ppl = ppl_density * area\n        idf = space_use.HotWater.add_water_to_idf_zone(idf, zone.Name, total_ppl)\n        return idf\n\n    def add_envelope(\n        self, idf: IDF, envelope: ZoneEnvelope, inf_zone_list: ZoneList\n    ) -&gt; IDF:\n        \"\"\"Add the envelope to the IDF model.\n\n        Takes care of both the constructions and infiltration and windows.\n\n        Args:\n            idf (IDF): The IDF model to add the envelope to.\n            envelope (ZoneEnvelope): The envelope template.\n            inf_zone_list (ZoneList): The list of zones to add the infiltration to.\n\n\n        Returns:\n            IDF: The IDF model with the added envelope.\n        \"\"\"\n        constructions = envelope.Constructions\n        infiltration = envelope.Infiltration\n        window_def = envelope.WindowDefinition\n        _other_settings = envelope.OtherSettings\n        _foundation_settings = envelope.Foundation\n        # TODO: other settings\n\n        self.add_srf_constructions(idf, constructions, window_def)\n        self.add_infiltration(idf, infiltration, inf_zone_list)\n\n        sch_names = self.envelope.schedule_names\n        idf = self.add_schedules_by_name(idf, sch_names)\n\n        return idf\n\n    def add_srf_constructions(\n        self,\n        idf: IDF,\n        constructions: ZoneConstruction,\n        window_def: WindowDefinition | None,\n    ) -&gt; IDF:\n        \"\"\"Assigns the constructions to the surfaces in the model.\n\n        Args:\n            idf (IDF): The IDF model to select the surfaces from.\n            constructions (ZoneConstruction): The construction template.\n            window_def (WindowDefinition): The window definition template.\n\n        Returns:\n            IDF: The IDF model with the selected surfaces.\n        \"\"\"\n        if self.geometry.roof_height:\n            raise ClimateStudioBuilderNotImplementedError(\"roof_height\")\n\n        if (\n            constructions.FacadeIsAdiabatic\n            or constructions.RoofIsAdiabatic\n            or constructions.GroundIsAdiabatic\n            or constructions.PartitionIsAdiabatic\n            or constructions.SlabIsAdiabatic\n        ):\n            raise ClimateStudioBuilderNotImplementedError(\"_IsAdiabatic\")\n\n        if constructions.InternalMassIsOn:\n            raise ClimateStudioBuilderNotImplementedError(\"InternalMassIsOn\")\n\n        handlers = SurfaceHandlers.Default()\n        idf = handlers.handle_envelope(idf, self.lib, constructions, window_def)\n\n        return idf\n\n    def add_zone_lists(\n        self,\n        idf: IDF,\n    ):\n        \"\"\"Add the zone lists to the IDF model.\n\n        Note that this attempts to automatically determine\n        the zones from the IDF model which are conditioned\n        as well as a separate list for all zones.\n\n        Args:\n            idf (IDF): The IDF model to add the zone lists to.\n\n        Returns:\n            idf (IDF): The IDF model with the added zone lists\n            conditioned_zone_list (ZoneList): The list of conditioned zones\n            all_zones_list (ZoneList): The list of all zones\n        \"\"\"\n        all_zone_names = [zone.Name for zone in idf.idfobjects[\"ZONE\"]]\n        all_zones_list = ZoneList(Name=\"All_Zones\", Names=all_zone_names)\n        conditioned_zone_names = [\n            zone.Name\n            for zone in idf.idfobjects[\"ZONE\"]\n            if \"attic\" not in zone.Name.lower()\n            and (\n                not zone.Name.lower().endswith(self.geometry.basement_suffix.lower())\n                if ((not self.conditioned_basement) and self.geometry.basement)\n                else True\n            )\n        ]\n\n        conditioned_storey_count = self.geometry.num_stories + (\n            1 if self.conditioned_basement else 0\n        )\n        zones_per_storey = 1 if self.geometry.zoning == \"by_storey\" else 5\n        expected_zone_count = conditioned_storey_count * zones_per_storey\n        if len(conditioned_zone_names) != expected_zone_count:\n            msg = f\"Expected {expected_zone_count} zones, but found {len(conditioned_zone_names)}.\"\n            raise ValueError(msg)\n\n        conditioned_zone_list = ZoneList(\n            Name=\"Conditioned_Zones\", Names=conditioned_zone_names\n        )\n        idf = conditioned_zone_list.add(idf)\n        idf = all_zones_list.add(idf)\n        return idf, conditioned_zone_list, all_zones_list\n\n    def add_infiltration(\n        self, idf: IDF, infiltration: ZoneInfiltration, zone_list: ZoneList\n    ):\n        \"\"\"Add the infiltration to the IDF model.\n\n        Args:\n            idf (IDF): The IDF model to add the infiltration to.\n            infiltration: The infiltration object.\n            zone_list (ZoneList): The list of zones to add the infiltration to.\n\n        Returns:\n            idf (IDF): The IDF model with the added infiltration.\n        \"\"\"\n        idf = infiltration.add_infiltration_to_idf_zone(idf, zone_list.Name)\n        # idf = self.add_schedules_by_name(idf, infiltration.schedule_names)\n        return idf\n\n    def add_space_use(self, idf: IDF, space_use: ZoneUse, zone_list: ZoneList) -&gt; IDF:\n        \"\"\"Add the space use to the IDF model.\n\n        Args:\n            idf (IDF): The IDF model to add the space use to.\n            space_use (ZoneUse): The zone use template.\n            zone_list (ZoneList): The list of zones to add the space use to.\n\n        Returns:\n            IDF: The IDF model with the added space use.\n        \"\"\"\n        idf = space_use.add_space_use_to_idf_zone(idf, zone_list)\n        idf = self.add_hot_water_to_zone_list(idf, space_use, zone_list)\n        idf = self.add_schedules_by_name(idf, space_use.schedule_names)\n        return idf\n\n    def add_schedules_by_name(self, idf: IDF, schedule_names: set[str]) -&gt; IDF:\n        \"\"\"Add schedules to the IDF model by name.\n\n        Args:\n            idf (IDF): The IDF model to add the schedules to.\n            schedule_names (set[str]): The names of the schedules to add.\n\n        Returns:\n            IDF: The IDF model with the added schedules.\n        \"\"\"\n        schedules = [self.lib.Schedules[s] for s in schedule_names]\n        for schedule in schedules:\n            yr_sch, *_ = schedule.to_year_week_day()\n            yr_sch.to_epbunch(idf)\n        return idf\n\n    def simulate(\n        self,\n        config: SimulationPathConfig,\n        post_build_callback: Callable[[IDF], IDF] | None = None,\n    ) -&gt; tuple[IDF, Sql]:\n        \"\"\"Build and simualte the idf model.\n\n        Args:\n            config (SimulationConfig): The configuration for the simulation.\n            post_build_callback (Callable[[IDF],IDF] | None): A callback to run after the model is built.\n\n        Returns:\n            tuple[IDF, Sql]: The built energy model and the sql file.\n        \"\"\"\n        idf = self.build(config)\n        if post_build_callback is not None:\n            idf = post_build_callback(idf)\n        idf.simulate()\n        sql = Sql(idf.sql_file)\n        return idf, sql\n\n    def get_warnings(self, idf: IDF) -&gt; str:\n        \"\"\"Get the warning text from the idf model.\n\n        Args:\n            idf (IDF): The IDF model to get the warning text from.\n\n        Returns:\n            str: The warning text.\n        \"\"\"\n        err_files = filter(\n            lambda x: x.suffix == \".err\",\n            [idf.output_directory / Path(f) for f in idf.simulation_files],\n        )\n        err_text = \"\\n\".join([f.read_text() for f in err_files])\n        return err_text\n\n    def standard_results_postprocess(self, sql: Sql, move_energy: bool) -&gt; pd.Series:\n        \"\"\"Postprocess the sql file to get the standard results.\n\n        Args:\n            sql (Sql): The sql file to postprocess.\n            move_energy (bool): Whether to move the energy to fuels based off of the CoP/Fuel Types.\n\n        Returns:\n            pd.DataFrame: The postprocessed results.\n        \"\"\"\n        res_df = sql.tabular_data_by_name(\n            \"AnnualBuildingUtilityPerformanceSummary\", \"End Uses\"\n        )\n        kWh_per_GJ = 277.778\n        res_df = (\n            res_df[\n                [\n                    \"Electricity\",\n                    \"District Cooling\",\n                    \"District Heating\",\n                ]\n            ].droplevel(-1, axis=1)\n            * kWh_per_GJ\n        ) / self.total_conditioned_area\n        res_series_hot_water = res_df.loc[\"Water Systems\"]\n        res_series = res_df.loc[\"Total End Uses\"] - res_series_hot_water\n        res_series[\"Domestic Hot Water\"] = res_series_hot_water.sum()\n\n        res_series.name = \"kWh/m2\"\n\n        if move_energy:\n            heat_cop = self.space_use.Conditioning.HeatingCOP\n            cool_cop = self.space_use.Conditioning.CoolingCOP\n            dhw_cop = self.space_use.HotWater.DomHotWaterCOP\n            heat_fuel = self.space_use.Conditioning.HeatingFuelType\n            cool_fuel = self.space_use.Conditioning.CoolingFuelType\n            dhw_fuel = self.space_use.HotWater.HotWaterFuelType\n            heat_energy = res_series[\"District Heating\"] / heat_cop\n            cool_energy = res_series[\"District Cooling\"] / cool_cop\n            dhw_energy = res_series[\"Domestic Hot Water\"] / dhw_cop\n            if heat_fuel not in res_series.index:\n                res_series[heat_fuel] = 0\n            if cool_fuel not in res_series.index:\n                res_series[cool_fuel] = 0\n            if dhw_fuel not in res_series.index:\n                res_series[dhw_fuel] = 0\n            res_series[heat_fuel] += heat_energy\n            res_series[cool_fuel] += cool_energy\n            res_series[dhw_fuel] += dhw_energy\n            res_series = res_series.drop([\n                \"District Cooling\",\n                \"District Heating\",\n                \"Domestic Hot Water\",\n            ])\n\n        return cast(pd.Series, res_series)\n\n    def run(\n        self,\n        weather_dir: Path | None = None,\n        post_build_callback: Callable[[IDF], IDF] | None = None,\n        move_energy: bool = False,\n    ) -&gt; tuple[IDF, pd.Series, str]:\n        \"\"\"Build and simualte the idf model.\n\n        Args:\n            weather_dir (Path): The directory to store the weather files.\n            post_build_callback (Callable[[IDF],IDF] | None): A callback to run after the model is built.\n            move_energy (bool): Whether to move the energy to fuels based off of the CoP/Fuel Types.\n\n        Returns:\n            idf (IDF): The built energy model.\n            results (pd.Series): The postprocessed results.\n            err_text (str): The warning text.\n        \"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            output_dir = Path(temp_dir)\n            config = (\n                SimulationPathConfig(\n                    output_dir=output_dir,\n                    weather_dir=weather_dir,\n                )\n                if weather_dir is not None\n                else SimulationPathConfig(output_dir=output_dir)\n            )\n\n            idf, sql = self.simulate(\n                config,\n                post_build_callback=post_build_callback,\n            )\n            results = self.standard_results_postprocess(sql, move_energy=move_energy)\n            err_text = self.get_warnings(idf)\n            return idf, results, err_text\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.envelope","title":"<code>envelope: ZoneEnvelope</code>  <code>property</code>","text":"<p>The envelope definition for the model.</p>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.space_use","title":"<code>space_use: ZoneUse</code>  <code>property</code>","text":"<p>The space use definition for the model.</p>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.total_conditioned_area","title":"<code>total_conditioned_area: float</code>  <code>property</code>","text":"<p>The total conditioned area of the model.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The total conditioned area of the model.</p>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.total_people","title":"<code>total_people: float</code>  <code>property</code>","text":"<p>The total number of people in the model.</p> <p>Returns:</p> Name Type Description <code>ppl</code> <code>float</code> <p>The total number of people in the model</p>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.add_envelope","title":"<code>add_envelope(idf, envelope, inf_zone_list)</code>","text":"<p>Add the envelope to the IDF model.</p> <p>Takes care of both the constructions and infiltration and windows.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the envelope to.</p> required <code>envelope</code> <code>ZoneEnvelope</code> <p>The envelope template.</p> required <code>inf_zone_list</code> <code>ZoneList</code> <p>The list of zones to add the infiltration to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The IDF model with the added envelope.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def add_envelope(\n    self, idf: IDF, envelope: ZoneEnvelope, inf_zone_list: ZoneList\n) -&gt; IDF:\n    \"\"\"Add the envelope to the IDF model.\n\n    Takes care of both the constructions and infiltration and windows.\n\n    Args:\n        idf (IDF): The IDF model to add the envelope to.\n        envelope (ZoneEnvelope): The envelope template.\n        inf_zone_list (ZoneList): The list of zones to add the infiltration to.\n\n\n    Returns:\n        IDF: The IDF model with the added envelope.\n    \"\"\"\n    constructions = envelope.Constructions\n    infiltration = envelope.Infiltration\n    window_def = envelope.WindowDefinition\n    _other_settings = envelope.OtherSettings\n    _foundation_settings = envelope.Foundation\n    # TODO: other settings\n\n    self.add_srf_constructions(idf, constructions, window_def)\n    self.add_infiltration(idf, infiltration, inf_zone_list)\n\n    sch_names = self.envelope.schedule_names\n    idf = self.add_schedules_by_name(idf, sch_names)\n\n    return idf\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.add_hot_water_to_zone","title":"<code>add_hot_water_to_zone(idf, space_use, zone_name)</code>","text":"<p>Add the hot water to the zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the hot water to.</p> required <code>space_use</code> <code>ZoneUse</code> <p>The zone use template.</p> required <code>zone_name</code> <code>str</code> <p>The name of the zone to add the hot water to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The IDF model with the added hot water.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def add_hot_water_to_zone(\n    self, idf: IDF, space_use: ZoneUse, zone_name: str\n) -&gt; IDF:\n    \"\"\"Add the hot water to the zone.\n\n    Args:\n        idf (IDF): The IDF model to add the hot water to.\n        space_use (ZoneUse): The zone use template.\n        zone_name (str): The name of the zone to add the hot water to.\n\n    Returns:\n        idf (IDF): The IDF model with the added hot water.\n    \"\"\"\n    zone = next(filter(lambda x: x.Name == zone_name, idf.idfobjects[\"ZONE\"]), None)\n    if zone is None:\n        raise ValueError(f\"NO_ZONE:{zone_name}\")\n    area = 0\n    area_ct = 0\n    for srf in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]:\n        if srf.Zone_Name == zone.Name and srf.Surface_Type.lower() == \"floor\":\n            poly = Polygon(srf.coords)\n            area += poly.area\n            area_ct += 1\n    if area_ct &gt; 1:\n        raise ValueError(f\"TOO_MANY_FLOORS:{zone.Name}\")\n    if area == 0 or area_ct == 0:\n        raise ValueError(f\"NO_AREA:{zone.Name}\")\n    ppl_density = space_use.Loads.PeopleDensity\n    total_ppl = ppl_density * area\n    idf = space_use.HotWater.add_water_to_idf_zone(idf, zone.Name, total_ppl)\n    return idf\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.add_hot_water_to_zone_list","title":"<code>add_hot_water_to_zone_list(idf, space_use, zone_list)</code>","text":"<p>Add the hot water to the zone list.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the hot water to.</p> required <code>space_use</code> <code>ZoneUse</code> <p>The zone use template.</p> required <code>zone_list</code> <code>ZoneList</code> <p>The list of zones to add the hot water to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The IDF model with the added hot water.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def add_hot_water_to_zone_list(\n    self, idf: IDF, space_use: ZoneUse, zone_list: ZoneList\n) -&gt; IDF:\n    \"\"\"Add the hot water to the zone list.\n\n    Args:\n        idf (IDF): The IDF model to add the hot water to.\n        space_use (ZoneUse): The zone use template.\n        zone_list (ZoneList): The list of zones to add the hot water to.\n\n    Returns:\n        idf (IDF): The IDF model with the added hot water.\n    \"\"\"\n    for zone_name in zone_list.Names:\n        idf = self.add_hot_water_to_zone(idf, space_use, zone_name)\n    return idf\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.add_infiltration","title":"<code>add_infiltration(idf, infiltration, zone_list)</code>","text":"<p>Add the infiltration to the IDF model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the infiltration to.</p> required <code>infiltration</code> <code>ZoneInfiltration</code> <p>The infiltration object.</p> required <code>zone_list</code> <code>ZoneList</code> <p>The list of zones to add the infiltration to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The IDF model with the added infiltration.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def add_infiltration(\n    self, idf: IDF, infiltration: ZoneInfiltration, zone_list: ZoneList\n):\n    \"\"\"Add the infiltration to the IDF model.\n\n    Args:\n        idf (IDF): The IDF model to add the infiltration to.\n        infiltration: The infiltration object.\n        zone_list (ZoneList): The list of zones to add the infiltration to.\n\n    Returns:\n        idf (IDF): The IDF model with the added infiltration.\n    \"\"\"\n    idf = infiltration.add_infiltration_to_idf_zone(idf, zone_list.Name)\n    # idf = self.add_schedules_by_name(idf, infiltration.schedule_names)\n    return idf\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.add_schedules_by_name","title":"<code>add_schedules_by_name(idf, schedule_names)</code>","text":"<p>Add schedules to the IDF model by name.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the schedules to.</p> required <code>schedule_names</code> <code>set[str]</code> <p>The names of the schedules to add.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The IDF model with the added schedules.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def add_schedules_by_name(self, idf: IDF, schedule_names: set[str]) -&gt; IDF:\n    \"\"\"Add schedules to the IDF model by name.\n\n    Args:\n        idf (IDF): The IDF model to add the schedules to.\n        schedule_names (set[str]): The names of the schedules to add.\n\n    Returns:\n        IDF: The IDF model with the added schedules.\n    \"\"\"\n    schedules = [self.lib.Schedules[s] for s in schedule_names]\n    for schedule in schedules:\n        yr_sch, *_ = schedule.to_year_week_day()\n        yr_sch.to_epbunch(idf)\n    return idf\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.add_space_use","title":"<code>add_space_use(idf, space_use, zone_list)</code>","text":"<p>Add the space use to the IDF model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the space use to.</p> required <code>space_use</code> <code>ZoneUse</code> <p>The zone use template.</p> required <code>zone_list</code> <code>ZoneList</code> <p>The list of zones to add the space use to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The IDF model with the added space use.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def add_space_use(self, idf: IDF, space_use: ZoneUse, zone_list: ZoneList) -&gt; IDF:\n    \"\"\"Add the space use to the IDF model.\n\n    Args:\n        idf (IDF): The IDF model to add the space use to.\n        space_use (ZoneUse): The zone use template.\n        zone_list (ZoneList): The list of zones to add the space use to.\n\n    Returns:\n        IDF: The IDF model with the added space use.\n    \"\"\"\n    idf = space_use.add_space_use_to_idf_zone(idf, zone_list)\n    idf = self.add_hot_water_to_zone_list(idf, space_use, zone_list)\n    idf = self.add_schedules_by_name(idf, space_use.schedule_names)\n    return idf\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.add_srf_constructions","title":"<code>add_srf_constructions(idf, constructions, window_def)</code>","text":"<p>Assigns the constructions to the surfaces in the model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to select the surfaces from.</p> required <code>constructions</code> <code>ZoneConstruction</code> <p>The construction template.</p> required <code>window_def</code> <code>WindowDefinition</code> <p>The window definition template.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The IDF model with the selected surfaces.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def add_srf_constructions(\n    self,\n    idf: IDF,\n    constructions: ZoneConstruction,\n    window_def: WindowDefinition | None,\n) -&gt; IDF:\n    \"\"\"Assigns the constructions to the surfaces in the model.\n\n    Args:\n        idf (IDF): The IDF model to select the surfaces from.\n        constructions (ZoneConstruction): The construction template.\n        window_def (WindowDefinition): The window definition template.\n\n    Returns:\n        IDF: The IDF model with the selected surfaces.\n    \"\"\"\n    if self.geometry.roof_height:\n        raise ClimateStudioBuilderNotImplementedError(\"roof_height\")\n\n    if (\n        constructions.FacadeIsAdiabatic\n        or constructions.RoofIsAdiabatic\n        or constructions.GroundIsAdiabatic\n        or constructions.PartitionIsAdiabatic\n        or constructions.SlabIsAdiabatic\n    ):\n        raise ClimateStudioBuilderNotImplementedError(\"_IsAdiabatic\")\n\n    if constructions.InternalMassIsOn:\n        raise ClimateStudioBuilderNotImplementedError(\"InternalMassIsOn\")\n\n    handlers = SurfaceHandlers.Default()\n    idf = handlers.handle_envelope(idf, self.lib, constructions, window_def)\n\n    return idf\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.add_zone_lists","title":"<code>add_zone_lists(idf)</code>","text":"<p>Add the zone lists to the IDF model.</p> <p>Note that this attempts to automatically determine the zones from the IDF model which are conditioned as well as a separate list for all zones.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the zone lists to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The IDF model with the added zone lists</p> <code>conditioned_zone_list</code> <code>ZoneList</code> <p>The list of conditioned zones</p> <code>all_zones_list</code> <code>ZoneList</code> <p>The list of all zones</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def add_zone_lists(\n    self,\n    idf: IDF,\n):\n    \"\"\"Add the zone lists to the IDF model.\n\n    Note that this attempts to automatically determine\n    the zones from the IDF model which are conditioned\n    as well as a separate list for all zones.\n\n    Args:\n        idf (IDF): The IDF model to add the zone lists to.\n\n    Returns:\n        idf (IDF): The IDF model with the added zone lists\n        conditioned_zone_list (ZoneList): The list of conditioned zones\n        all_zones_list (ZoneList): The list of all zones\n    \"\"\"\n    all_zone_names = [zone.Name for zone in idf.idfobjects[\"ZONE\"]]\n    all_zones_list = ZoneList(Name=\"All_Zones\", Names=all_zone_names)\n    conditioned_zone_names = [\n        zone.Name\n        for zone in idf.idfobjects[\"ZONE\"]\n        if \"attic\" not in zone.Name.lower()\n        and (\n            not zone.Name.lower().endswith(self.geometry.basement_suffix.lower())\n            if ((not self.conditioned_basement) and self.geometry.basement)\n            else True\n        )\n    ]\n\n    conditioned_storey_count = self.geometry.num_stories + (\n        1 if self.conditioned_basement else 0\n    )\n    zones_per_storey = 1 if self.geometry.zoning == \"by_storey\" else 5\n    expected_zone_count = conditioned_storey_count * zones_per_storey\n    if len(conditioned_zone_names) != expected_zone_count:\n        msg = f\"Expected {expected_zone_count} zones, but found {len(conditioned_zone_names)}.\"\n        raise ValueError(msg)\n\n    conditioned_zone_list = ZoneList(\n        Name=\"Conditioned_Zones\", Names=conditioned_zone_names\n    )\n    idf = conditioned_zone_list.add(idf)\n    idf = all_zones_list.add(idf)\n    return idf, conditioned_zone_list, all_zones_list\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.build","title":"<code>build(config)</code>","text":"<p>Build the energy model using the Climate Studio API.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SimulationConfig</code> <p>The configuration for the simulation.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The built energy model.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def build(self, config: SimulationPathConfig) -&gt; IDF:\n    \"\"\"Build the energy model using the Climate Studio API.\n\n    Args:\n        config (SimulationConfig): The configuration for the simulation.\n\n    Returns:\n        IDF: The built energy model.\n    \"\"\"\n    if (not self.geometry.basement) and self.conditioned_basement:\n        raise ValueError(\"CONDITIONEDBASEMENT:TRUE:BASEMENT:FALSE\")\n\n    if self.geometry.roof_height:\n        raise ClimateStudioBuilderNotImplementedError(\"roof_height\")\n    config.output_dir.mkdir(parents=True, exist_ok=True)\n    base_filepath = EnergyPlusArtifactDir / \"Minimal.idf\"\n    target_base_filepath = config.output_dir / \"Minimal.idf\"\n    shutil.copy(base_filepath, target_base_filepath)\n    epw_path, ddy_path = asyncio.run(self.fetch_weather(config.weather_dir))\n    idf = IDF(\n        target_base_filepath.as_posix(),\n        as_version=None,  # pyright: ignore [reportArgumentType]\n        prep_outputs=True,\n        epw=epw_path.as_posix(),\n        output_directory=config.output_dir.as_posix(),\n    )\n    ddy = IDF(\n        ddy_path.as_posix(),\n        as_version=\"9.2.0\",\n        file_version=\"9.2.0\",\n        prep_outputs=False,\n    )\n    ddy_spec = DDYSizingSpec(\n        match=False, conditions_types=[\"Summer Extreme\", \"Winter Extreme\"]\n    )\n    ddy_spec.inject_ddy(idf, ddy)\n\n    idf = add_default_sim_controls(idf)\n    idf, scheds = add_default_schedules(idf)\n    self.lib.Schedules.update(scheds)\n\n    idf = SiteGroundTemperature.FromValues([\n        18.3,\n        18.2,\n        18.3,\n        18.4,\n        20.1,\n        22.0,\n        22.3,\n        22.5,\n        22.5,\n        20.7,\n        18.9,\n        18.5,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 7.9,\n        # 6.05,\n        # 5.65,\n        # 6.21,\n        # 8.98,\n        # 11.97,\n        # 14.71,\n        # 16.62,\n        # 17.06,\n        # 15.98,\n        # 13.61,\n        # 10.71,\n        # 1.11,\n        # 0.1,\n        # 1.89,\n        # 4.69,\n        # 12.02,\n        # 17.68,\n        # 21.5,\n        # 22.66,\n        # 20.68,\n        # 16.29,\n        # 10.42,\n        # 4.97,\n    ]).add(idf)\n\n    idf = self.geometry.add(idf)\n\n    # construct zone lists\n    idf, conditioned_zone_list, all_zones_list = self.add_zone_lists(idf)\n\n    # TODO: Handle separately ventilated attic/basement?\n    idf = self.add_space_use(idf, self.space_use, conditioned_zone_list)\n    idf = self.add_envelope(idf, self.envelope, all_zones_list)\n\n    return idf\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.compute_dhw","title":"<code>compute_dhw()</code>","text":"<p>Compute the domestic hot water energy demand.</p> <p>Returns:</p> Name Type Description <code>energy</code> <code>float</code> <p>The domestic hot water energy demand (kWh/m2)</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def compute_dhw(self) -&gt; float:\n    \"\"\"Compute the domestic hot water energy demand.\n\n    Returns:\n        energy (float): The domestic hot water energy demand (kWh/m2)\n    \"\"\"\n    # TODO: this should be computed from the DHW schedule\n    if not self.space_use.HotWater.IsOn:\n        return 0\n    flow_rate_per_person = self.space_use.HotWater.FlowRatePerPerson  # m3/hr/person\n    temperature_rise = (\n        self.space_use.HotWater.WaterSupplyTemperature\n        - self.space_use.HotWater.WaterTemperatureInlet\n    )  # K\n    water_density = 1000  # kg/m3\n    c = 4186  # J/kg.K\n    total_flow_rate = flow_rate_per_person * self.total_people  # m3/hr\n    total_volume = total_flow_rate * 8760  # m3 / yr\n    total_energy = total_volume * temperature_rise * water_density * c  # J / yr\n    total_energy_kWh = total_energy / 3600000  # kWh / yr\n    total_energy_kWh_per_m2 = (\n        total_energy_kWh / self.total_conditioned_area\n    )  # kWh/m2 / yr\n    return total_energy_kWh_per_m2\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.get_warnings","title":"<code>get_warnings(idf)</code>","text":"<p>Get the warning text from the idf model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to get the warning text from.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The warning text.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def get_warnings(self, idf: IDF) -&gt; str:\n    \"\"\"Get the warning text from the idf model.\n\n    Args:\n        idf (IDF): The IDF model to get the warning text from.\n\n    Returns:\n        str: The warning text.\n    \"\"\"\n    err_files = filter(\n        lambda x: x.suffix == \".err\",\n        [idf.output_directory / Path(f) for f in idf.simulation_files],\n    )\n    err_text = \"\\n\".join([f.read_text() for f in err_files])\n    return err_text\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.run","title":"<code>run(weather_dir=None, post_build_callback=None, move_energy=False)</code>","text":"<p>Build and simualte the idf model.</p> <p>Parameters:</p> Name Type Description Default <code>weather_dir</code> <code>Path</code> <p>The directory to store the weather files.</p> <code>None</code> <code>post_build_callback</code> <code>Callable[[IDF], IDF] | None</code> <p>A callback to run after the model is built.</p> <code>None</code> <code>move_energy</code> <code>bool</code> <p>Whether to move the energy to fuels based off of the CoP/Fuel Types.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The built energy model.</p> <code>results</code> <code>Series</code> <p>The postprocessed results.</p> <code>err_text</code> <code>str</code> <p>The warning text.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def run(\n    self,\n    weather_dir: Path | None = None,\n    post_build_callback: Callable[[IDF], IDF] | None = None,\n    move_energy: bool = False,\n) -&gt; tuple[IDF, pd.Series, str]:\n    \"\"\"Build and simualte the idf model.\n\n    Args:\n        weather_dir (Path): The directory to store the weather files.\n        post_build_callback (Callable[[IDF],IDF] | None): A callback to run after the model is built.\n        move_energy (bool): Whether to move the energy to fuels based off of the CoP/Fuel Types.\n\n    Returns:\n        idf (IDF): The built energy model.\n        results (pd.Series): The postprocessed results.\n        err_text (str): The warning text.\n    \"\"\"\n    with tempfile.TemporaryDirectory() as temp_dir:\n        output_dir = Path(temp_dir)\n        config = (\n            SimulationPathConfig(\n                output_dir=output_dir,\n                weather_dir=weather_dir,\n            )\n            if weather_dir is not None\n            else SimulationPathConfig(output_dir=output_dir)\n        )\n\n        idf, sql = self.simulate(\n            config,\n            post_build_callback=post_build_callback,\n        )\n        results = self.standard_results_postprocess(sql, move_energy=move_energy)\n        err_text = self.get_warnings(idf)\n        return idf, results, err_text\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.simulate","title":"<code>simulate(config, post_build_callback=None)</code>","text":"<p>Build and simualte the idf model.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SimulationConfig</code> <p>The configuration for the simulation.</p> required <code>post_build_callback</code> <code>Callable[[IDF], IDF] | None</code> <p>A callback to run after the model is built.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[IDF, Sql]</code> <p>tuple[IDF, Sql]: The built energy model and the sql file.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def simulate(\n    self,\n    config: SimulationPathConfig,\n    post_build_callback: Callable[[IDF], IDF] | None = None,\n) -&gt; tuple[IDF, Sql]:\n    \"\"\"Build and simualte the idf model.\n\n    Args:\n        config (SimulationConfig): The configuration for the simulation.\n        post_build_callback (Callable[[IDF],IDF] | None): A callback to run after the model is built.\n\n    Returns:\n        tuple[IDF, Sql]: The built energy model and the sql file.\n    \"\"\"\n    idf = self.build(config)\n    if post_build_callback is not None:\n        idf = post_build_callback(idf)\n    idf.simulate()\n    sql = Sql(idf.sql_file)\n    return idf, sql\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.standard_results_postprocess","title":"<code>standard_results_postprocess(sql, move_energy)</code>","text":"<p>Postprocess the sql file to get the standard results.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>Sql</code> <p>The sql file to postprocess.</p> required <code>move_energy</code> <code>bool</code> <p>Whether to move the energy to fuels based off of the CoP/Fuel Types.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.DataFrame: The postprocessed results.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>def standard_results_postprocess(self, sql: Sql, move_energy: bool) -&gt; pd.Series:\n    \"\"\"Postprocess the sql file to get the standard results.\n\n    Args:\n        sql (Sql): The sql file to postprocess.\n        move_energy (bool): Whether to move the energy to fuels based off of the CoP/Fuel Types.\n\n    Returns:\n        pd.DataFrame: The postprocessed results.\n    \"\"\"\n    res_df = sql.tabular_data_by_name(\n        \"AnnualBuildingUtilityPerformanceSummary\", \"End Uses\"\n    )\n    kWh_per_GJ = 277.778\n    res_df = (\n        res_df[\n            [\n                \"Electricity\",\n                \"District Cooling\",\n                \"District Heating\",\n            ]\n        ].droplevel(-1, axis=1)\n        * kWh_per_GJ\n    ) / self.total_conditioned_area\n    res_series_hot_water = res_df.loc[\"Water Systems\"]\n    res_series = res_df.loc[\"Total End Uses\"] - res_series_hot_water\n    res_series[\"Domestic Hot Water\"] = res_series_hot_water.sum()\n\n    res_series.name = \"kWh/m2\"\n\n    if move_energy:\n        heat_cop = self.space_use.Conditioning.HeatingCOP\n        cool_cop = self.space_use.Conditioning.CoolingCOP\n        dhw_cop = self.space_use.HotWater.DomHotWaterCOP\n        heat_fuel = self.space_use.Conditioning.HeatingFuelType\n        cool_fuel = self.space_use.Conditioning.CoolingFuelType\n        dhw_fuel = self.space_use.HotWater.HotWaterFuelType\n        heat_energy = res_series[\"District Heating\"] / heat_cop\n        cool_energy = res_series[\"District Cooling\"] / cool_cop\n        dhw_energy = res_series[\"Domestic Hot Water\"] / dhw_cop\n        if heat_fuel not in res_series.index:\n            res_series[heat_fuel] = 0\n        if cool_fuel not in res_series.index:\n            res_series[cool_fuel] = 0\n        if dhw_fuel not in res_series.index:\n            res_series[dhw_fuel] = 0\n        res_series[heat_fuel] += heat_energy\n        res_series[cool_fuel] += cool_energy\n        res_series[dhw_fuel] += dhw_energy\n        res_series = res_series.drop([\n            \"District Cooling\",\n            \"District Heating\",\n            \"Domestic Hot Water\",\n        ])\n\n    return cast(pd.Series, res_series)\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.SimulationPathConfig","title":"<code>SimulationPathConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The configuration for the simulation's pathing.</p> Source code in <code>epinterface\\climate_studio\\builder.py</code> <pre><code>class SimulationPathConfig(BaseModel):\n    \"\"\"The configuration for the simulation's pathing.\"\"\"\n\n    output_dir: Path = Field(\n        default_factory=lambda: EnergyPlusArtifactDir / \"cache\" / str(uuid4())[:8],\n        description=\"The output directory for the IDF model.\",\n    )\n    weather_dir: Path = Field(\n        default_factory=lambda: EnergyPlusArtifactDir / \"cache\" / \"weather\",\n        description=\"The directory to store the weather files.\",\n    )\n</code></pre>"},{"location":"modules/climate-studio/","title":"ClimateStudio Interface","text":"<p>A module for parsing climate studio data and generating EnergyPlus objects.</p>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioException","title":"<code>ClimateStudioException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>A base exception for the climate studio library.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ClimateStudioException(Exception):\n    \"\"\"A base exception for the climate studio library.\"\"\"\n\n    def __init__(self, message: str):\n        \"\"\"Initialize the exception with a message.\"\"\"\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioException.__init__","title":"<code>__init__(message)</code>","text":"<p>Initialize the exception with a message.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def __init__(self, message: str):\n    \"\"\"Initialize the exception with a message.\"\"\"\n    self.message = message\n    super().__init__(self.message)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioLibraryDuplicatesFound","title":"<code>ClimateStudioLibraryDuplicatesFound</code>","text":"<p>               Bases: <code>ClimateStudioException</code></p> <p>An error raised when duplicates are found in a climate studio library.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ClimateStudioLibraryDuplicatesFound(ClimateStudioException):\n    \"\"\"An error raised when duplicates are found in a climate studio library.\"\"\"\n\n    def __init__(self, duplicate_field: str):\n        \"\"\"Initialize the exception with a message.\n\n        Args:\n            duplicate_field (str): The field with duplicates\n        \"\"\"\n        self.duplicate_field = duplicate_field\n        self.message = f\"Duplicate objects found in library: {duplicate_field}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioLibraryDuplicatesFound.__init__","title":"<code>__init__(duplicate_field)</code>","text":"<p>Initialize the exception with a message.</p> <p>Parameters:</p> Name Type Description Default <code>duplicate_field</code> <code>str</code> <p>The field with duplicates</p> required Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def __init__(self, duplicate_field: str):\n    \"\"\"Initialize the exception with a message.\n\n    Args:\n        duplicate_field (str): The field with duplicates\n    \"\"\"\n    self.duplicate_field = duplicate_field\n    self.message = f\"Duplicate objects found in library: {duplicate_field}\"\n    super().__init__(self.message)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioLibraryV1","title":"<code>ClimateStudioLibraryV1</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Climate Studio library object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ClimateStudioLibraryV1(BaseModel, arbitrary_types_allowed=True):\n    \"\"\"Climate Studio library object.\"\"\"\n\n    # DaySchedules: dict[str, DaySchedule]\n    # DomHotWater: dict[str, DomHotWater]\n    # WindowSettings: dict[str, WindowSettings]\n    # NaturalVentilation: dict[str, NaturalVentilation] ?\n    GasMaterials: dict[str, GasMaterial]\n    GlazingConstructionSimple: dict[str, GlazingConstructionSimple]\n    GlazingMaterials: dict[str, GlazingMaterial]\n    OpaqueMaterials: dict[str, OpaqueMaterial]\n    OpaqueConstructions: dict[str, OpaqueConstruction]\n    ZoneConditioning: dict[str, ZoneConditioning]\n    ZoneConstruction: dict[str, ZoneConstruction]\n    ZoneDefinition: dict[str, ZoneDefinition]\n    ZoneInfiltration: dict[str, ZoneInfiltration]\n    ZoneLoad: dict[str, ZoneLoad]\n    Schedules: dict[str, Schedule]\n\n    @classmethod\n    @validate_call\n    def Load(cls, base_path: Path):\n        \"\"\"Load a Climate Studio library from a directory.\n\n        The directory should have all the necessary named files.\n\n        Args:\n            base_path (Path): The base path to the library directory.\n\n        Returns:\n            lib (ClimateStudioLibrary): The Climate Studio library object.\n        \"\"\"\n        if isinstance(base_path, str):\n            base_path = Path(base_path)\n\n        gas_materials = cls.LoadObjects(base_path, GasMaterial, pluralize=True)\n        glass_consts_simple = cls.LoadObjects(base_path, GlazingConstructionSimple)\n        glazing_materials = cls.LoadObjects(base_path, GlazingMaterial, pluralize=True)\n        opaque_materials = cls.LoadObjects(base_path, OpaqueMaterial, pluralize=True)\n        opaque_consts = cls.LoadObjects(base_path, OpaqueConstruction, pluralize=True)\n        zone_constructions = cls.LoadObjects(base_path, ZoneConstruction)\n        zone_definitions = cls.LoadObjects(base_path, ZoneDefinition)\n        zone_conditioning = cls.LoadObjects(base_path, ZoneConditioning)\n        zone_infiltrations = cls.LoadObjects(base_path, ZoneInfiltration)\n        zone_loads = cls.LoadObjects(base_path, ZoneLoad)\n\n        year_schs = pd.read_csv(base_path / \"YearSchedules.csv\", dtype=str)\n        sch_names = year_schs.columns\n        schedules_list = [extract_sch(year_schs, sch_name) for sch_name in sch_names]\n        schedules = {sch.Name: sch for sch in schedules_list}\n        if len(schedules) != len(schedules_list):\n            raise ClimateStudioLibraryDuplicatesFound(\"Schedules\")\n\n        return cls(\n            GasMaterials=gas_materials,\n            GlazingConstructionSimple=glass_consts_simple,\n            GlazingMaterials=glazing_materials,\n            OpaqueMaterials=opaque_materials,\n            OpaqueConstructions=opaque_consts,\n            ZoneConditioning=zone_conditioning,\n            ZoneConstruction=zone_constructions,\n            ZoneDefinition=zone_definitions,\n            ZoneInfiltration=zone_infiltrations,\n            ZoneLoad=zone_loads,\n            Schedules=schedules,\n        )\n\n    @classmethod\n    def LoadObjects(\n        cls, base_path: Path, obj_class: type[NamedType], pluralize: bool = False\n    ) -&gt; dict[str, NamedType]:\n        \"\"\"Handles deserializing a ClimateStudio CSV to the appropriate class.\n\n        Args:\n            base_path (Path): The base path to the library directory.\n            obj_class (Type[NamedObject]): The class to deserialize to.\n            pluralize (bool, optional): Whether to pluralize the filename. Defaults to False.\n\n        Returns:\n            dict[str, NamedObject]: The deserialized objects.\n        \"\"\"\n        df = pd.read_csv(\n            base_path / f\"{obj_class.__name__}{'s' if pluralize else ''}.csv\"\n        )\n        data = df.to_dict(orient=\"records\")\n        obj_list = [obj_class.model_validate(d) for d in data]\n        obj_dict = {obj.Name: obj for obj in obj_list}\n        if len(obj_dict) != len(obj_list):\n            raise ClimateStudioLibraryDuplicatesFound(obj_class.__name__)\n        return obj_dict\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioLibraryV1.Load","title":"<code>Load(base_path)</code>  <code>classmethod</code>","text":"<p>Load a Climate Studio library from a directory.</p> <p>The directory should have all the necessary named files.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>Path</code> <p>The base path to the library directory.</p> required <p>Returns:</p> Name Type Description <code>lib</code> <code>ClimateStudioLibrary</code> <p>The Climate Studio library object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>@classmethod\n@validate_call\ndef Load(cls, base_path: Path):\n    \"\"\"Load a Climate Studio library from a directory.\n\n    The directory should have all the necessary named files.\n\n    Args:\n        base_path (Path): The base path to the library directory.\n\n    Returns:\n        lib (ClimateStudioLibrary): The Climate Studio library object.\n    \"\"\"\n    if isinstance(base_path, str):\n        base_path = Path(base_path)\n\n    gas_materials = cls.LoadObjects(base_path, GasMaterial, pluralize=True)\n    glass_consts_simple = cls.LoadObjects(base_path, GlazingConstructionSimple)\n    glazing_materials = cls.LoadObjects(base_path, GlazingMaterial, pluralize=True)\n    opaque_materials = cls.LoadObjects(base_path, OpaqueMaterial, pluralize=True)\n    opaque_consts = cls.LoadObjects(base_path, OpaqueConstruction, pluralize=True)\n    zone_constructions = cls.LoadObjects(base_path, ZoneConstruction)\n    zone_definitions = cls.LoadObjects(base_path, ZoneDefinition)\n    zone_conditioning = cls.LoadObjects(base_path, ZoneConditioning)\n    zone_infiltrations = cls.LoadObjects(base_path, ZoneInfiltration)\n    zone_loads = cls.LoadObjects(base_path, ZoneLoad)\n\n    year_schs = pd.read_csv(base_path / \"YearSchedules.csv\", dtype=str)\n    sch_names = year_schs.columns\n    schedules_list = [extract_sch(year_schs, sch_name) for sch_name in sch_names]\n    schedules = {sch.Name: sch for sch in schedules_list}\n    if len(schedules) != len(schedules_list):\n        raise ClimateStudioLibraryDuplicatesFound(\"Schedules\")\n\n    return cls(\n        GasMaterials=gas_materials,\n        GlazingConstructionSimple=glass_consts_simple,\n        GlazingMaterials=glazing_materials,\n        OpaqueMaterials=opaque_materials,\n        OpaqueConstructions=opaque_consts,\n        ZoneConditioning=zone_conditioning,\n        ZoneConstruction=zone_constructions,\n        ZoneDefinition=zone_definitions,\n        ZoneInfiltration=zone_infiltrations,\n        ZoneLoad=zone_loads,\n        Schedules=schedules,\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioLibraryV1.LoadObjects","title":"<code>LoadObjects(base_path, obj_class, pluralize=False)</code>  <code>classmethod</code>","text":"<p>Handles deserializing a ClimateStudio CSV to the appropriate class.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>Path</code> <p>The base path to the library directory.</p> required <code>obj_class</code> <code>Type[NamedObject]</code> <p>The class to deserialize to.</p> required <code>pluralize</code> <code>bool</code> <p>Whether to pluralize the filename. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, NamedType]</code> <p>dict[str, NamedObject]: The deserialized objects.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>@classmethod\ndef LoadObjects(\n    cls, base_path: Path, obj_class: type[NamedType], pluralize: bool = False\n) -&gt; dict[str, NamedType]:\n    \"\"\"Handles deserializing a ClimateStudio CSV to the appropriate class.\n\n    Args:\n        base_path (Path): The base path to the library directory.\n        obj_class (Type[NamedObject]): The class to deserialize to.\n        pluralize (bool, optional): Whether to pluralize the filename. Defaults to False.\n\n    Returns:\n        dict[str, NamedObject]: The deserialized objects.\n    \"\"\"\n    df = pd.read_csv(\n        base_path / f\"{obj_class.__name__}{'s' if pluralize else ''}.csv\"\n    )\n    data = df.to_dict(orient=\"records\")\n    obj_list = [obj_class.model_validate(d) for d in data]\n    obj_dict = {obj.Name: obj for obj in obj_list}\n    if len(obj_dict) != len(obj_list):\n        raise ClimateStudioLibraryDuplicatesFound(obj_class.__name__)\n    return obj_dict\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioLibraryV2","title":"<code>ClimateStudioLibraryV2</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Climate Studio library object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ClimateStudioLibraryV2(BaseModel, arbitrary_types_allowed=True):\n    \"\"\"Climate Studio library object.\"\"\"\n\n    SpaceUses: dict[str, ZoneUse]\n    Envelopes: dict[str, ZoneEnvelope]\n    GlazingConstructions: dict[str, GlazingConstructionSimple]\n    OpaqueConstructions: dict[str, OpaqueConstruction]\n    OpaqueMaterials: dict[str, OpaqueMaterial]\n    Schedules: dict[str, Schedule]\n\n    @field_validator(\"Schedules\", mode=\"before\")\n    @classmethod\n    def validate_schedules(cls, value: dict[str, Any]):\n        \"\"\"Validate the schedules.\"\"\"\n        for key, val in value.items():\n            if isinstance(val, dict):\n                transfer = ScheduleTransferObject.model_validate(val)\n                limit_type = ScheduleTypeLimits.from_dict(transfer.Type)\n                value[key] = Schedule.from_values(\n                    Name=transfer.Name,\n                    Type=limit_type,  # pyright: ignore [reportArgumentType]\n                    Values=transfer.Values,\n                )\n            elif isinstance(val, ScheduleTransferObject):\n                limit_type = ScheduleTypeLimits.from_dict(val.Type)\n                value[key] = Schedule.from_values(\n                    Name=val.Name,\n                    Type=limit_type,  # pyright: ignore [reportArgumentType]\n                    Values=val.Values,\n                )\n            elif not isinstance(val, Schedule):\n                raise TypeError(f\"SCHEDULE_LOAD_ERROR:{type(val)}\")\n            else:\n                continue\n        return value\n\n    @field_serializer(\"Schedules\")\n    def serialize_schedules(\n        self, schedules: dict[str, Schedule]\n    ) -&gt; dict[str, \"ScheduleTransferObject\"]:\n        \"\"\"Serialize the schedules to a dataframe.\n\n        Args:\n            schedules (dict[str, Schedule]): The schedules to serialize.\n\n        Returns:\n            serialized_schedules (dict[str, list[float]])\n        \"\"\"\n        out_result: dict[str, ScheduleTransferObject] = {}\n        for name, sch in schedules.items():\n            out_result[name] = ScheduleTransferObject(\n                Name=sch.Name,\n                Type=sch.Type.to_dict(),\n                Values=list(cast(np.ndarray, sch.Values)),\n            )\n\n        return out_result\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioLibraryV2.serialize_schedules","title":"<code>serialize_schedules(schedules)</code>","text":"<p>Serialize the schedules to a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>schedules</code> <code>dict[str, Schedule]</code> <p>The schedules to serialize.</p> required <p>Returns:</p> Type Description <code>dict[str, ScheduleTransferObject]</code> <p>serialized_schedules (dict[str, list[float]])</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>@field_serializer(\"Schedules\")\ndef serialize_schedules(\n    self, schedules: dict[str, Schedule]\n) -&gt; dict[str, \"ScheduleTransferObject\"]:\n    \"\"\"Serialize the schedules to a dataframe.\n\n    Args:\n        schedules (dict[str, Schedule]): The schedules to serialize.\n\n    Returns:\n        serialized_schedules (dict[str, list[float]])\n    \"\"\"\n    out_result: dict[str, ScheduleTransferObject] = {}\n    for name, sch in schedules.items():\n        out_result[name] = ScheduleTransferObject(\n            Name=sch.Name,\n            Type=sch.Type.to_dict(),\n            Values=list(cast(np.ndarray, sch.Values)),\n        )\n\n    return out_result\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioLibraryV2.validate_schedules","title":"<code>validate_schedules(value)</code>  <code>classmethod</code>","text":"<p>Validate the schedules.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>@field_validator(\"Schedules\", mode=\"before\")\n@classmethod\ndef validate_schedules(cls, value: dict[str, Any]):\n    \"\"\"Validate the schedules.\"\"\"\n    for key, val in value.items():\n        if isinstance(val, dict):\n            transfer = ScheduleTransferObject.model_validate(val)\n            limit_type = ScheduleTypeLimits.from_dict(transfer.Type)\n            value[key] = Schedule.from_values(\n                Name=transfer.Name,\n                Type=limit_type,  # pyright: ignore [reportArgumentType]\n                Values=transfer.Values,\n            )\n        elif isinstance(val, ScheduleTransferObject):\n            limit_type = ScheduleTypeLimits.from_dict(val.Type)\n            value[key] = Schedule.from_values(\n                Name=val.Name,\n                Type=limit_type,  # pyright: ignore [reportArgumentType]\n                Values=val.Values,\n            )\n        elif not isinstance(val, Schedule):\n            raise TypeError(f\"SCHEDULE_LOAD_ERROR:{type(val)}\")\n        else:\n            continue\n    return value\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioMetadata","title":"<code>ClimateStudioMetadata</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Metadata for a climate studio table object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ClimateStudioMetadata(BaseModel):\n    \"\"\"Metadata for a climate studio table object.\"\"\"\n\n    Category: str = Field(..., title=\"Category of the object\")\n    Comment: NanStr = Field(..., title=\"Comment on the object\")\n    DataSource: NanStr = Field(..., title=\"Data source of the object\")\n    ClimateZone: str = Field(..., title=\"Climate zone of the object\")\n    Standard: str = Field(..., title=\"Standard of the object\")\n    Program: str = Field(..., title=\"Program of the object\")\n    Version: NanStr | None = Field(default=None, title=\"Version of the object\")\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioValueNotFound","title":"<code>ClimateStudioValueNotFound</code>","text":"<p>               Bases: <code>ClimateStudioException</code></p> <p>An error raised when a value is not found in a climate studio library.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ClimateStudioValueNotFound(ClimateStudioException):\n    \"\"\"An error raised when a value is not found in a climate studio library.\"\"\"\n\n    def __init__(self, obj_type: str, value: str):\n        \"\"\"Initialize the exception with a message.\n\n        Args:\n            obj_type (str): The type of object that was not found.\n            value (str): The value that was not found.\n        \"\"\"\n        self.obj_type = obj_type\n        self.value = value\n        self.message = f\"Value not found in library: {obj_type}:{value}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioValueNotFound.__init__","title":"<code>__init__(obj_type, value)</code>","text":"<p>Initialize the exception with a message.</p> <p>Parameters:</p> Name Type Description Default <code>obj_type</code> <code>str</code> <p>The type of object that was not found.</p> required <code>value</code> <code>str</code> <p>The value that was not found.</p> required Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def __init__(self, obj_type: str, value: str):\n    \"\"\"Initialize the exception with a message.\n\n    Args:\n        obj_type (str): The type of object that was not found.\n        value (str): The value that was not found.\n    \"\"\"\n    self.obj_type = obj_type\n    self.value = value\n    self.message = f\"Value not found in library: {obj_type}:{value}\"\n    super().__init__(self.message)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.CommonMaterialProperties","title":"<code>CommonMaterialProperties</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Common material properties for glazing and opaque materials.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class CommonMaterialProperties(BaseModel):\n    \"\"\"Common material properties for glazing and opaque materials.\"\"\"\n\n    Conductivity: float = Field(\n        ...,\n        title=\"Conductivity [W/mK]\",\n        validation_alias=\"Conductivity [W/m.K]\",\n        ge=0,\n    )\n    Density: float = Field(\n        ...,\n        title=\"Density [kg/m3]\",\n        ge=0,\n        validation_alias=AliasChoices(\n            \"Density [kg/m\u00b3]\",\n            \"Density [kg/m3]\",\n        ),\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.EmbodiedCarbonData","title":"<code>EmbodiedCarbonData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Embodied carbon data for a material or construction.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class EmbodiedCarbonData(BaseModel):\n    \"\"\"Embodied carbon data for a material or construction.\"\"\"\n\n    EmbodiedEnergy: float = Field(\n        ...,\n        title=\"Embodied energy [MJ/unit]\",\n        validation_alias=AliasChoices(\n            \"EmbodiedEnergy [MJ/Kg]\",\n            \"EmbodiedEnergy\",\n            \"EmbodiedEnergy [MJ/m\u00b2]\",\n            \"EmbodiedEnergy [MJ/m\u00c2\u00b2]\",\n            \"EmbodiedEnergy [MJ/m\u00c3\u201a\u00c2\u00b2]\",  # noqa: RUF001\n        ),\n    )\n    EmbodiedEnergyStdDev: float = Field(\n        0,\n        title=\"Standard deviation of embodied energy [MJ/unit]\",\n        validation_alias=\"EmbodiedEnergyStdDev\",\n        ge=0,\n    )\n    EmbodiedCarbon: float = Field(\n        ...,\n        title=\"Embodied carbon [kgCO2eq/unit]\",\n        validation_alias=AliasChoices(\n            \"EmbodiedCarbon [kgCO2eq/Kg]\",\n            \"EmbodiedCarbon\",\n            \"EmbodiedCarbon [kgCO2eq/m\u00b2]\",\n            \"EmbodiedCarbon [kgCO2eq/m\u00c2\u00b2]\",\n            \"EmbodiedCarbon [kgCO2eq/m\u00c3\u201a\u00c2\u00b2]\",  # noqa: RUF001\n        ),\n    )\n    EmbodiedCarbonStdDev: float = Field(\n        0,\n        title=\"Standard deviation of embodied carbon [kgCO2eq/unit]\",\n        validation_alias=\"EmbodiedCarbonStdDev\",\n        ge=0,\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.Foundation","title":"<code>Foundation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Foundation object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class Foundation(BaseModel, extra=\"ignore\"):\n    \"\"\"Foundation object.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.GasMaterial","title":"<code>GasMaterial</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MaterialWithThickness</code>, <code>StandardMaterializedMetadata</code></p> <p>Gas Material object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class GasMaterial(\n    NamedObject, MaterialWithThickness, StandardMaterializedMetadata, extra=\"forbid\"\n):\n    \"\"\"Gas Material object.\"\"\"\n\n    Model: Literal[\"Gas\"] = Field(default=\"Gas\", title=\"Model of the gas material\")\n    GasType1: str = Field(..., title=\"Type of the gas material\")\n    GasType2: str = Field(..., title=\"Type of the gas material\")\n    GasType3: str = Field(..., title=\"Type of the gas material\")\n    GasesInMix: int = Field(..., title=\"Number of gases in the mix\", ge=1)\n    Ratio1: float = Field(..., title=\"Ratio of the gas material\", ge=0, le=1)\n    Ratio2: float = Field(..., title=\"Ratio of the gas material\", ge=0, le=1)\n    Ratio3: float = Field(..., title=\"Ratio of the gas material\", ge=0, le=1)\n    ConductivityCoefficientA: float = Field(\n        ..., title=\"Conductivity coefficient A\", ge=0\n    )\n    ConductivityCoefficientB: float = Field(\n        ..., title=\"Conductivity coefficient B\", ge=0\n    )\n    ConductivityCoefficientC: float = Field(\n        ..., title=\"Conductivity coefficient C\", ge=0\n    )\n    MolecularWeight: float = Field(..., title=\"Molecular weight\", ge=0)\n    SpecificHeatCoefficientA: float = Field(\n        ..., title=\"Specific heat coefficient A\", ge=0\n    )\n    SpecificHeatCoefficientB: float = Field(\n        ..., title=\"Specific heat coefficient B\", ge=0\n    )\n    SpecificHeatCoefficientC: float = Field(\n        ..., title=\"Specific heat coefficient C\", ge=0\n    )\n    SpecificHeatRatio: float = Field(..., title=\"Specific heat ratio\", ge=0)\n    ViscosityCoefficientA: float = Field(..., title=\"Viscosity coefficient A\", ge=0)\n    ViscosityCoefficientB: float = Field(..., title=\"Viscosity coefficient B\", ge=0)\n    ViscosityCoefficientC: float = Field(..., title=\"Viscosity coefficient C\", ge=0)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.GlazingConstructionSimple","title":"<code>GlazingConstructionSimple</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>StandardMaterializedMetadata</code>, <code>ManufacturerData</code></p> <p>Simple glazing construction object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class GlazingConstructionSimple(\n    NamedObject,\n    StandardMaterializedMetadata,\n    ManufacturerData,\n    extra=\"forbid\",\n    populate_by_name=True,\n):\n    \"\"\"Simple glazing construction object.\"\"\"\n\n    SHGF: float = Field(..., title=\"Solar heat gain factor\", ge=0, le=1)\n    UValue: float = Field(\n        ...,\n        title=\"U-value [W/m\u00b2K]\",\n        validation_alias=\"UValue [W/m2-k]\",\n        ge=0,\n    )\n    TVis: float = Field(..., title=\"Visible transmittance\", ge=0, le=1)\n    Type: WindowType = Field(..., title=\"Type of the glazing construction\")\n\n    def add_to_idf(self, idf: IDF) -&gt; IDF:\n        \"\"\"Adds the glazing construction to an IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the construction to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        glazing_mat = SimpleGlazingMaterial(\n            Name=self.Name,\n            UFactor=self.UValue,\n            Solar_Heat_Gain_Coefficient=self.SHGF,\n            Visible_Transmittance=self.TVis,\n        )\n\n        construction = Construction(\n            name=self.Name,\n            layers=[glazing_mat],\n        )\n\n        idf = construction.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.GlazingConstructionSimple.add_to_idf","title":"<code>add_to_idf(idf)</code>","text":"<p>Adds the glazing construction to an IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the construction to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_to_idf(self, idf: IDF) -&gt; IDF:\n    \"\"\"Adds the glazing construction to an IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the construction to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    glazing_mat = SimpleGlazingMaterial(\n        Name=self.Name,\n        UFactor=self.UValue,\n        Solar_Heat_Gain_Coefficient=self.SHGF,\n        Visible_Transmittance=self.TVis,\n    )\n\n    construction = Construction(\n        name=self.Name,\n        layers=[glazing_mat],\n    )\n\n    idf = construction.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.GlazingMaterial","title":"<code>GlazingMaterial</code>","text":"<p>               Bases: <code>GlazingMaterialProperties</code>, <code>MaterialWithThickness</code>, <code>StandardMaterializedMetadata</code>, <code>NamedObject</code></p> <p>Glazing material object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class GlazingMaterial(\n    GlazingMaterialProperties,\n    MaterialWithThickness,\n    StandardMaterializedMetadata,\n    NamedObject,\n    extra=\"forbid\",\n):\n    \"\"\"Glazing material object.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.GlazingMaterialProperties","title":"<code>GlazingMaterialProperties</code>","text":"<p>               Bases: <code>CommonMaterialProperties</code></p> <p>Properties of a glazing material.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class GlazingMaterialProperties(CommonMaterialProperties):\n    \"\"\"Properties of a glazing material.\"\"\"\n\n    Optical: str = Field(..., title=\"Optical properties of the glazing material\")\n    OpticalDataName: NanStr = Field(\n        ..., title=\"Optical data name of the glazing material\"\n    )\n    NFRC_ID: int = Field(..., title=\"NFRC ID of the glazing material\")\n    Glazing_ID: int = Field(..., title=\"Glazing ID of the glazing material\")\n    CoatingSide: NanStr = Field(..., title=\"Coating side of the glazing material\")\n    SpectralDataPointWavelength: FloatListStr = Field(\n        ...,\n        title=\"Spectral data point wavelength\",\n        validation_alias=\"SpectralDataPointWavelength [Microns]\",\n    )\n    SpectralDataPointTransmittance: FloatListStr = Field(\n        ...,\n        title=\"Spectral data point transmittance\",\n        validation_alias=\"SpectralDataPointTransmittance [0-1]\",\n    )\n    SpectralDataPointFrontReflectance: FloatListStr = Field(\n        ...,\n        title=\"Spectral data point front reflectance\",\n        validation_alias=\"SpectralDataPointFrontReflectance [0-1]\",\n    )\n    SpectralDataPointBackReflectance: FloatListStr = Field(\n        ...,\n        title=\"Spectral data point back reflectance\",\n        validation_alias=\"SpectralDataPointBackReflectance [0-1]\",\n    )\n    SolarTransmittance: float = Field(\n        ...,\n        title=\"Solar transmittance of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"SolarTransmittance [0-1]\",\n    )\n    SolarReflectanceFront: float = Field(\n        ...,\n        title=\"Solar reflectance front of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"SolarReflectanceFront [0-1]\",\n    )\n    SolarReflectanceBack: float = Field(\n        ...,\n        title=\"Solar reflectance back of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"SolarReflectanceBack [0-1]\",\n    )\n    VisibleTransmittance: float = Field(\n        ...,\n        title=\"Visible transmittance of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"VisibleTransmittance [0-1]\",\n    )\n    VisibleReflectanceFront: float = Field(\n        ...,\n        title=\"Visible reflectance front of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"VisibleReflectanceFront [0-1]\",\n    )\n    VisibleReflectanceBack: float = Field(\n        ...,\n        title=\"Visible reflectance back of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"VisibleReflectanceBack [0-1]\",\n    )\n    IRTransmittance: float = Field(\n        ...,\n        title=\"IR transmittance of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"IRTransmittance [0-1]\",\n    )\n    IREmissivityFront: float = Field(\n        ...,\n        title=\"IR emissivity front of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"IREmissivityFront [0-1]\",\n    )\n    IREmissivityBack: float = Field(\n        ...,\n        title=\"IR emissivity back of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"IREmissivityBack [0-1]\",\n    )\n    DirtFactor: float = Field(\n        ...,\n        title=\"Dirt factor of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"DirtFactor [0-1]\",\n    )\n    Type: str = Field(..., title=\"Type of the glazing material\")\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.LifecycleData","title":"<code>LifecycleData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Lifecycle data for a material or construction.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class LifecycleData(BaseModel):\n    \"\"\"Lifecycle data for a material or construction.\"\"\"\n\n    Cost: float = Field(\n        ...,\n        title=\"Cost [$/unit]\",\n        # a superscript 3 looks like this:\n        validation_alias=AliasChoices(\n            \"Cost [$/m\u00b3]\",\n            \"Cost [$/m3]\",\n            \"Cost [$/m\u00b2]\",\n            \"Cost [$/m2]\",\n            \"Cost [$/m]\",\n            \"Cost [$/kg]\",\n            \"Cost [$/m\u00c2\u00b2]\",\n            \"Cost [$/m\u00c3\u201a\u00c2\u00b2]\",  # noqa: RUF001\n        ),\n        ge=0,\n    )\n    Life: float = Field(\n        ...,\n        title=\"Life [years]\",\n        validation_alias=\"Life [yr]\",\n        ge=0,\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ManufacturerData","title":"<code>ManufacturerData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Manufacturer data for a construction.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ManufacturerData(BaseModel):\n    \"\"\"Manufacturer data for a construction.\"\"\"\n\n    Manufacturer: NanStr = Field(..., title=\"Manufacturer of the object\")\n    ProductName: NanStr = Field(..., title=\"Product name of the object\")\n    Appearance: NanStr = Field(..., title=\"Appearance of the glazing construction\")\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.MaterialWithThickness","title":"<code>MaterialWithThickness</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Material with a thickness.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class MaterialWithThickness(BaseModel, populate_by_name=True):\n    \"\"\"Material with a thickness.\"\"\"\n\n    Thickness: float = Field(\n        ...,\n        title=\"Thickness of the material [m]\",\n        validation_alias=\"Thickness [m]\",\n        ge=0,\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.NamedObject","title":"<code>NamedObject</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A Named object (with a name field).</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class NamedObject(BaseModel):\n    \"\"\"A Named object (with a name field).\"\"\"\n\n    Name: str = Field(..., title=\"Name of the object used in referencing.\")\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.NotImplementedClimateStudioParameter","title":"<code>NotImplementedClimateStudioParameter</code>","text":"<p>               Bases: <code>ClimateStudioException</code></p> <p>An error raised when a climate studio parameter is not implemented.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class NotImplementedClimateStudioParameter(ClimateStudioException):\n    \"\"\"An error raised when a climate studio parameter is not implemented.\"\"\"\n\n    def __init__(self, parameter_name: str, obj_name: str, obj_type: str):\n        \"\"\"Initialize the exception with a message.\n\n        Args:\n            parameter_name (str): The name of the parameter.\n            obj_name (str): The name of the object.\n            obj_type (str): The type of the object.\n        \"\"\"\n        self.parameter_name = parameter_name\n        self.obj_name = obj_name\n        self.obj_type = obj_type\n        self.message = f\"Parameter {parameter_name} not implemented for {obj_type.upper()}:{obj_name}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.NotImplementedClimateStudioParameter.__init__","title":"<code>__init__(parameter_name, obj_name, obj_type)</code>","text":"<p>Initialize the exception with a message.</p> <p>Parameters:</p> Name Type Description Default <code>parameter_name</code> <code>str</code> <p>The name of the parameter.</p> required <code>obj_name</code> <code>str</code> <p>The name of the object.</p> required <code>obj_type</code> <code>str</code> <p>The type of the object.</p> required Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def __init__(self, parameter_name: str, obj_name: str, obj_type: str):\n    \"\"\"Initialize the exception with a message.\n\n    Args:\n        parameter_name (str): The name of the parameter.\n        obj_name (str): The name of the object.\n        obj_type (str): The type of the object.\n    \"\"\"\n    self.parameter_name = parameter_name\n    self.obj_name = obj_name\n    self.obj_type = obj_type\n    self.message = f\"Parameter {parameter_name} not implemented for {obj_type.upper()}:{obj_name}\"\n    super().__init__(self.message)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.OpaqueConstruction","title":"<code>OpaqueConstruction</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>StandardMaterializedMetadata</code>, <code>ManufacturerData</code></p> <p>Opaque construction object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class OpaqueConstruction(\n    NamedObject,\n    StandardMaterializedMetadata,\n    ManufacturerData,\n    extra=\"forbid\",\n    populate_by_name=True,\n):\n    \"\"\"Opaque construction object.\"\"\"\n\n    Layers: LayerListStr = Field(..., title=\"Layers of the opaque construction\")\n    VegetationLayer: NanStr = Field(\n        ..., title=\"Vegetation layer of the opaque construction\"\n    )\n    Type: OpaqueConstructionType = Field(..., title=\"Type of the opaque construction\")\n\n    def add_to_idf(self, idf: IDF, material_defs: dict[str, OpaqueMaterial]) -&gt; IDF:\n        \"\"\"Adds an opaque construction to an IDF object.\n\n        Note that this will add the individual materials as well.\n\n        Args:\n            idf (IDF): The IDF object to add the construction to.\n            material_defs (list[OpaqueMaterial]): List of opaque material definitions.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        layers = [layer.dereference_to_material(material_defs) for layer in self.Layers]\n\n        construction = Construction(\n            name=self.Name,\n            layers=layers,\n        )\n        idf = construction.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.OpaqueConstruction.add_to_idf","title":"<code>add_to_idf(idf, material_defs)</code>","text":"<p>Adds an opaque construction to an IDF object.</p> <p>Note that this will add the individual materials as well.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the construction to.</p> required <code>material_defs</code> <code>list[OpaqueMaterial]</code> <p>List of opaque material definitions.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_to_idf(self, idf: IDF, material_defs: dict[str, OpaqueMaterial]) -&gt; IDF:\n    \"\"\"Adds an opaque construction to an IDF object.\n\n    Note that this will add the individual materials as well.\n\n    Args:\n        idf (IDF): The IDF object to add the construction to.\n        material_defs (list[OpaqueMaterial]): List of opaque material definitions.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    layers = [layer.dereference_to_material(material_defs) for layer in self.Layers]\n\n    construction = Construction(\n        name=self.Name,\n        layers=layers,\n    )\n    idf = construction.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.OpaqueConstructionLayer","title":"<code>OpaqueConstructionLayer</code>","text":"<p>               Bases: <code>MaterialWithThickness</code>, <code>NamedObject</code></p> <p>Layer of an opaque construction.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class OpaqueConstructionLayer(MaterialWithThickness, NamedObject, extra=\"forbid\"):\n    \"\"\"Layer of an opaque construction.\"\"\"\n\n    def dereference_to_material(\n        self, material_defs: dict[str, OpaqueMaterial]\n    ) -&gt; Material:\n        \"\"\"Converts a referenced material into a direct EP material object.\n\n        Args:\n            material_defs (list[OpaqueMaterial]): List of opaque material definitions.\n\n        Returns:\n            Material: The material object.\n        \"\"\"\n        if self.Name not in material_defs:\n            raise ClimateStudioValueNotFound(\"Material\", self.Name)\n\n        mat_def = material_defs[self.Name]\n\n        material = Material(\n            Name=f\"{self.Name}_{self.Thickness}\",\n            Thickness=self.Thickness,\n            Conductivity=mat_def.Conductivity,\n            Density=mat_def.Density,\n            Specific_Heat=mat_def.SpecificHeat,\n            Thermal_Absorptance=mat_def.ThermalAbsorptance,\n            Solar_Absorptance=mat_def.SolarAbsorptance,\n            Visible_Absorptance=mat_def.VisibleAbsorptance,\n            Roughness=mat_def.Roughness,\n        )\n        return material\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.OpaqueConstructionLayer.dereference_to_material","title":"<code>dereference_to_material(material_defs)</code>","text":"<p>Converts a referenced material into a direct EP material object.</p> <p>Parameters:</p> Name Type Description Default <code>material_defs</code> <code>list[OpaqueMaterial]</code> <p>List of opaque material definitions.</p> required <p>Returns:</p> Name Type Description <code>Material</code> <code>Material</code> <p>The material object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def dereference_to_material(\n    self, material_defs: dict[str, OpaqueMaterial]\n) -&gt; Material:\n    \"\"\"Converts a referenced material into a direct EP material object.\n\n    Args:\n        material_defs (list[OpaqueMaterial]): List of opaque material definitions.\n\n    Returns:\n        Material: The material object.\n    \"\"\"\n    if self.Name not in material_defs:\n        raise ClimateStudioValueNotFound(\"Material\", self.Name)\n\n    mat_def = material_defs[self.Name]\n\n    material = Material(\n        Name=f\"{self.Name}_{self.Thickness}\",\n        Thickness=self.Thickness,\n        Conductivity=mat_def.Conductivity,\n        Density=mat_def.Density,\n        Specific_Heat=mat_def.SpecificHeat,\n        Thermal_Absorptance=mat_def.ThermalAbsorptance,\n        Solar_Absorptance=mat_def.SolarAbsorptance,\n        Visible_Absorptance=mat_def.VisibleAbsorptance,\n        Roughness=mat_def.Roughness,\n    )\n    return material\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.OpaqueMaterial","title":"<code>OpaqueMaterial</code>","text":"<p>               Bases: <code>OpaqueMaterialProperties</code>, <code>StandardMaterializedMetadata</code>, <code>NamedObject</code></p> <p>Opaque material object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class OpaqueMaterial(\n    OpaqueMaterialProperties,\n    StandardMaterializedMetadata,\n    NamedObject,\n    extra=\"forbid\",\n):\n    \"\"\"Opaque material object.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.OpaqueMaterialProperties","title":"<code>OpaqueMaterialProperties</code>","text":"<p>               Bases: <code>CommonMaterialProperties</code></p> <p>Properties of an opaque material.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class OpaqueMaterialProperties(CommonMaterialProperties, populate_by_name=True):\n    \"\"\"Properties of an opaque material.\"\"\"\n\n    Roughness: str = Field(..., title=\"Roughness of the opaque material\")\n    SpecificHeat: float = Field(\n        ...,\n        title=\"Specific heat [J/kgK]\",\n        validation_alias=\"SpecificHeat [J/kg.K]\",\n        ge=0,\n    )\n    ThermalAbsorptance: float = Field(\n        ...,\n        title=\"Thermal absorptance\",\n        ge=0,\n        le=1,\n        validation_alias=\"ThermalAbsorptance [0-1]\",\n    )\n    SolarAbsorptance: float = Field(\n        ...,\n        title=\"Solar absorptance\",\n        ge=0,\n        le=1,\n        validation_alias=\"SolarAbsorptance [0-1]\",\n    )\n    VisibleAbsorptance: float = Field(\n        ...,\n        title=\"Visible absorptance\",\n        ge=0,\n        le=1,\n        validation_alias=\"VisibleAbsorptance [0-1]\",\n    )\n    PhaseChange: BoolStr = Field(\n        ...,\n        title=\"Phase change\",\n        validation_alias=\"PhaseChange [Bool]\",\n    )\n    VariableConductivity: BoolStr = Field(\n        ...,\n        title=\"Variable conductivity\",\n        validation_alias=\"VariableConductivity [Bool]\",\n    )\n    TemperatureCoefficientThermalConductivity: float = Field(\n        ...,\n        # a superscript 2 looks like this:\n        title=\"Temperature coefficient of thermal conductivity [W/m.K2\u00b2]\",\n        ge=0,\n        validation_alias=\"TemperatureCoefficientThermalConductivity [W/m-K2]\",\n    )\n    TemperatureArray: FloatListStr = Field(\n        ...,\n        title=\"Temperature array\",\n        validation_alias=\"TemperatureArray [C]\",\n    )\n    EnthalpyArray: FloatListStr = Field(\n        ...,\n        title=\"Enthalpy array\",\n        validation_alias=\"EnthalpyArray [J/kg]\",\n    )\n    VariableConductivityArray: FloatListStr = Field(\n        ...,\n        title=\"Variable conductivity array\",\n        validation_alias=\"VariableConductivityArray [W/m-K]\",\n    )\n    Type: OpaqueMaterialType = Field(\n        ..., title=\"Type of the opaque material\", validation_alias=\"Type [enum]\"\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.OtherSettings","title":"<code>OtherSettings</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Other settings object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class OtherSettings(BaseModel, extra=\"ignore\"):\n    \"\"\"Other settings object.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ScheduleParseError","title":"<code>ScheduleParseError</code>","text":"<p>               Bases: <code>ClimateStudioException</code></p> <p>An error raised when a schedule cannot be parsed.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ScheduleParseError(ClimateStudioException):\n    \"\"\"An error raised when a schedule cannot be parsed.\"\"\"\n\n    def __init__(self, schedule_name: str):\n        \"\"\"Initialize the exception with a message.\n\n        Args:\n            schedule_name (str): The name of the schedule.\n        \"\"\"\n        self.schedule_name = schedule_name\n        super().__init__(f\"Failed to parse schedule {schedule_name}\")\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ScheduleParseError.__init__","title":"<code>__init__(schedule_name)</code>","text":"<p>Initialize the exception with a message.</p> <p>Parameters:</p> Name Type Description Default <code>schedule_name</code> <code>str</code> <p>The name of the schedule.</p> required Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def __init__(self, schedule_name: str):\n    \"\"\"Initialize the exception with a message.\n\n    Args:\n        schedule_name (str): The name of the schedule.\n    \"\"\"\n    self.schedule_name = schedule_name\n    super().__init__(f\"Failed to parse schedule {schedule_name}\")\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ScheduleTransferObject","title":"<code>ScheduleTransferObject</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schedule transfer object for help with de/serialization.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ScheduleTransferObject(BaseModel):\n    \"\"\"Schedule transfer object for help with de/serialization.\"\"\"\n\n    Name: str\n    Type: dict\n    Values: list[float]\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.StandardMaterializedMetadata","title":"<code>StandardMaterializedMetadata</code>","text":"<p>               Bases: <code>EmbodiedCarbonData</code>, <code>LifecycleData</code>, <code>ClimateStudioMetadata</code></p> <p>Standard metadata for a climate studio table.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class StandardMaterializedMetadata(\n    EmbodiedCarbonData, LifecycleData, ClimateStudioMetadata\n):\n    \"\"\"Standard metadata for a climate studio table.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandler","title":"<code>SurfaceHandler</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A handler for filtering and adding surfaces to a model.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class SurfaceHandler(BaseModel):\n    \"\"\"A handler for filtering and adding surfaces to a model.\"\"\"\n\n    boundary_condition: str | None\n    original_construction_name: str | None\n    original_surface_type: str | None\n    surface_group: Literal[\"glazing\", \"opaque\"]\n\n    def assign_srfs(\n        self, idf: IDF, lib: ClimateStudioLibraryV2, construction_name: str\n    ) -&gt; IDF:\n        \"\"\"Adds a construction (and its materials) to an IDF and assigns it to matching surfaces.\n\n        Args:\n            idf (IDF): The IDF model to add the construction to.\n            lib (ClimateStudioLibraryV2): The library of constructions.\n            construction_name (str): The name of the construction to add.\n        \"\"\"\n        srf_key = (\n            \"FENESTRATIONSURFACE:DETAILED\"\n            if self.surface_group == \"glazing\"\n            else \"BUILDINGSURFACE:DETAILED\"\n        )\n        if self.boundary_condition is not None and self.surface_group == \"glazing\":\n            raise NotImplementedClimateStudioParameter(\n                \"BoundaryCondition\", self.surface_group, \"Glazing\"\n            )\n\n        srfs = [srf for srf in idf.idfobjects[srf_key] if self.check_srf(srf)]\n        construction_lib = (\n            lib.OpaqueConstructions\n            if self.surface_group != \"glazing\"\n            else lib.GlazingConstructions\n        )\n        if construction_name not in construction_lib:\n            raise KeyError(\n                f\"MISSING_CONSTRUCTION:{construction_name}:TARGET={self.__repr__()}\"\n            )\n        construction = construction_lib[construction_name]\n        idf = (\n            construction.add_to_idf(idf)\n            if isinstance(construction, GlazingConstructionSimple)\n            else construction.add_to_idf(idf, lib.OpaqueMaterials)\n        )\n        for srf in srfs:\n            srf.Construction_Name = construction.Name\n        return idf\n\n    def check_srf(self, srf):\n        \"\"\"Check if the surface matches the filters.\n\n        Args:\n            srf (eppy.IDF.BLOCK): The surface to check.\n\n        Returns:\n            match (bool): True if the surface matches the filters.\n        \"\"\"\n        return (\n            self.check_construction_type(srf)\n            and self.check_boundary(srf)\n            and self.check_construction_name(srf)\n        )\n\n    def check_construction_type(self, srf):\n        \"\"\"Check if the surface matches the construction type.\n\n        Args:\n            srf (eppy.IDF.BLOCK): The surface to check.\n\n        Returns:\n            match (bool): True if the surface matches the construction type.\n        \"\"\"\n        if self.surface_group == \"glazing\":\n            # Ignore the construction type check for windows\n            return True\n        if self.original_surface_type is None:\n            # Ignore the construction type check when filter not provided\n            return True\n        # Check the construction type\n        return self.original_surface_type.lower() == srf.Surface_Type.lower()\n\n    def check_boundary(self, srf):\n        \"\"\"Check if the surface matches the boundary condition.\n\n        Args:\n            srf (eppy.IDF.BLOCK): The surface to check.\n\n        Returns:\n            match (bool): True if the surface matches the boundary condition.\n        \"\"\"\n        if self.surface_group == \"glazing\":\n            # Ignore the bc filter check for windows\n            return True\n        if self.boundary_condition is None:\n            # Ignore the bc filter when filter not provided\n            return True\n        # Check the boundary condition\n        return srf.Outside_Boundary_Condition.lower() == self.boundary_condition.lower()\n\n    def check_construction_name(self, srf):\n        \"\"\"Check if the surface matches the original construction name.\n\n        Args:\n            srf (eppy.IDF.BLOCK): The surface to check.\n\n        Returns:\n            match (bool): True if the surface matches the original construction name.\n        \"\"\"\n        if self.original_construction_name is None:\n            # Ignore the original construction name check when filter not provided\n            return True\n        # Check the original construction name\n        return srf.Construction_Name.lower() == self.original_construction_name.lower()\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandler.assign_srfs","title":"<code>assign_srfs(idf, lib, construction_name)</code>","text":"<p>Adds a construction (and its materials) to an IDF and assigns it to matching surfaces.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the construction to.</p> required <code>lib</code> <code>ClimateStudioLibraryV2</code> <p>The library of constructions.</p> required <code>construction_name</code> <code>str</code> <p>The name of the construction to add.</p> required Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def assign_srfs(\n    self, idf: IDF, lib: ClimateStudioLibraryV2, construction_name: str\n) -&gt; IDF:\n    \"\"\"Adds a construction (and its materials) to an IDF and assigns it to matching surfaces.\n\n    Args:\n        idf (IDF): The IDF model to add the construction to.\n        lib (ClimateStudioLibraryV2): The library of constructions.\n        construction_name (str): The name of the construction to add.\n    \"\"\"\n    srf_key = (\n        \"FENESTRATIONSURFACE:DETAILED\"\n        if self.surface_group == \"glazing\"\n        else \"BUILDINGSURFACE:DETAILED\"\n    )\n    if self.boundary_condition is not None and self.surface_group == \"glazing\":\n        raise NotImplementedClimateStudioParameter(\n            \"BoundaryCondition\", self.surface_group, \"Glazing\"\n        )\n\n    srfs = [srf for srf in idf.idfobjects[srf_key] if self.check_srf(srf)]\n    construction_lib = (\n        lib.OpaqueConstructions\n        if self.surface_group != \"glazing\"\n        else lib.GlazingConstructions\n    )\n    if construction_name not in construction_lib:\n        raise KeyError(\n            f\"MISSING_CONSTRUCTION:{construction_name}:TARGET={self.__repr__()}\"\n        )\n    construction = construction_lib[construction_name]\n    idf = (\n        construction.add_to_idf(idf)\n        if isinstance(construction, GlazingConstructionSimple)\n        else construction.add_to_idf(idf, lib.OpaqueMaterials)\n    )\n    for srf in srfs:\n        srf.Construction_Name = construction.Name\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandler.check_boundary","title":"<code>check_boundary(srf)</code>","text":"<p>Check if the surface matches the boundary condition.</p> <p>Parameters:</p> Name Type Description Default <code>srf</code> <code>BLOCK</code> <p>The surface to check.</p> required <p>Returns:</p> Name Type Description <code>match</code> <code>bool</code> <p>True if the surface matches the boundary condition.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def check_boundary(self, srf):\n    \"\"\"Check if the surface matches the boundary condition.\n\n    Args:\n        srf (eppy.IDF.BLOCK): The surface to check.\n\n    Returns:\n        match (bool): True if the surface matches the boundary condition.\n    \"\"\"\n    if self.surface_group == \"glazing\":\n        # Ignore the bc filter check for windows\n        return True\n    if self.boundary_condition is None:\n        # Ignore the bc filter when filter not provided\n        return True\n    # Check the boundary condition\n    return srf.Outside_Boundary_Condition.lower() == self.boundary_condition.lower()\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandler.check_construction_name","title":"<code>check_construction_name(srf)</code>","text":"<p>Check if the surface matches the original construction name.</p> <p>Parameters:</p> Name Type Description Default <code>srf</code> <code>BLOCK</code> <p>The surface to check.</p> required <p>Returns:</p> Name Type Description <code>match</code> <code>bool</code> <p>True if the surface matches the original construction name.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def check_construction_name(self, srf):\n    \"\"\"Check if the surface matches the original construction name.\n\n    Args:\n        srf (eppy.IDF.BLOCK): The surface to check.\n\n    Returns:\n        match (bool): True if the surface matches the original construction name.\n    \"\"\"\n    if self.original_construction_name is None:\n        # Ignore the original construction name check when filter not provided\n        return True\n    # Check the original construction name\n    return srf.Construction_Name.lower() == self.original_construction_name.lower()\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandler.check_construction_type","title":"<code>check_construction_type(srf)</code>","text":"<p>Check if the surface matches the construction type.</p> <p>Parameters:</p> Name Type Description Default <code>srf</code> <code>BLOCK</code> <p>The surface to check.</p> required <p>Returns:</p> Name Type Description <code>match</code> <code>bool</code> <p>True if the surface matches the construction type.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def check_construction_type(self, srf):\n    \"\"\"Check if the surface matches the construction type.\n\n    Args:\n        srf (eppy.IDF.BLOCK): The surface to check.\n\n    Returns:\n        match (bool): True if the surface matches the construction type.\n    \"\"\"\n    if self.surface_group == \"glazing\":\n        # Ignore the construction type check for windows\n        return True\n    if self.original_surface_type is None:\n        # Ignore the construction type check when filter not provided\n        return True\n    # Check the construction type\n    return self.original_surface_type.lower() == srf.Surface_Type.lower()\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandler.check_srf","title":"<code>check_srf(srf)</code>","text":"<p>Check if the surface matches the filters.</p> <p>Parameters:</p> Name Type Description Default <code>srf</code> <code>BLOCK</code> <p>The surface to check.</p> required <p>Returns:</p> Name Type Description <code>match</code> <code>bool</code> <p>True if the surface matches the filters.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def check_srf(self, srf):\n    \"\"\"Check if the surface matches the filters.\n\n    Args:\n        srf (eppy.IDF.BLOCK): The surface to check.\n\n    Returns:\n        match (bool): True if the surface matches the filters.\n    \"\"\"\n    return (\n        self.check_construction_type(srf)\n        and self.check_boundary(srf)\n        and self.check_construction_name(srf)\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandlers","title":"<code>SurfaceHandlers</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A collection of surface handlers for different surface types.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class SurfaceHandlers(BaseModel):\n    \"\"\"A collection of surface handlers for different surface types.\"\"\"\n\n    Roof: SurfaceHandler\n    Facade: SurfaceHandler\n    Slab: SurfaceHandler\n    Ceiling: SurfaceHandler\n    Partition: SurfaceHandler\n    GroundSlab: SurfaceHandler\n    GroundWall: SurfaceHandler\n    Window: SurfaceHandler\n\n    @classmethod\n    def Default(cls):\n        \"\"\"Get the default surface handlers.\"\"\"\n        roof_handler = SurfaceHandler(\n            boundary_condition=\"outdoors\",\n            original_construction_name=None,\n            original_surface_type=\"roof\",\n            surface_group=\"opaque\",\n        )\n        facade_handler = SurfaceHandler(\n            boundary_condition=\"outdoors\",\n            original_construction_name=None,\n            original_surface_type=\"wall\",\n            surface_group=\"opaque\",\n        )\n        partition_handler = SurfaceHandler(\n            boundary_condition=\"surface\",\n            original_construction_name=None,\n            original_surface_type=\"wall\",\n            surface_group=\"opaque\",\n        )\n        ground_wall_handler = SurfaceHandler(\n            boundary_condition=\"ground\",\n            original_construction_name=None,\n            original_surface_type=\"wall\",\n            surface_group=\"opaque\",\n        )\n        slab_handler = SurfaceHandler(\n            boundary_condition=\"surface\",\n            original_construction_name=None,\n            original_surface_type=\"floor\",\n            surface_group=\"opaque\",\n        )\n        ceiling_handler = SurfaceHandler(\n            boundary_condition=\"surface\",\n            original_construction_name=None,\n            original_surface_type=\"ceiling\",\n            surface_group=\"opaque\",\n        )\n        ground_slab_handler = SurfaceHandler(\n            boundary_condition=\"ground\",\n            original_construction_name=None,\n            original_surface_type=\"floor\",\n            surface_group=\"opaque\",\n        )\n        window_handler = SurfaceHandler(\n            boundary_condition=None,\n            original_construction_name=None,\n            original_surface_type=None,\n            surface_group=\"glazing\",\n        )\n\n        return cls(\n            Roof=roof_handler,\n            Facade=facade_handler,\n            Slab=slab_handler,\n            Ceiling=ceiling_handler,\n            Partition=partition_handler,\n            GroundSlab=ground_slab_handler,\n            GroundWall=ground_wall_handler,\n            Window=window_handler,\n        )\n\n    def handle_envelope(\n        self,\n        idf: IDF,\n        lib: ClimateStudioLibraryV2,\n        constructions: ZoneConstruction,\n        window: WindowDefinition | None,\n    ):\n        \"\"\"Assign the envelope to the IDF model.\n\n        Note that this will add a \"reversed\" construction for the floorsystem slab/ceiling\n\n        Args:\n            idf (IDF): The IDF model to add the envelope to.\n            lib (ClimateStudioLibraryV2): The library of constructions.\n            constructions (ZoneConstruction): The construction names for the envelope.\n            window (WindowDefinition | None): The window definition.\n\n        Returns:\n            idf (IDF): The updated IDF model.\n        \"\"\"\n\n        # outside walls are the ones with outdoor boundary condition and vertical orientation\n        def make_reversed(const: OpaqueConstruction):\n            new_const = const.model_copy(deep=True)\n            new_const.Layers = new_const.Layers[::-1]\n            new_const.Name = f\"{const.Name}_Reversed\"\n            return new_const\n\n        def reverse_construction(const_name: str, lib: ClimateStudioLibraryV2):\n            const = lib.OpaqueConstructions[const_name]\n            new_const = make_reversed(const)\n            return new_const\n\n        slab_reversed = reverse_construction(constructions.SlabConstruction, lib)\n        lib.OpaqueConstructions[slab_reversed.Name] = slab_reversed\n\n        idf = self.Roof.assign_srfs(\n            idf=idf, lib=lib, construction_name=constructions.RoofConstruction\n        )\n        idf = self.Facade.assign_srfs(\n            idf=idf, lib=lib, construction_name=constructions.FacadeConstruction\n        )\n        idf = self.Partition.assign_srfs(\n            idf=idf, lib=lib, construction_name=constructions.PartitionConstruction\n        )\n        idf = self.Slab.assign_srfs(\n            idf=idf, lib=lib, construction_name=slab_reversed.Name\n        )\n        idf = self.Ceiling.assign_srfs(\n            idf=idf, lib=lib, construction_name=constructions.SlabConstruction\n        )\n        idf = self.GroundSlab.assign_srfs(\n            idf=idf, lib=lib, construction_name=constructions.GroundSlabConstruction\n        )\n        idf = self.GroundWall.assign_srfs(\n            idf=idf, lib=lib, construction_name=constructions.GroundWallConstruction\n        )\n        if window:\n            idf = self.Window.assign_srfs(\n                idf=idf, lib=lib, construction_name=window.Construction\n            )\n        return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandlers.Default","title":"<code>Default()</code>  <code>classmethod</code>","text":"<p>Get the default surface handlers.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>@classmethod\ndef Default(cls):\n    \"\"\"Get the default surface handlers.\"\"\"\n    roof_handler = SurfaceHandler(\n        boundary_condition=\"outdoors\",\n        original_construction_name=None,\n        original_surface_type=\"roof\",\n        surface_group=\"opaque\",\n    )\n    facade_handler = SurfaceHandler(\n        boundary_condition=\"outdoors\",\n        original_construction_name=None,\n        original_surface_type=\"wall\",\n        surface_group=\"opaque\",\n    )\n    partition_handler = SurfaceHandler(\n        boundary_condition=\"surface\",\n        original_construction_name=None,\n        original_surface_type=\"wall\",\n        surface_group=\"opaque\",\n    )\n    ground_wall_handler = SurfaceHandler(\n        boundary_condition=\"ground\",\n        original_construction_name=None,\n        original_surface_type=\"wall\",\n        surface_group=\"opaque\",\n    )\n    slab_handler = SurfaceHandler(\n        boundary_condition=\"surface\",\n        original_construction_name=None,\n        original_surface_type=\"floor\",\n        surface_group=\"opaque\",\n    )\n    ceiling_handler = SurfaceHandler(\n        boundary_condition=\"surface\",\n        original_construction_name=None,\n        original_surface_type=\"ceiling\",\n        surface_group=\"opaque\",\n    )\n    ground_slab_handler = SurfaceHandler(\n        boundary_condition=\"ground\",\n        original_construction_name=None,\n        original_surface_type=\"floor\",\n        surface_group=\"opaque\",\n    )\n    window_handler = SurfaceHandler(\n        boundary_condition=None,\n        original_construction_name=None,\n        original_surface_type=None,\n        surface_group=\"glazing\",\n    )\n\n    return cls(\n        Roof=roof_handler,\n        Facade=facade_handler,\n        Slab=slab_handler,\n        Ceiling=ceiling_handler,\n        Partition=partition_handler,\n        GroundSlab=ground_slab_handler,\n        GroundWall=ground_wall_handler,\n        Window=window_handler,\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandlers.handle_envelope","title":"<code>handle_envelope(idf, lib, constructions, window)</code>","text":"<p>Assign the envelope to the IDF model.</p> <p>Note that this will add a \"reversed\" construction for the floorsystem slab/ceiling</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the envelope to.</p> required <code>lib</code> <code>ClimateStudioLibraryV2</code> <p>The library of constructions.</p> required <code>constructions</code> <code>ZoneConstruction</code> <p>The construction names for the envelope.</p> required <code>window</code> <code>WindowDefinition | None</code> <p>The window definition.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF model.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def handle_envelope(\n    self,\n    idf: IDF,\n    lib: ClimateStudioLibraryV2,\n    constructions: ZoneConstruction,\n    window: WindowDefinition | None,\n):\n    \"\"\"Assign the envelope to the IDF model.\n\n    Note that this will add a \"reversed\" construction for the floorsystem slab/ceiling\n\n    Args:\n        idf (IDF): The IDF model to add the envelope to.\n        lib (ClimateStudioLibraryV2): The library of constructions.\n        constructions (ZoneConstruction): The construction names for the envelope.\n        window (WindowDefinition | None): The window definition.\n\n    Returns:\n        idf (IDF): The updated IDF model.\n    \"\"\"\n\n    # outside walls are the ones with outdoor boundary condition and vertical orientation\n    def make_reversed(const: OpaqueConstruction):\n        new_const = const.model_copy(deep=True)\n        new_const.Layers = new_const.Layers[::-1]\n        new_const.Name = f\"{const.Name}_Reversed\"\n        return new_const\n\n    def reverse_construction(const_name: str, lib: ClimateStudioLibraryV2):\n        const = lib.OpaqueConstructions[const_name]\n        new_const = make_reversed(const)\n        return new_const\n\n    slab_reversed = reverse_construction(constructions.SlabConstruction, lib)\n    lib.OpaqueConstructions[slab_reversed.Name] = slab_reversed\n\n    idf = self.Roof.assign_srfs(\n        idf=idf, lib=lib, construction_name=constructions.RoofConstruction\n    )\n    idf = self.Facade.assign_srfs(\n        idf=idf, lib=lib, construction_name=constructions.FacadeConstruction\n    )\n    idf = self.Partition.assign_srfs(\n        idf=idf, lib=lib, construction_name=constructions.PartitionConstruction\n    )\n    idf = self.Slab.assign_srfs(\n        idf=idf, lib=lib, construction_name=slab_reversed.Name\n    )\n    idf = self.Ceiling.assign_srfs(\n        idf=idf, lib=lib, construction_name=constructions.SlabConstruction\n    )\n    idf = self.GroundSlab.assign_srfs(\n        idf=idf, lib=lib, construction_name=constructions.GroundSlabConstruction\n    )\n    idf = self.GroundWall.assign_srfs(\n        idf=idf, lib=lib, construction_name=constructions.GroundWallConstruction\n    )\n    if window:\n        idf = self.Window.assign_srfs(\n            idf=idf, lib=lib, construction_name=window.Construction\n        )\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.WindowDefinition","title":"<code>WindowDefinition</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Window definition object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class WindowDefinition(NamedObject, ClimateStudioMetadata, extra=\"ignore\"):\n    \"\"\"Window definition object.\"\"\"\n\n    Construction: str = Field(..., title=\"Construction object name\")\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        return set()\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.WindowDefinition.schedule_names","title":"<code>schedule_names: set[str]</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneConditioning","title":"<code>ZoneConditioning</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone conditioning object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ZoneConditioning(\n    NamedObject, ClimateStudioMetadata, extra=\"forbid\", populate_by_name=True\n):\n    \"\"\"Zone conditioning object.\"\"\"\n\n    HeatingSetpoint: float = Field(\n        ...,\n        title=\"Heating setpoint [\u00b0C]\",\n        validation_alias=\"HeatingSetpoint [\u00b0C]\",\n        ge=0,\n        le=100,\n    )\n    CoolingSetpoint: float = Field(\n        ...,\n        title=\"Cooling setpoint [\u00b0C]\",\n        validation_alias=\"CoolingSetpoint [\u00b0C]\",\n        ge=0,\n        le=100,\n    )\n    # TODO: should we validate heating &lt; cooling?\n    HeatingSetpointConstant: BoolStr = Field(..., title=\"Heating setpoint constant\")\n    CoolingSetpointConstant: BoolStr = Field(..., title=\"Cooling setpoint constant\")\n    HeatingSetpointSchedule: str = Field(..., title=\"Heating setpoint schedule\")\n    CoolingSetpointSchedule: str = Field(..., title=\"Cooling setpoint schedule\")\n    MinFreshAirPerson: float = Field(\n        ...,\n        title=\"Minimum fresh air per person [L/s/p]\",\n        validation_alias=\"MinFreshAirPerson [L/s/p]\",\n        ge=0,\n    )\n    MinFreshAirArea: float = Field(\n        ...,\n        title=\"Minimum fresh air per area [L/s/m\u00b2]\",\n        validation_alias=\"MinFreshAirArea [L/s/m\u00b2]\",\n        ge=0,\n    )\n    CoolingCOP: float = Field(\n        ...,\n        title=\"Cooling Coefficient of Performance\",\n        ge=0,\n    )\n    HeatingCOP: float = Field(\n        ...,\n        title=\"Heating Coefficient of Performance\",\n        ge=0,\n    )\n    HeatIsOn: BoolStr = Field(..., title=\"Heat is on\")\n    CoolIsOn: BoolStr = Field(..., title=\"Cool is on\")\n    MechVentIsOn: BoolStr = Field(..., title=\"Mechanical ventilation is on\")\n    HumidistatIsOn: BoolStr = Field(\n        ...,\n        title=\"Humidistat is on\",\n        validation_alias=\"HumidistatIsOn [Bool]\",\n    )\n    HeatingLimitType: IdealLoadsLimitType = Field(\n        ...,\n        title=\"Heating limit type\",\n        validation_alias=\"HeatingLimitType [enum]\",\n    )\n    CoolingLimitType: IdealLoadsLimitType = Field(\n        ...,\n        title=\"Cooling limit type\",\n        validation_alias=\"CoolingLimitType [enum]\",\n    )\n    MaxHeatingCapacity: float = Field(\n        ...,\n        title=\"Maximum heating capacity [W/m\u00b2]\",\n        validation_alias=\"MaxHeatingCapacity [W/m\u00b2]\",\n        ge=0,\n    )\n    MaxCoolingCapacity: float = Field(\n        ...,\n        title=\"Maximum cooling capacity [W/m\u00b2]\",\n        validation_alias=\"MaxCoolingCapacity [W/m\u00b2]\",\n        ge=0,\n    )\n    MaxHeatFlow: float = Field(\n        ...,\n        title=\"Maximum volumetric heat flow per flow area [m\u00b3/s/m\u00b2]\",\n        validation_alias=\"MaxHeatFlow [m\u00b3/s/m\u00b2]\",\n        ge=0,\n    )\n    MaxCoolFlow: float = Field(\n        ...,\n        title=\"Maximum volumetric cool flow per flow area [m\u00b3/s/m\u00b2]\",\n        validation_alias=\"MaxCoolFlow [m\u00b3/s/m\u00b2]\",\n        ge=0,\n    )\n    HeatingSchedule: str = Field(\n        ...,\n        title=\"Heating schedule\",\n        validation_alias=\"HeatingSchedule [Schedule name]\",\n    )\n    CoolingSchedule: str = Field(\n        ...,\n        title=\"Cooling schedule\",\n        validation_alias=\"CoolingSchedule [Schedule name]\",\n    )\n    MechVentSchedule: str = Field(\n        ...,\n        title=\"Mechanical ventilation schedule\",\n        validation_alias=\"MechVentSchedule [Schedule name]\",\n    )\n    EconomizerType: OutdoorAirEconomizerTypeType = Field(\n        ...,\n        title=\"Economizer type\",\n        validation_alias=\"EconomizerType [enum]\",\n    )\n    HeatRecoveryType: HeatRecoveryTypeType = Field(\n        ...,\n        title=\"Heat recovery type\",\n        validation_alias=\"HeatRecoveryType [enum]\",\n    )\n    HeatRecoveryEfficiencySensible: float = Field(\n        ...,\n        title=\"Heat recovery efficiency sensible\",\n        ge=0,\n        le=1,\n        validation_alias=\"HeatRecoveryEfficiencySensible [0-1]\",\n    )\n    HeatRecoveryEfficiencyLatent: float = Field(\n        ...,\n        title=\"Heat recovery efficiency latent\",\n        ge=0,\n        le=1,\n        validation_alias=\"HeatRecoveryEfficiencyLatent [0-1]\",\n    )\n    MinHumidity: float = Field(\n        ...,\n        title=\"Minimum humidity [%]\",\n        ge=0,\n        le=100,\n        validation_alias=\"MinHumidity [RH%]\",\n    )\n    MaxHumidity: float = Field(\n        ...,\n        title=\"Maximum humidity [%]\",\n        ge=0,\n        le=100,\n        validation_alias=\"MaxHumidity [RH%]\",\n    )\n    EMSFanEnergyIsOn: BoolStr = Field(..., title=\"EMS fan energy is on\")\n    FanPressureRise: float = Field(\n        ...,\n        title=\"Fan pressure rise [Pa]\",\n        ge=0,\n        validation_alias=\"FanPressureRise [Pa]\",\n    )\n    MaxHeatSupplyAirTemp: float = Field(\n        ...,\n        title=\"Maximum heat supply air temperature [\u00b0C]\",\n        ge=0,\n        validation_alias=\"MaxHeatSupplyAirTemp [\u00b0C]\",\n    )\n    MinCoolSupplyAirTemp: float = Field(\n        ...,\n        title=\"Minimum cool supply air temperature [\u00b0C]\",\n        ge=0,\n        validation_alias=\"MinCoolSupplyAirTemp [\u00b0C]\",\n    )\n    HeatingSizingFactor: float = Field(\n        ...,\n        title=\"Heating sizing factor\",\n        ge=0,\n        validation_alias=\"HeatingSizingFactor [Unitless]\",\n    )\n    CoolingSizingFactor: float = Field(\n        ...,\n        title=\"Cooling sizing factor\",\n        ge=0,\n        validation_alias=\"CoolingSizingFactor [Unitless]\",\n    )\n    Autosize: BoolStr = Field(\n        ...,\n        title=\"Autosize\",\n        validation_alias=\"Autosize [Bool]\",\n    )\n    HeatingFuelType: FuelType = Field(\n        ...,\n        title=\"Heating fuel type\",\n        validation_alias=\"HeatingFuelType [enum]\",\n    )\n    CoolingFuelType: FuelType = Field(\n        ...,\n        title=\"Cooling fuel type\",\n        validation_alias=\"CoolingFuelType [enum]\",\n    )\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        cond_scheds = set()\n\n        if self.HeatIsOn:\n            cond_scheds.add(self.HeatingSchedule)\n\n        if self.CoolIsOn:\n            cond_scheds.add(self.CoolingSchedule)\n        if not self.HeatingSetpointConstant and self.HeatIsOn:\n            cond_scheds.add(self.HeatingSetpointSchedule)\n\n        if not self.CoolingSetpointConstant and self.CoolIsOn:\n            cond_scheds.add(self.CoolingSetpointSchedule)\n\n        if self.MechVentIsOn:\n            cond_scheds.add(self.MechVentSchedule)\n\n        return cond_scheds\n\n    def add_conditioning_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n        \"\"\"Add conditioning to an IDF zone.\n\n        This constructs HVAC template objects which get assigned to the zone.\n\n        NB: currently, many of the climate studio parameters are ignored -\n        particularly the ones related to humidity control.\n\n        Args:\n            idf (IDF): The IDF object to add the conditioning to.\n            target_zone_name (str): The name of the zone to add the conditioning to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if self.HumidistatIsOn:\n            raise NotImplementedClimateStudioParameter(\n                \"HumidistatIsOn\",\n                self.Name,\n                \"Conditioning\",\n            )\n\n        if self.EMSFanEnergyIsOn:\n            raise NotImplementedClimateStudioParameter(\n                \"EMSFanEnergyIsOn\",\n                self.Name,\n                \"Conditioning\",\n            )\n\n        thermostat = HVACTemplateThermostat(\n            Name=f\"{self.Name}_{target_zone_name}_Thermostat\",\n            Heating_Setpoint_Schedule_Name=(\n                self.HeatingSetpointSchedule\n                if not self.HeatingSetpointConstant\n                else None\n            ),\n            Cooling_Setpoint_Schedule_Name=(\n                self.CoolingSetpointSchedule\n                if not self.CoolingSetpointConstant\n                else None\n            ),\n            Constant_Cooling_Setpoint=(\n                self.CoolingSetpoint if self.CoolingSetpointConstant else None\n            ),\n            Constant_Heating_Setpoint=(\n                self.HeatingSetpoint if self.HeatingSetpointConstant else None\n            ),\n        )\n\n        # TODO: better handling of alwayson/off schedule names\n        # TODO: better handling of mech vent schedule\n        logger.warning(\n            f\"Mechanical ventilation schedule is being ignored in zone {target_zone_name}.\"\n        )\n        hvac_template = HVACTemplateZoneIdealLoadsAirSystem(\n            Zone_Name=target_zone_name,\n            Template_Thermostat_Name=thermostat.Name,\n            System_Availability_Schedule_Name=\"AlwaysOn\",\n            Heating_Availability_Schedule_Name=(\n                self.HeatingSchedule if self.HeatIsOn else \"AlwaysOff\"\n            ),\n            Cooling_Availability_Schedule_Name=(\n                self.CoolingSchedule if self.CoolIsOn else None\n            ),\n            Maximum_Heating_Supply_Air_Temperature=self.MaxHeatSupplyAirTemp,\n            Maximum_Heating_Air_Flow_Rate=self.MaxHeatFlow\n            if not self.Autosize\n            else \"autosize\",\n            Maximum_Sensible_Heating_Capacity=self.MaxHeatingCapacity\n            if not self.Autosize\n            else \"autosize\",\n            Minimum_Cooling_Supply_Air_Temperature=self.MinCoolSupplyAirTemp,\n            Maximum_Cooling_Air_Flow_Rate=self.MaxCoolFlow\n            if not self.Autosize\n            else \"autosize\",\n            Maximum_Total_Cooling_Capacity=self.MaxCoolingCapacity\n            if not self.Autosize\n            else \"autosize\",\n            Heating_Limit=self.HeatingLimitType,\n            Cooling_Limit=self.CoolingLimitType,\n            Humidification_Control_Type=\"None\",\n            Outdoor_Air_Method=\"Sum\" if self.MechVentIsOn else \"None\",\n            Outdoor_Air_Flow_Rate_per_Person=self.MinFreshAirPerson\n            / 1000,  # convert to m3\n            Outdoor_Air_Flow_Rate_per_Zone_Floor_Area=self.MinFreshAirArea\n            / 1000,  # convert to m3\n            Outdoor_Air_Flow_Rate_per_Zone=0,\n            Demand_Controlled_Ventilation_Type=\"None\",\n            Outdoor_Air_Economizer_Type=self.EconomizerType,\n            Heat_Recovery_Type=self.HeatRecoveryType,\n            Sensible_Heat_Recovery_Effectiveness=self.HeatRecoveryEfficiencySensible,\n            Latent_Heat_Recovery_Effectiveness=self.HeatRecoveryEfficiencyLatent,\n        )\n\n        idf = thermostat.add(idf)\n        idf = hvac_template.add(idf)\n        if self.Autosize:\n            sizing = SizingParameters(\n                Heating_Sizing_Factor=self.HeatingSizingFactor,\n                Cooling_Sizing_Factor=self.CoolingSizingFactor,\n            )\n            idf = sizing.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneConditioning.schedule_names","title":"<code>schedule_names: set[str]</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneConditioning.add_conditioning_to_idf_zone","title":"<code>add_conditioning_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Add conditioning to an IDF zone.</p> <p>This constructs HVAC template objects which get assigned to the zone.</p> <p>NB: currently, many of the climate studio parameters are ignored - particularly the ones related to humidity control.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the conditioning to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the conditioning to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_conditioning_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n    \"\"\"Add conditioning to an IDF zone.\n\n    This constructs HVAC template objects which get assigned to the zone.\n\n    NB: currently, many of the climate studio parameters are ignored -\n    particularly the ones related to humidity control.\n\n    Args:\n        idf (IDF): The IDF object to add the conditioning to.\n        target_zone_name (str): The name of the zone to add the conditioning to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if self.HumidistatIsOn:\n        raise NotImplementedClimateStudioParameter(\n            \"HumidistatIsOn\",\n            self.Name,\n            \"Conditioning\",\n        )\n\n    if self.EMSFanEnergyIsOn:\n        raise NotImplementedClimateStudioParameter(\n            \"EMSFanEnergyIsOn\",\n            self.Name,\n            \"Conditioning\",\n        )\n\n    thermostat = HVACTemplateThermostat(\n        Name=f\"{self.Name}_{target_zone_name}_Thermostat\",\n        Heating_Setpoint_Schedule_Name=(\n            self.HeatingSetpointSchedule\n            if not self.HeatingSetpointConstant\n            else None\n        ),\n        Cooling_Setpoint_Schedule_Name=(\n            self.CoolingSetpointSchedule\n            if not self.CoolingSetpointConstant\n            else None\n        ),\n        Constant_Cooling_Setpoint=(\n            self.CoolingSetpoint if self.CoolingSetpointConstant else None\n        ),\n        Constant_Heating_Setpoint=(\n            self.HeatingSetpoint if self.HeatingSetpointConstant else None\n        ),\n    )\n\n    # TODO: better handling of alwayson/off schedule names\n    # TODO: better handling of mech vent schedule\n    logger.warning(\n        f\"Mechanical ventilation schedule is being ignored in zone {target_zone_name}.\"\n    )\n    hvac_template = HVACTemplateZoneIdealLoadsAirSystem(\n        Zone_Name=target_zone_name,\n        Template_Thermostat_Name=thermostat.Name,\n        System_Availability_Schedule_Name=\"AlwaysOn\",\n        Heating_Availability_Schedule_Name=(\n            self.HeatingSchedule if self.HeatIsOn else \"AlwaysOff\"\n        ),\n        Cooling_Availability_Schedule_Name=(\n            self.CoolingSchedule if self.CoolIsOn else None\n        ),\n        Maximum_Heating_Supply_Air_Temperature=self.MaxHeatSupplyAirTemp,\n        Maximum_Heating_Air_Flow_Rate=self.MaxHeatFlow\n        if not self.Autosize\n        else \"autosize\",\n        Maximum_Sensible_Heating_Capacity=self.MaxHeatingCapacity\n        if not self.Autosize\n        else \"autosize\",\n        Minimum_Cooling_Supply_Air_Temperature=self.MinCoolSupplyAirTemp,\n        Maximum_Cooling_Air_Flow_Rate=self.MaxCoolFlow\n        if not self.Autosize\n        else \"autosize\",\n        Maximum_Total_Cooling_Capacity=self.MaxCoolingCapacity\n        if not self.Autosize\n        else \"autosize\",\n        Heating_Limit=self.HeatingLimitType,\n        Cooling_Limit=self.CoolingLimitType,\n        Humidification_Control_Type=\"None\",\n        Outdoor_Air_Method=\"Sum\" if self.MechVentIsOn else \"None\",\n        Outdoor_Air_Flow_Rate_per_Person=self.MinFreshAirPerson\n        / 1000,  # convert to m3\n        Outdoor_Air_Flow_Rate_per_Zone_Floor_Area=self.MinFreshAirArea\n        / 1000,  # convert to m3\n        Outdoor_Air_Flow_Rate_per_Zone=0,\n        Demand_Controlled_Ventilation_Type=\"None\",\n        Outdoor_Air_Economizer_Type=self.EconomizerType,\n        Heat_Recovery_Type=self.HeatRecoveryType,\n        Sensible_Heat_Recovery_Effectiveness=self.HeatRecoveryEfficiencySensible,\n        Latent_Heat_Recovery_Effectiveness=self.HeatRecoveryEfficiencyLatent,\n    )\n\n    idf = thermostat.add(idf)\n    idf = hvac_template.add(idf)\n    if self.Autosize:\n        sizing = SizingParameters(\n            Heating_Sizing_Factor=self.HeatingSizingFactor,\n            Cooling_Sizing_Factor=self.CoolingSizingFactor,\n        )\n        idf = sizing.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneConstruction","title":"<code>ZoneConstruction</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone construction object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ZoneConstruction(\n    NamedObject, ClimateStudioMetadata, extra=\"forbid\", populate_by_name=True\n):\n    \"\"\"Zone construction object.\"\"\"\n\n    RoofConstruction: str = Field(..., title=\"Roof construction object name\")\n    FacadeConstruction: str = Field(..., title=\"Facade construction object name\")\n    SlabConstruction: str = Field(..., title=\"Slab construction object name\")\n    PartitionConstruction: str = Field(..., title=\"Partition construction object name\")\n    ExternalFloorConstruction: str = Field(\n        ..., title=\"External floor construction object name\"\n    )\n    GroundSlabConstruction: str = Field(\n        ..., title=\"Ground slab construction object name\"\n    )\n    GroundWallConstruction: str = Field(\n        ..., title=\"Ground wall construction object name\"\n    )\n    InternalMassConstruction: str = Field(\n        ..., title=\"Internal mass construction object name\"\n    )\n    InternalMassIsOn: BoolStr = Field(..., title=\"Internal mass is on\")\n    InternalMassExposedAreaPerArea: float = Field(\n        ...,\n        title=\"Internal mass exposed area per area [m\u00b2/m\u00b2]\",\n        validation_alias=\"InternalMassExposedAreaPerArea [area / floor (m2/m2)]\",\n    )\n    GroundIsAdiabatic: BoolStr = Field(..., title=\"Ground is adiabatic\")\n    RoofIsAdiabatic: BoolStr = Field(..., title=\"Roof is adiabatic\")\n    FacadeIsAdiabatic: BoolStr = Field(..., title=\"Facade is adiabatic\")\n    SlabIsAdiabatic: BoolStr = Field(..., title=\"Slab is adiabatic\")\n    PartitionIsAdiabatic: BoolStr = Field(..., title=\"Partition is adiabatic\")\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneDefinition","title":"<code>ZoneDefinition</code>","text":"<p>               Bases: <code>NamedObject</code></p> <p>Zone definition object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ZoneDefinition(NamedObject, extra=\"forbid\"):\n    \"\"\"Zone definition object.\"\"\"\n\n    Loads: str = Field(..., title=\"Loads object name\")\n    Conditioning: str = Field(..., title=\"Conditioning object name\")\n    NaturalVentilation: str = Field(..., title=\"Natural ventilation object name\")\n    Constructions: str = Field(..., title=\"Construction object name\")\n    HotWater: str = Field(..., title=\"Hot water object name\")\n    Infiltration: str = Field(..., title=\"Infiltration object name\")\n    DataSource: NanStr = Field(\n        ..., title=\"Data source of the object\", validation_alias=\"Data Source\"\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneEnvelope","title":"<code>ZoneEnvelope</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone envelope object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ZoneEnvelope(NamedObject, ClimateStudioMetadata, extra=\"forbid\"):\n    \"\"\"Zone envelope object.\"\"\"\n\n    Constructions: ZoneConstruction\n    Infiltration: ZoneInfiltration\n    WindowDefinition: WindowDefinition | None\n    WWR: float | None = Field(\n        default=0.1, description=\"Window to wall ratio\", ge=0, le=1\n    )\n    Foundation: Foundation | None\n    OtherSettings: OtherSettings | None\n    BuildingType: str | int = Field(..., title=\"Building type\")\n\n    # TODO: add envelope to idf zone\n    # (currently in builder)\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        win_sch = (\n            self.WindowDefinition.schedule_names if self.WindowDefinition else set()\n        )\n        return win_sch\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneEnvelope.schedule_names","title":"<code>schedule_names: set[str]</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneHotWater","title":"<code>ZoneHotWater</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone Hot Water object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ZoneHotWater(\n    NamedObject, ClimateStudioMetadata, extra=\"ignore\", populate_by_name=True\n):\n    \"\"\"Zone Hot Water object.\"\"\"\n\n    DomHotWaterCOP: float = Field(\n        ...,\n        title=\"Domestic hot water coefficient of performance\",\n        ge=0,\n    )\n    WaterTemperatureInlet: float = Field(\n        ...,\n        title=\"Water temperature inlet [\u00b0C]\",\n        ge=0,\n        le=100,\n    )\n    WaterSupplyTemperature: float = Field(\n        ...,\n        title=\"Water supply temperature [\u00b0C]\",\n        ge=0,\n        le=100,\n    )\n    WaterSchedule: str = Field(..., title=\"Water schedule\")\n    FlowRatePerPerson: float = Field(\n        ..., title=\"Flow rate per person [m3/hr/p]\", ge=0, le=0.1\n    )\n    IsOn: BoolStr = Field(..., title=\"Is on\")\n    HotWaterFuelType: FuelType = Field(..., title=\"Hot water fuel type\")\n\n    @model_validator(mode=\"before\")\n    def validate_supply_greater_than_inlet(cls, values: dict[str, Any]):\n        \"\"\"Validate that the supply temperature is greater than the inlet temperature.\"\"\"\n        if values[\"WaterSupplyTemperature\"] &lt;= values[\"WaterTemperatureInlet\"]:\n            msg = \"Water supply temperature must be greater than the inlet temperature.\"\n            raise ValueError(msg)\n        return values\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        return {self.WaterSchedule} if self.IsOn else set()\n\n    def add_water_to_idf_zone(\n        self, idf: IDF, target_zone_name: str, total_ppl: float\n    ) -&gt; IDF:\n        \"\"\"Add the hot water to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the hot water to.\n            target_zone_name (str): The name of the zone to add the hot water to.\n            total_ppl (float): The total number of people in the zone.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if not self.IsOn:\n            return idf\n\n        total_flow_rate = self.FlowRatePerPerson * total_ppl  # m3/hr\n        total_flow_rate_per_s = total_flow_rate / 3600  # m3/s\n\n        lim = \"Temperature\"\n        if not idf.getobject(\"SCHEDULETYPELIMITS\", lim):\n            lim = ScheduleTypeLimits(\n                Name=\"Temperature\",\n                LowerLimit=-60,\n                UpperLimit=200,\n            )\n            lim.to_epbunch(idf)\n\n        target_temperature_schedule = Schedule.constant_schedule(\n            value=self.WaterSupplyTemperature,  # pyright: ignore [reportArgumentType]\n            Name=f\"{target_zone_name}_{self.Name}_TargetWaterTemperatureSch\",\n            Type=\"Temperature\",\n        )\n        inlet_temperature_schedule = Schedule.constant_schedule(\n            value=self.WaterTemperatureInlet,  # pyright: ignore [reportArgumentType]\n            Name=f\"{target_zone_name}_{self.Name}_InletWaterTemperatureSch\",\n            Type=\"Temperature\",\n        )\n\n        target_temperature_yr_schedule, *_ = (\n            target_temperature_schedule.to_year_week_day()\n        )\n        inlet_temperature_yr_schedule, *_ = (\n            inlet_temperature_schedule.to_year_week_day()\n        )\n\n        target_temperature_yr_schedule.to_epbunch(idf)\n        inlet_temperature_yr_schedule.to_epbunch(idf)\n\n        hot_water = WaterUseEquipment(\n            Name=f\"{target_zone_name}_{self.Name}_HotWater\",\n            EndUse_Subcategory=\"Domestic Hot Water\",\n            Peak_Flow_Rate=total_flow_rate_per_s,\n            Flow_Rate_Fraction_Schedule_Name=self.WaterSchedule,\n            Zone_Name=target_zone_name,\n            Target_Temperature_Schedule_Name=target_temperature_yr_schedule.Name,\n            Hot_Water_Supply_Temperature_Schedule_Name=target_temperature_schedule.Name,\n            Cold_Water_Supply_Temperature_Schedule_Name=inlet_temperature_schedule.Name,\n            Sensible_Fraction_Schedule_Name=None,\n            Latent_Fraction_Schedule_Name=None,\n        )\n        idf = hot_water.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneHotWater.schedule_names","title":"<code>schedule_names: set[str]</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneHotWater.add_water_to_idf_zone","title":"<code>add_water_to_idf_zone(idf, target_zone_name, total_ppl)</code>","text":"<p>Add the hot water to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the hot water to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the hot water to.</p> required <code>total_ppl</code> <code>float</code> <p>The total number of people in the zone.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_water_to_idf_zone(\n    self, idf: IDF, target_zone_name: str, total_ppl: float\n) -&gt; IDF:\n    \"\"\"Add the hot water to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the hot water to.\n        target_zone_name (str): The name of the zone to add the hot water to.\n        total_ppl (float): The total number of people in the zone.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if not self.IsOn:\n        return idf\n\n    total_flow_rate = self.FlowRatePerPerson * total_ppl  # m3/hr\n    total_flow_rate_per_s = total_flow_rate / 3600  # m3/s\n\n    lim = \"Temperature\"\n    if not idf.getobject(\"SCHEDULETYPELIMITS\", lim):\n        lim = ScheduleTypeLimits(\n            Name=\"Temperature\",\n            LowerLimit=-60,\n            UpperLimit=200,\n        )\n        lim.to_epbunch(idf)\n\n    target_temperature_schedule = Schedule.constant_schedule(\n        value=self.WaterSupplyTemperature,  # pyright: ignore [reportArgumentType]\n        Name=f\"{target_zone_name}_{self.Name}_TargetWaterTemperatureSch\",\n        Type=\"Temperature\",\n    )\n    inlet_temperature_schedule = Schedule.constant_schedule(\n        value=self.WaterTemperatureInlet,  # pyright: ignore [reportArgumentType]\n        Name=f\"{target_zone_name}_{self.Name}_InletWaterTemperatureSch\",\n        Type=\"Temperature\",\n    )\n\n    target_temperature_yr_schedule, *_ = (\n        target_temperature_schedule.to_year_week_day()\n    )\n    inlet_temperature_yr_schedule, *_ = (\n        inlet_temperature_schedule.to_year_week_day()\n    )\n\n    target_temperature_yr_schedule.to_epbunch(idf)\n    inlet_temperature_yr_schedule.to_epbunch(idf)\n\n    hot_water = WaterUseEquipment(\n        Name=f\"{target_zone_name}_{self.Name}_HotWater\",\n        EndUse_Subcategory=\"Domestic Hot Water\",\n        Peak_Flow_Rate=total_flow_rate_per_s,\n        Flow_Rate_Fraction_Schedule_Name=self.WaterSchedule,\n        Zone_Name=target_zone_name,\n        Target_Temperature_Schedule_Name=target_temperature_yr_schedule.Name,\n        Hot_Water_Supply_Temperature_Schedule_Name=target_temperature_schedule.Name,\n        Cold_Water_Supply_Temperature_Schedule_Name=inlet_temperature_schedule.Name,\n        Sensible_Fraction_Schedule_Name=None,\n        Latent_Fraction_Schedule_Name=None,\n    )\n    idf = hot_water.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneHotWater.validate_supply_greater_than_inlet","title":"<code>validate_supply_greater_than_inlet(values)</code>","text":"<p>Validate that the supply temperature is greater than the inlet temperature.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>@model_validator(mode=\"before\")\ndef validate_supply_greater_than_inlet(cls, values: dict[str, Any]):\n    \"\"\"Validate that the supply temperature is greater than the inlet temperature.\"\"\"\n    if values[\"WaterSupplyTemperature\"] &lt;= values[\"WaterTemperatureInlet\"]:\n        msg = \"Water supply temperature must be greater than the inlet temperature.\"\n        raise ValueError(msg)\n    return values\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneInfiltration","title":"<code>ZoneInfiltration</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone infiltration object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ZoneInfiltration(\n    NamedObject, ClimateStudioMetadata, extra=\"forbid\", populate_by_name=True\n):\n    \"\"\"Zone infiltration object.\"\"\"\n\n    InfiltrationIsOn: BoolStr = Field(..., title=\"Infiltration is on\")\n    InfiltrationConstantCoefficient: float = Field(\n        ...,\n        title=\"Infiltration constant coefficient\",\n    )\n    InfiltrationTemperatureCoefficient: float = Field(\n        ...,\n        title=\"Infiltration temperature coefficient\",\n    )\n    InfiltrationWindVelocityCoefficient: float = Field(\n        ...,\n        title=\"Infiltration wind velocity coefficient\",\n    )\n    InfiltrationWindVelocitySquaredCoefficient: float = Field(\n        ...,\n        title=\"Infiltration wind velocity squared coefficient\",\n    )\n    AFN_AirMassFlowCoefficient_Crack: float = Field(\n        ...,\n        title=\"AFN air mass flow coefficient crack\",\n    )\n\n    InfiltrationAch: float = Field(\n        ...,\n        title=\"Infiltration air changes per hour\",\n        ge=0,\n        validation_alias=\"InfiltrationAch [ACH]\",\n    )\n    InfiltrationFlowPerExteriorSurfaceArea: float = Field(\n        ...,\n        title=\"Infiltration flow per exterior surface area\",\n        ge=0,\n        validation_alias=\"InfiltrationFlowPerExteriorSurfaceArea [m3/s/m2]\",\n    )\n    CalculationMethod: InfDesignFlowRateCalculationMethodType = Field(\n        ...,\n        title=\"Calculation method\",\n    )\n\n    def add_infiltration_to_idf_zone(\n        self, idf: IDF, target_zone_or_zone_list_name: str\n    ):\n        \"\"\"Add infiltration to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the infiltration to.\n            target_zone_or_zone_list_name (str): The name of the zone or zone list to add the infiltration to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        if not self.InfiltrationIsOn:\n            return idf\n\n        infiltration_schedule_name = (\n            f\"{target_zone_or_zone_list_name}_{self.Name}_Infiltration_Schedule\"\n        )\n        schedule = Schedule.constant_schedule(\n            value=1, Name=infiltration_schedule_name, Type=\"Fraction\"\n        )\n        inf_schedule, *_ = schedule.to_year_week_day()\n        inf_schedule.to_epbunch(idf)\n        inf = ZoneInfiltrationDesignFlowRate(\n            Name=f\"{target_zone_or_zone_list_name}_{self.Name}_Infiltration\",\n            Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n            Schedule_Name=inf_schedule.Name,\n            Design_Flow_Rate_Calculation_Method=self.CalculationMethod,\n            Flow_Rate_per_Exterior_Surface_Area=self.InfiltrationFlowPerExteriorSurfaceArea,\n            Air_Changes_per_Hour=self.InfiltrationAch,\n            Flow_Rate_per_Floor_Area=None,\n            Design_Flow_Rate=None,\n            Constant_Term_Coefficient=self.InfiltrationConstantCoefficient,\n            Temperature_Term_Coefficient=self.InfiltrationTemperatureCoefficient,\n            Velocity_Term_Coefficient=self.InfiltrationWindVelocityCoefficient,\n            Velocity_Squared_Term_Coefficient=self.InfiltrationWindVelocitySquaredCoefficient,\n        )\n        idf = inf.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneInfiltration.add_infiltration_to_idf_zone","title":"<code>add_infiltration_to_idf_zone(idf, target_zone_or_zone_list_name)</code>","text":"<p>Add infiltration to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the infiltration to.</p> required <code>target_zone_or_zone_list_name</code> <code>str</code> <p>The name of the zone or zone list to add the infiltration to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_infiltration_to_idf_zone(\n    self, idf: IDF, target_zone_or_zone_list_name: str\n):\n    \"\"\"Add infiltration to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the infiltration to.\n        target_zone_or_zone_list_name (str): The name of the zone or zone list to add the infiltration to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    if not self.InfiltrationIsOn:\n        return idf\n\n    infiltration_schedule_name = (\n        f\"{target_zone_or_zone_list_name}_{self.Name}_Infiltration_Schedule\"\n    )\n    schedule = Schedule.constant_schedule(\n        value=1, Name=infiltration_schedule_name, Type=\"Fraction\"\n    )\n    inf_schedule, *_ = schedule.to_year_week_day()\n    inf_schedule.to_epbunch(idf)\n    inf = ZoneInfiltrationDesignFlowRate(\n        Name=f\"{target_zone_or_zone_list_name}_{self.Name}_Infiltration\",\n        Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n        Schedule_Name=inf_schedule.Name,\n        Design_Flow_Rate_Calculation_Method=self.CalculationMethod,\n        Flow_Rate_per_Exterior_Surface_Area=self.InfiltrationFlowPerExteriorSurfaceArea,\n        Air_Changes_per_Hour=self.InfiltrationAch,\n        Flow_Rate_per_Floor_Area=None,\n        Design_Flow_Rate=None,\n        Constant_Term_Coefficient=self.InfiltrationConstantCoefficient,\n        Temperature_Term_Coefficient=self.InfiltrationTemperatureCoefficient,\n        Velocity_Term_Coefficient=self.InfiltrationWindVelocityCoefficient,\n        Velocity_Squared_Term_Coefficient=self.InfiltrationWindVelocitySquaredCoefficient,\n    )\n    idf = inf.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneLoad","title":"<code>ZoneLoad</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone load object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ZoneLoad(\n    NamedObject, ClimateStudioMetadata, extra=\"forbid\", populate_by_name=True\n):\n    \"\"\"Zone load object.\"\"\"\n\n    BuildingType: str | int = Field(..., title=\"Building type\")\n    PeopleDensity: float = Field(\n        ...,\n        title=\"People density [people/m\u00b2]\",\n        ge=0,\n        validation_alias=\"PeopleDensity [P/m\u00b2]\",\n    )\n    MetabolicRate: float = Field(\n        ...,\n        title=\"Metabolic rate [met]\",\n        ge=0,\n        validation_alias=\"MetabolicRate [met]\",\n    )\n    AirspeedSchedule: str = Field(\n        ..., title=\"Airspeed schedule\", validation_alias=\"AirspeedSchedule [m/s]\"\n    )\n    EquipmentPowerDensity: float = Field(\n        ...,\n        title=\"Equipment power density [W/m\u00b2]\",\n        ge=0,\n        validation_alias=\"EquipmentPowerDensity [W/m\u00b2]\",\n    )\n    LightingPowerDensity: float = Field(\n        ...,\n        title=\"Lighting power density [W/m\u00b2]\",\n        ge=0,\n        validation_alias=\"LightingPowerDensity [W/m\u00b2]\",\n    )\n    IlluminanceTarget: float = Field(\n        ...,\n        title=\"Illuminance target [lux]\",\n        ge=0,\n        validation_alias=\"IlluminanceTarget [Lux]\",\n    )\n    OccupancySchedule: str = Field(..., title=\"Occupancy schedule\")\n    EquipmentAvailabilitySchedule: str = Field(\n        ...,\n        title=\"Equipment availability schedule\",\n        validation_alias=\"EquipmentAvailibilitySchedule\",  # known typo in cs\n    )\n    LightsAvailabilitySchedule: str = Field(\n        ...,\n        title=\"Lighting availability schedule\",\n        validation_alias=\"LightsAvailibilitySchedule\",  # known typo in cs\n    )\n    DimmingType: DimmingTypeType = Field(\n        ...,\n        title=\"Dimming type\",\n    )\n    PeopleIsOn: BoolStr = Field(..., title=\"People are on\")\n    EquipmentIsOn: BoolStr = Field(..., title=\"Equipment is on\")\n    LightsIsOn: BoolStr = Field(..., title=\"Lights are on\")\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        return {\n            # self.AirspeedSchedule,\n            self.OccupancySchedule,\n            self.EquipmentAvailabilitySchedule,\n            self.LightsAvailabilitySchedule,\n        }\n\n    @property\n    def MetabolicRate_W(self):\n        \"\"\"Get the metabolic rate in Watts.\"\"\"\n        avg_human_weight_kg = 80\n        conversion_factor = 1.162  # W/kg\n        return self.MetabolicRate * avg_human_weight_kg * conversion_factor\n\n    def add_lights_to_idf_zone(\n        self, idf: IDF, target_zone_or_zone_list_name: str\n    ) -&gt; IDF:\n        \"\"\"Add lights to an IDF zone.\n\n        Note that this makes some assumptions about the fraction visible/radiant/replaceable.\n\n        Args:\n            idf (IDF): The IDF object to add the lights to.\n            target_zone_or_zone_list_name (str): The name of the zone or zone list to add the lights to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if not self.LightsIsOn:\n            return idf\n\n        if self.DimmingType != \"Off\":\n            raise NotImplementedClimateStudioParameter(\n                \"DimmingType:On\", self.Name, \"Lights\"\n            )\n\n        logger.warning(\n            f\"Adding lights to zone with schedule {self.LightsAvailabilitySchedule}.  Make sure this schedule exists.\"\n        )\n\n        logger.warning(\n            f\"Ignoring IlluminanceTarget for zone(s) {target_zone_or_zone_list_name}.\"\n        )\n        lights = Lights(\n            Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_Lights\",\n            Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n            Schedule_Name=self.LightsAvailabilitySchedule,\n            Design_Level_Calculation_Method=\"Watts/Area\",\n            Watts_per_Zone_Floor_Area=self.LightingPowerDensity,\n            Watts_per_Person=None,\n            Lighting_Level=None,\n            Return_Air_Fraction=0,\n            Fraction_Radiant=0.42,\n            Fraction_Visible=0.18,\n            Fraction_Replaceable=1,\n            EndUse_Subcategory=None,\n        )\n        idf = lights.add(idf)\n        return idf\n\n    def add_people_to_idf_zone(\n        self, idf: IDF, target_zone_or_zone_list_name: str\n    ) -&gt; IDF:\n        \"\"\"Add people to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the people to.\n            target_zone_or_zone_list_name (str): The name of the zone or zone list to add the people to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if not self.PeopleIsOn:\n            return idf\n\n        activity_sch_name = (\n            f\"{target_zone_or_zone_list_name}_{self.Name}_Activity_Schedule\"\n        )\n        lim = \"AnyNumber\"\n        if not idf.getobject(\"SCHEDULETYPELIMITS\", lim):\n            lim = ScheduleTypeLimits(\n                Name=\"AnyNumber\",\n                LowerLimit=None,\n                UpperLimit=None,\n            )\n            lim.to_epbunch(idf)\n        activity_sch = Schedule.from_values(\n            Values=[self.MetabolicRate_W] * 8760,\n            Name=activity_sch_name,\n            Type=lim,  # pyright: ignore [reportArgumentType]\n        )\n        activity_sch_year, *_ = activity_sch.to_year_week_day()\n        activity_sch_year.to_epbunch(idf)\n\n        logger.warning(\n            f\"Adding people to zone with schedule {self.OccupancySchedule}.  Make sure this schedule exists.\"\n        )\n        logger.warning(\n            f\"Ignoring AirspeedSchedule for zone(s) {target_zone_or_zone_list_name}.\"\n        )\n        people = People(\n            Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_People\",\n            Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n            Number_of_People_Schedule_Name=self.OccupancySchedule,\n            Number_of_People_Calculation_Method=\"People/Area\",\n            Number_of_People=None,\n            Floor_Area_per_Person=None,\n            People_per_Floor_Area=self.PeopleDensity,\n            Fraction_Radiant=0.3,\n            Sensible_Heat_Fraction=\"autocalculate\",\n            Activity_Level_Schedule_Name=activity_sch_year.Name,\n        )\n\n        idf = people.add(idf)\n        return idf\n\n    def add_equipment_to_idf_zone(\n        self, idf: IDF, target_zone_or_zone_list_name: str\n    ) -&gt; IDF:\n        \"\"\"Add equipment to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the equipment to.\n            target_zone_or_zone_list_name (str): The name of the zone or zone list to add the equipment to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if not self.EquipmentIsOn:\n            return idf\n\n        logger.warning(\n            f\"Adding equipment to zone with schedule {self.EquipmentAvailabilitySchedule}.  Make sure this schedule exists.\"\n        )\n\n        equipment = ElectricEquipment(\n            Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_Equipment\",\n            Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n            Schedule_Name=self.EquipmentAvailabilitySchedule,\n            Design_Level_Calculation_Method=\"Watts/Area\",\n            Watts_per_Zone_Floor_Area=self.EquipmentPowerDensity,\n            Watts_per_Person=None,\n            Fraction_Latent=0,\n            Fraction_Radiant=0.2,\n            Fraction_Lost=0,\n            EndUse_Subcategory=None,\n        )\n        idf = equipment.add(idf)\n        return idf\n\n    def add_loads_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n        \"\"\"Add the loads to an IDF zone.\n\n        This will add the people, equipment, and lights to the zone.\n\n        nb: remember to add the schedules.\n\n        Args:\n            idf (IDF): The IDF object to add the loads to.\n            target_zone_name (str): The name of the zone to add the loads to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        idf = self.add_lights_to_idf_zone(idf, target_zone_name)\n        idf = self.add_people_to_idf_zone(idf, target_zone_name)\n        idf = self.add_equipment_to_idf_zone(idf, target_zone_name)\n        return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneLoad.MetabolicRate_W","title":"<code>MetabolicRate_W</code>  <code>property</code>","text":"<p>Get the metabolic rate in Watts.</p>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneLoad.schedule_names","title":"<code>schedule_names: set[str]</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneLoad.add_equipment_to_idf_zone","title":"<code>add_equipment_to_idf_zone(idf, target_zone_or_zone_list_name)</code>","text":"<p>Add equipment to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the equipment to.</p> required <code>target_zone_or_zone_list_name</code> <code>str</code> <p>The name of the zone or zone list to add the equipment to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_equipment_to_idf_zone(\n    self, idf: IDF, target_zone_or_zone_list_name: str\n) -&gt; IDF:\n    \"\"\"Add equipment to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the equipment to.\n        target_zone_or_zone_list_name (str): The name of the zone or zone list to add the equipment to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if not self.EquipmentIsOn:\n        return idf\n\n    logger.warning(\n        f\"Adding equipment to zone with schedule {self.EquipmentAvailabilitySchedule}.  Make sure this schedule exists.\"\n    )\n\n    equipment = ElectricEquipment(\n        Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_Equipment\",\n        Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n        Schedule_Name=self.EquipmentAvailabilitySchedule,\n        Design_Level_Calculation_Method=\"Watts/Area\",\n        Watts_per_Zone_Floor_Area=self.EquipmentPowerDensity,\n        Watts_per_Person=None,\n        Fraction_Latent=0,\n        Fraction_Radiant=0.2,\n        Fraction_Lost=0,\n        EndUse_Subcategory=None,\n    )\n    idf = equipment.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneLoad.add_lights_to_idf_zone","title":"<code>add_lights_to_idf_zone(idf, target_zone_or_zone_list_name)</code>","text":"<p>Add lights to an IDF zone.</p> <p>Note that this makes some assumptions about the fraction visible/radiant/replaceable.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the lights to.</p> required <code>target_zone_or_zone_list_name</code> <code>str</code> <p>The name of the zone or zone list to add the lights to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_lights_to_idf_zone(\n    self, idf: IDF, target_zone_or_zone_list_name: str\n) -&gt; IDF:\n    \"\"\"Add lights to an IDF zone.\n\n    Note that this makes some assumptions about the fraction visible/radiant/replaceable.\n\n    Args:\n        idf (IDF): The IDF object to add the lights to.\n        target_zone_or_zone_list_name (str): The name of the zone or zone list to add the lights to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if not self.LightsIsOn:\n        return idf\n\n    if self.DimmingType != \"Off\":\n        raise NotImplementedClimateStudioParameter(\n            \"DimmingType:On\", self.Name, \"Lights\"\n        )\n\n    logger.warning(\n        f\"Adding lights to zone with schedule {self.LightsAvailabilitySchedule}.  Make sure this schedule exists.\"\n    )\n\n    logger.warning(\n        f\"Ignoring IlluminanceTarget for zone(s) {target_zone_or_zone_list_name}.\"\n    )\n    lights = Lights(\n        Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_Lights\",\n        Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n        Schedule_Name=self.LightsAvailabilitySchedule,\n        Design_Level_Calculation_Method=\"Watts/Area\",\n        Watts_per_Zone_Floor_Area=self.LightingPowerDensity,\n        Watts_per_Person=None,\n        Lighting_Level=None,\n        Return_Air_Fraction=0,\n        Fraction_Radiant=0.42,\n        Fraction_Visible=0.18,\n        Fraction_Replaceable=1,\n        EndUse_Subcategory=None,\n    )\n    idf = lights.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneLoad.add_loads_to_idf_zone","title":"<code>add_loads_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Add the loads to an IDF zone.</p> <p>This will add the people, equipment, and lights to the zone.</p> <p>nb: remember to add the schedules.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the loads to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the loads to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_loads_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n    \"\"\"Add the loads to an IDF zone.\n\n    This will add the people, equipment, and lights to the zone.\n\n    nb: remember to add the schedules.\n\n    Args:\n        idf (IDF): The IDF object to add the loads to.\n        target_zone_name (str): The name of the zone to add the loads to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    idf = self.add_lights_to_idf_zone(idf, target_zone_name)\n    idf = self.add_people_to_idf_zone(idf, target_zone_name)\n    idf = self.add_equipment_to_idf_zone(idf, target_zone_name)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneLoad.add_people_to_idf_zone","title":"<code>add_people_to_idf_zone(idf, target_zone_or_zone_list_name)</code>","text":"<p>Add people to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the people to.</p> required <code>target_zone_or_zone_list_name</code> <code>str</code> <p>The name of the zone or zone list to add the people to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_people_to_idf_zone(\n    self, idf: IDF, target_zone_or_zone_list_name: str\n) -&gt; IDF:\n    \"\"\"Add people to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the people to.\n        target_zone_or_zone_list_name (str): The name of the zone or zone list to add the people to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if not self.PeopleIsOn:\n        return idf\n\n    activity_sch_name = (\n        f\"{target_zone_or_zone_list_name}_{self.Name}_Activity_Schedule\"\n    )\n    lim = \"AnyNumber\"\n    if not idf.getobject(\"SCHEDULETYPELIMITS\", lim):\n        lim = ScheduleTypeLimits(\n            Name=\"AnyNumber\",\n            LowerLimit=None,\n            UpperLimit=None,\n        )\n        lim.to_epbunch(idf)\n    activity_sch = Schedule.from_values(\n        Values=[self.MetabolicRate_W] * 8760,\n        Name=activity_sch_name,\n        Type=lim,  # pyright: ignore [reportArgumentType]\n    )\n    activity_sch_year, *_ = activity_sch.to_year_week_day()\n    activity_sch_year.to_epbunch(idf)\n\n    logger.warning(\n        f\"Adding people to zone with schedule {self.OccupancySchedule}.  Make sure this schedule exists.\"\n    )\n    logger.warning(\n        f\"Ignoring AirspeedSchedule for zone(s) {target_zone_or_zone_list_name}.\"\n    )\n    people = People(\n        Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_People\",\n        Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n        Number_of_People_Schedule_Name=self.OccupancySchedule,\n        Number_of_People_Calculation_Method=\"People/Area\",\n        Number_of_People=None,\n        Floor_Area_per_Person=None,\n        People_per_Floor_Area=self.PeopleDensity,\n        Fraction_Radiant=0.3,\n        Sensible_Heat_Fraction=\"autocalculate\",\n        Activity_Level_Schedule_Name=activity_sch_year.Name,\n    )\n\n    idf = people.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneUse","title":"<code>ZoneUse</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone use object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>class ZoneUse(\n    NamedObject, ClimateStudioMetadata, extra=\"forbid\", populate_by_name=True\n):\n    \"\"\"Zone use object.\"\"\"\n\n    Conditioning: ZoneConditioning\n    Loads: ZoneLoad\n    HotWater: ZoneHotWater\n\n    def add_loads_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n        \"\"\"Add the loads to an IDF zone.\n\n        This will add the people, equipment, and lights to the zone.\n\n        nb: remember to add the schedules.\n\n        Args:\n            idf (IDF): The IDF object to add the loads to.\n            target_zone_name (str): The name of the zone to add the loads to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        idf = self.Loads.add_loads_to_idf_zone(idf, target_zone_name)\n        return idf\n\n    def add_conditioning_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n        \"\"\"Add the conditioning to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the conditioning to.\n            target_zone_name (str): The name of the zone to add the conditioning to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        idf = self.Conditioning.add_conditioning_to_idf_zone(idf, target_zone_name)\n        return idf\n\n    def add_hot_water_to_idf_zone(\n        self, idf: IDF, target_zone_name: str, zone_area: float\n    ) -&gt; IDF:\n        \"\"\"Add the hot water to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the hot water to.\n            target_zone_name (str): The name of the zone to add the hot water to.\n            zone_area (float): The area of the zone.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n\n        \"\"\"\n        total_people = self.Loads.PeopleDensity * zone_area\n        idf = self.HotWater.add_water_to_idf_zone(\n            idf, target_zone_name, total_ppl=total_people\n        )\n        return idf\n\n    def add_space_use_to_idf_zone(self, idf: IDF, target_zone: str | ZoneList) -&gt; IDF:\n        \"\"\"Add the use to an IDF zone.\n\n        This will add the loads and conditioning to the zone.\n\n        Args:\n            idf (IDF): The IDF object to add the use to.\n            target_zone (str | ZoneList): The name of the zone to add the use to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        loads_target = target_zone if isinstance(target_zone, str) else target_zone.Name\n        idf = self.add_loads_to_idf_zone(idf, loads_target)\n        if isinstance(target_zone, str):\n            idf = self.add_conditioning_to_idf_zone(idf, target_zone)\n        else:\n            for zone in target_zone.Names:\n                idf = self.add_conditioning_to_idf_zone(idf, zone)\n        return idf\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        return (\n            self.Loads.schedule_names\n            | self.Conditioning.schedule_names\n            | self.HotWater.schedule_names\n        )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneUse.schedule_names","title":"<code>schedule_names: set[str]</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneUse.add_conditioning_to_idf_zone","title":"<code>add_conditioning_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Add the conditioning to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the conditioning to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the conditioning to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_conditioning_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n    \"\"\"Add the conditioning to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the conditioning to.\n        target_zone_name (str): The name of the zone to add the conditioning to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    idf = self.Conditioning.add_conditioning_to_idf_zone(idf, target_zone_name)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneUse.add_hot_water_to_idf_zone","title":"<code>add_hot_water_to_idf_zone(idf, target_zone_name, zone_area)</code>","text":"<p>Add the hot water to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the hot water to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the hot water to.</p> required <code>zone_area</code> <code>float</code> <p>The area of the zone.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_hot_water_to_idf_zone(\n    self, idf: IDF, target_zone_name: str, zone_area: float\n) -&gt; IDF:\n    \"\"\"Add the hot water to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the hot water to.\n        target_zone_name (str): The name of the zone to add the hot water to.\n        zone_area (float): The area of the zone.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n\n    \"\"\"\n    total_people = self.Loads.PeopleDensity * zone_area\n    idf = self.HotWater.add_water_to_idf_zone(\n        idf, target_zone_name, total_ppl=total_people\n    )\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneUse.add_loads_to_idf_zone","title":"<code>add_loads_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Add the loads to an IDF zone.</p> <p>This will add the people, equipment, and lights to the zone.</p> <p>nb: remember to add the schedules.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the loads to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the loads to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_loads_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n    \"\"\"Add the loads to an IDF zone.\n\n    This will add the people, equipment, and lights to the zone.\n\n    nb: remember to add the schedules.\n\n    Args:\n        idf (IDF): The IDF object to add the loads to.\n        target_zone_name (str): The name of the zone to add the loads to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    idf = self.Loads.add_loads_to_idf_zone(idf, target_zone_name)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneUse.add_space_use_to_idf_zone","title":"<code>add_space_use_to_idf_zone(idf, target_zone)</code>","text":"<p>Add the use to an IDF zone.</p> <p>This will add the loads and conditioning to the zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the use to.</p> required <code>target_zone</code> <code>str | ZoneList</code> <p>The name of the zone to add the use to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def add_space_use_to_idf_zone(self, idf: IDF, target_zone: str | ZoneList) -&gt; IDF:\n    \"\"\"Add the use to an IDF zone.\n\n    This will add the loads and conditioning to the zone.\n\n    Args:\n        idf (IDF): The IDF object to add the use to.\n        target_zone (str | ZoneList): The name of the zone to add the use to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    loads_target = target_zone if isinstance(target_zone, str) else target_zone.Name\n    idf = self.add_loads_to_idf_zone(idf, loads_target)\n    if isinstance(target_zone, str):\n        idf = self.add_conditioning_to_idf_zone(idf, target_zone)\n    else:\n        for zone in target_zone.Names:\n            idf = self.add_conditioning_to_idf_zone(idf, zone)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.extract_sch","title":"<code>extract_sch(year_schedules, schedule_name)</code>","text":"<p>Extract a schedule from a climate studio schedule dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>year_schedules</code> <code>DataFrame</code> <p>Dataframe of year schedules</p> required <code>schedule_name</code> <code>str</code> <p>Name of the schedule</p> required <p>Returns:</p> Name Type Description <code>Schedule</code> <code>Schedule</code> <p>Extracted schedule</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def extract_sch(year_schedules: pd.DataFrame, schedule_name: str) -&gt; Schedule:\n    \"\"\"Extract a schedule from a climate studio schedule dataframe.\n\n    Args:\n        year_schedules (pd.DataFrame): Dataframe of year schedules\n        schedule_name (str): Name of the schedule\n\n    Returns:\n        Schedule: Extracted schedule\n    \"\"\"\n    sched_meta = year_schedules.head(5)\n    sched_meta.index = pd.Index([\n        \"Type\",\n        \"Periodicity\",\n        \"Category\",\n        \"Data Source\",\n        \"Comment\",\n    ])\n    meta = sched_meta[schedule_name]\n    sched_type = cast(str, meta[\"Type\"])\n    last_ix = (\n        8760\n        if meta[\"Periodicity\"] == \"FullYear\"\n        else (\n            24 * 7\n            if meta[\"Periodicity\"] == \"RepeatingWeek\"\n            else (24 if meta[\"Periodicity\"] == \"RepeatingDay\" else 1)\n        )\n    )\n    sched = year_schedules[schedule_name]\n    sched_vals = sched.iloc[5:]\n    sched_vals = np.array(sched_vals[:last_ix].astype(float).values)\n    if len(sched_vals) not in [1, 24, 24 * 7, 8760]:\n        raise ScheduleParseError(schedule_name)\n    if sched_type.lower() not in [\n        \"fraction\",\n        \"temperature\",\n        \"any number\",\n        \"anynumber\",\n        \"on/off\",\n    ]:\n        raise ScheduleParseError(f\"{schedule_name}:{meta['Type']}\")\n    if sched_type.lower() in [\"any number\", \"anynumber\"]:\n        meta[\"Type\"] = ScheduleTypeLimits(\n            Name=meta[\"Type\"], LowerLimit=None, UpperLimit=None\n        )\n    n_repeats_needed = 8760 // len(sched_vals) + 1\n    repeated_schedule = np.tile(sched_vals, n_repeats_needed)[:8760]\n    sched = Schedule.from_values(\n        Name=schedule_name,\n        Values=repeated_schedule.tolist(),\n        Type=meta[\"Type\"],  # pyright: ignore [reportArgumentType]\n    )\n    return sched\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.nan_to_none_or_str","title":"<code>nan_to_none_or_str(v)</code>","text":"<p>Converts NaN to None and leaves strings as is.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Any</code> <p>Value to convert</p> required <p>Returns:</p> Name Type Description <code>v</code> <code>None | str | Any</code> <p>Converted value</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def nan_to_none_or_str(v: Any) -&gt; str | None | Any:\n    \"\"\"Converts NaN to None and leaves strings as is.\n\n    Args:\n        v (Any): Value to convert\n\n    Returns:\n        v (None | str | Any): Converted value\n    \"\"\"\n    if isinstance(v, str):\n        return v\n    if v is None:\n        return None\n    if np.isnan(v):\n        return None\n    return v\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.str_to_bool","title":"<code>str_to_bool(v)</code>","text":"<p>Converts a string to a boolean if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str | bool</code> <p>Value to convert</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Converted value</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def str_to_bool(v: str | bool) -&gt; bool:\n    \"\"\"Converts a string to a boolean if necessary.\n\n    Args:\n        v (str | bool): Value to convert\n\n    Returns:\n        bool: Converted value\n    \"\"\"\n    if isinstance(v, bool):\n        return v\n    elif v.lower() == \"true\":\n        return True\n    elif v.lower() == \"false\":\n        return False\n    else:\n        return False\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.str_to_float_list","title":"<code>str_to_float_list(v)</code>","text":"<p>Converts a string to a list of floats.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>String to convert</p> required <p>Returns:</p> Name Type Description <code>vals</code> <code>list[float]</code> <p>List of floats</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def str_to_float_list(v: str | list):\n    \"\"\"Converts a string to a list of floats.\n\n    Args:\n        v (str): String to convert\n\n    Returns:\n        vals (list[float]): List of floats\n    \"\"\"\n    if v == \"[]\":\n        return []\n    if isinstance(v, str):\n        # re should be used to parse the string -\n        # check that it starts with \"[\"  and ends with \"]\"\n        # and the elements are separated by \", \"\n        # and the elements are all ints or floats\n\n        if not re.match(r\"^\\[.*\\]$\", v):\n            raise ValueError(f\"STRING:NOT_LIST:{v}\")\n        v = v[1:-1]\n        if not re.match(r\"^[\\-0-9\\., ]*$\", v):\n            raise ValueError(f\"STRING:NOT_LIST:{v}\")\n        v = v.replace(\" \", \"\").split(\",\")\n    return [float(x) for x in v]\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.str_to_opaque_layer_list","title":"<code>str_to_opaque_layer_list(v)</code>","text":"<p>Converts a string to a list of opaque construction layers.</p> Source code in <code>epinterface\\climate_studio\\interface.py</code> <pre><code>def str_to_opaque_layer_list(v: str | list):\n    \"\"\"Converts a string to a list of opaque construction layers.\"\"\"\n    if isinstance(v, list):\n        return v\n    if v == \"[]\":\n        return []\n    list_content = v[1:-1].split(\", \")\n    names = list_content[::2]\n    thicknesses = list(map(float, list_content[1::2]))\n    return [\n        OpaqueConstructionLayer(Name=name, Thickness=thickness)\n        for name, thickness in zip(names, thicknesses, strict=False)\n    ]\n</code></pre>"},{"location":"modules/geometry/","title":"Geometry","text":"<p>This contains some utilities for adding geometry to an IDF.</p> <p>Geometry utilities for the UBEM construction.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry","title":"<code>ShoeboxGeometry</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A simple shoebox constructor for the IDF model.</p> <p>Can create gables, basements, and various zoning strategies.</p> Source code in <code>epinterface\\geometry.py</code> <pre><code>class ShoeboxGeometry(BaseModel):\n    \"\"\"A simple shoebox constructor for the IDF model.\n\n    Can create gables, basements, and various zoning strategies.\n    \"\"\"\n\n    x: float\n    y: float\n    w: float\n    d: float\n    h: float\n    num_stories: int = Field(\n        ...,\n        title=\"Number of stories\",\n        ge=1,\n        description=\"The number of stories in the building.\",\n    )\n    zoning: ZoningType = Field(\n        ...,\n        title=\"Zoning type\",\n        description=\"Whether to use core/perim or full-floor zones.\",\n    )\n    perim_depth: float = Field(\n        default=3,\n        title=\"Perimeter depth\",\n        description=\"Sets the perimeter depth when using core/perim zoning.  Ignored otherwise.\",\n    )\n    roof_height: float | None = Field(\n        default=None,\n        title=\"Roof gable height\",\n        description=\"The height of the roof gable.  If None, a flat roof is assumed.\",\n    )\n    basement: bool = Field(\n        default=False,\n        title=\"Basement\",\n        description=\"Whether or not to use a basement with same f2f height as building.\",\n    )\n    wwr: float = Field(\n        default=0.15,\n        title=\"Window-to-wall ratio\",\n        description=\"The window-to-wall ratio of the building.\",\n        ge=0,\n        le=1,\n    )\n\n    @property\n    def basement_storey_count(self) -&gt; int:\n        \"\"\"Return the number of basement stories.\"\"\"\n        return 1 if self.basement else 0\n\n    @property\n    def zones_height(self) -&gt; float:\n        \"\"\"Return the total height of the zones, excluding any gabling.\"\"\"\n        return self.h * (self.num_stories)\n\n    @property\n    def total_height_with_gabling(self) -&gt; float:\n        \"\"\"Return the total height of the building, including any gabling.\"\"\"\n        return self.zones_height + (self.roof_height or 0)\n\n    @property\n    def footprint_area(self) -&gt; float:\n        \"\"\"Return the total floor area of the building.\"\"\"\n        return self.w * self.d\n\n    @property\n    def total_living_area(self) -&gt; float:\n        \"\"\"Return the total living area of the building.\"\"\"\n        return self.footprint_area * self.num_stories\n\n    @property\n    def total_area(self) -&gt; float:\n        \"\"\"Return the total area of the building.\"\"\"\n        return (\n            self.total_living_area\n            + self.footprint_area * self.basement_storey_count\n            + self.footprint_area * (1 if self.roof_height else 0)\n        )\n\n    @property\n    def basement_suffix(self) -&gt; str:\n        \"\"\"Return the basement suffix for the building.\"\"\"\n        if not self.basement:\n            msg = \"Building has no basement.\"\n            raise ValueError(msg)\n        return \"Storey 0\" if self.zoning == \"core/perim\" else \"Storey -1\"\n\n    def add(self, idf: IDF) -&gt; IDF:\n        \"\"\"Constructs a simple shoebox geometry in the IDF model.\n\n        Takes advantage of the geomeppy methods to do so.\n\n        Can create gables, basements, and various zoning strategies.\n\n        Args:\n            idf: The IDF model to add the geometry to.\n\n        Returns:\n            The IDF model with the added geometry.\n        \"\"\"\n        lower_left_corner = (self.x, self.y)\n        lower_right_corner = (self.x + self.w, self.y)\n        upper_right_corner = (self.x + self.w, self.y + self.d)\n        upper_left_corner = (self.x, self.y + self.d)\n        bottom_plane = [\n            lower_left_corner,\n            lower_right_corner,\n            upper_right_corner,\n            upper_left_corner,\n        ]\n        idf.add_block(\n            name=\"shoebox\",\n            coordinates=bottom_plane,\n            height=self.zones_height\n            + (self.h if self.basement and self.zoning == \"core/perim\" else 0),\n            num_stories=self.num_stories + self.basement_storey_count,\n            zoning=self.zoning,\n            perim_depth=self.perim_depth,\n            below_ground_stories=self.basement_storey_count,\n            below_ground_storey_height=self.h,\n        )\n        if self.basement and self.zoning == \"core/perim\":\n            idf.translate((0, 0, -self.h))\n\n        if self.roof_height:\n            for srf in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]:\n                if srf.Surface_Type.lower() == \"roof\":\n                    srf.Surface_Type = \"ceiling\"\n            idf.newidfobject(\"ZONE\", Name=\"Attic\")\n            roof_centerline = self.x + self.w / 2\n            vert_0 = (self.x, self.y + self.d, self.zones_height)\n            vert_1 = (self.x, self.y, self.zones_height)\n            vert_2 = (roof_centerline, self.y, self.total_height_with_gabling)\n            vert_3 = (roof_centerline, self.y + self.d, self.total_height_with_gabling)\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"Gable1\",\n                Surface_Type=\"Roof\",\n                Number_of_Vertices=4,\n                View_Factor_to_Ground=0,\n                Vertex_1_Xcoordinate=vert_0[0],\n                Vertex_1_Ycoordinate=vert_0[1],\n                Vertex_1_Zcoordinate=vert_0[2],\n                Vertex_2_Xcoordinate=vert_1[0],\n                Vertex_2_Ycoordinate=vert_1[1],\n                Vertex_2_Zcoordinate=vert_1[2],\n                Vertex_3_Xcoordinate=vert_2[0],\n                Vertex_3_Ycoordinate=vert_2[1],\n                Vertex_3_Zcoordinate=vert_2[2],\n                Vertex_4_Xcoordinate=vert_3[0],\n                Vertex_4_Ycoordinate=vert_3[1],\n                Vertex_4_Zcoordinate=vert_3[2],\n                Zone_Name=\"Attic\",\n            )\n\n            vert_0 = (self.x + self.w, self.y, self.zones_height)\n            vert_1 = (self.x + self.w, self.y + self.d, self.zones_height)\n            vert_2 = (roof_centerline, self.y + self.d, self.total_height_with_gabling)\n            vert_3 = (roof_centerline, self.y, self.total_height_with_gabling)\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"Gable2\",\n                Surface_Type=\"Roof\",\n                Number_of_Vertices=4,\n                View_Factor_to_Ground=0,\n                Vertex_1_Xcoordinate=vert_0[0],\n                Vertex_1_Ycoordinate=vert_0[1],\n                Vertex_1_Zcoordinate=vert_0[2],\n                Vertex_2_Xcoordinate=vert_1[0],\n                Vertex_2_Ycoordinate=vert_1[1],\n                Vertex_2_Zcoordinate=vert_1[2],\n                Vertex_3_Xcoordinate=vert_2[0],\n                Vertex_3_Ycoordinate=vert_2[1],\n                Vertex_3_Zcoordinate=vert_2[2],\n                Vertex_4_Xcoordinate=vert_3[0],\n                Vertex_4_Ycoordinate=vert_3[1],\n                Vertex_4_Zcoordinate=vert_3[2],\n                Zone_Name=\"Attic\",\n            )\n\n            # make triangular endcaps\n            vert_0 = (self.x, self.y, self.zones_height)\n            vert_1 = (self.x + self.w, self.y, self.zones_height)\n            vert_2 = (roof_centerline, self.y, self.total_height_with_gabling)\n\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"Endcap1\",\n                Surface_Type=\"Wall\",\n                Number_of_Vertices=3,\n                Vertex_1_Xcoordinate=vert_0[0],\n                Vertex_1_Ycoordinate=vert_0[1],\n                Vertex_1_Zcoordinate=vert_0[2],\n                Vertex_2_Xcoordinate=vert_1[0],\n                Vertex_2_Ycoordinate=vert_1[1],\n                Vertex_2_Zcoordinate=vert_1[2],\n                Vertex_3_Xcoordinate=vert_2[0],\n                Vertex_3_Ycoordinate=vert_2[1],\n                Vertex_3_Zcoordinate=vert_2[2],\n                Zone_Name=\"Attic\",\n            )\n\n            vert_0 = (self.x + self.w, self.y + self.d, self.zones_height)\n            vert_1 = (self.x, self.y + self.d, self.zones_height)\n            vert_2 = (roof_centerline, self.y + self.d, self.total_height_with_gabling)\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"Endcap2\",\n                Surface_Type=\"Wall\",\n                Number_of_Vertices=3,\n                Vertex_1_Xcoordinate=vert_0[0],\n                Vertex_1_Ycoordinate=vert_0[1],\n                Vertex_1_Zcoordinate=vert_0[2],\n                Vertex_2_Xcoordinate=vert_1[0],\n                Vertex_2_Ycoordinate=vert_1[1],\n                Vertex_2_Zcoordinate=vert_1[2],\n                Vertex_3_Xcoordinate=vert_2[0],\n                Vertex_3_Ycoordinate=vert_2[1],\n                Vertex_3_Zcoordinate=vert_2[2],\n                Zone_Name=\"Attic\",\n            )\n\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"attic_bottom_plane\",\n                Surface_Type=\"Floor\",\n                Number_of_Vertices=4,\n                Vertex_1_Xcoordinate=self.x + self.w,\n                Vertex_1_Ycoordinate=self.y,\n                Vertex_1_Zcoordinate=self.zones_height,\n                Vertex_2_Xcoordinate=self.x,\n                Vertex_2_Ycoordinate=self.y,\n                Vertex_2_Zcoordinate=self.zones_height,\n                Vertex_3_Xcoordinate=self.x,\n                Vertex_3_Ycoordinate=self.y + self.d,\n                Vertex_3_Zcoordinate=self.zones_height,\n                Vertex_4_Xcoordinate=self.x + self.w,\n                Vertex_4_Ycoordinate=self.y + self.d,\n                Vertex_4_Zcoordinate=self.zones_height,\n                Zone_Name=\"Attic\",\n            )\n\n        idf.intersect_match()\n\n        idf.set_default_constructions()\n\n        # Handle Windows\n        window_walls = [\n            w\n            for w in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]\n            if w.Outside_Boundary_Condition.lower() == \"outdoors\"\n            and \"attic\" not in w.Zone_Name.lower()\n            and (\n                not w.Zone_Name.lower().endswith(self.basement_suffix.lower())\n                if self.basement\n                else True\n            )\n            and w.Surface_Type.lower() == \"wall\"\n        ]\n        idf.set_wwr(\n            wwr=self.wwr,\n            construction=\"Project External Window\",\n            force=True,\n            surfaces=window_walls,\n        )\n        return idf\n</code></pre>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.basement_storey_count","title":"<code>basement_storey_count: int</code>  <code>property</code>","text":"<p>Return the number of basement stories.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.basement_suffix","title":"<code>basement_suffix: str</code>  <code>property</code>","text":"<p>Return the basement suffix for the building.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.footprint_area","title":"<code>footprint_area: float</code>  <code>property</code>","text":"<p>Return the total floor area of the building.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.total_area","title":"<code>total_area: float</code>  <code>property</code>","text":"<p>Return the total area of the building.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.total_height_with_gabling","title":"<code>total_height_with_gabling: float</code>  <code>property</code>","text":"<p>Return the total height of the building, including any gabling.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.total_living_area","title":"<code>total_living_area: float</code>  <code>property</code>","text":"<p>Return the total living area of the building.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.zones_height","title":"<code>zones_height: float</code>  <code>property</code>","text":"<p>Return the total height of the zones, excluding any gabling.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.add","title":"<code>add(idf)</code>","text":"<p>Constructs a simple shoebox geometry in the IDF model.</p> <p>Takes advantage of the geomeppy methods to do so.</p> <p>Can create gables, basements, and various zoning strategies.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the geometry to.</p> required <p>Returns:</p> Type Description <code>IDF</code> <p>The IDF model with the added geometry.</p> Source code in <code>epinterface\\geometry.py</code> <pre><code>def add(self, idf: IDF) -&gt; IDF:\n    \"\"\"Constructs a simple shoebox geometry in the IDF model.\n\n    Takes advantage of the geomeppy methods to do so.\n\n    Can create gables, basements, and various zoning strategies.\n\n    Args:\n        idf: The IDF model to add the geometry to.\n\n    Returns:\n        The IDF model with the added geometry.\n    \"\"\"\n    lower_left_corner = (self.x, self.y)\n    lower_right_corner = (self.x + self.w, self.y)\n    upper_right_corner = (self.x + self.w, self.y + self.d)\n    upper_left_corner = (self.x, self.y + self.d)\n    bottom_plane = [\n        lower_left_corner,\n        lower_right_corner,\n        upper_right_corner,\n        upper_left_corner,\n    ]\n    idf.add_block(\n        name=\"shoebox\",\n        coordinates=bottom_plane,\n        height=self.zones_height\n        + (self.h if self.basement and self.zoning == \"core/perim\" else 0),\n        num_stories=self.num_stories + self.basement_storey_count,\n        zoning=self.zoning,\n        perim_depth=self.perim_depth,\n        below_ground_stories=self.basement_storey_count,\n        below_ground_storey_height=self.h,\n    )\n    if self.basement and self.zoning == \"core/perim\":\n        idf.translate((0, 0, -self.h))\n\n    if self.roof_height:\n        for srf in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]:\n            if srf.Surface_Type.lower() == \"roof\":\n                srf.Surface_Type = \"ceiling\"\n        idf.newidfobject(\"ZONE\", Name=\"Attic\")\n        roof_centerline = self.x + self.w / 2\n        vert_0 = (self.x, self.y + self.d, self.zones_height)\n        vert_1 = (self.x, self.y, self.zones_height)\n        vert_2 = (roof_centerline, self.y, self.total_height_with_gabling)\n        vert_3 = (roof_centerline, self.y + self.d, self.total_height_with_gabling)\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"Gable1\",\n            Surface_Type=\"Roof\",\n            Number_of_Vertices=4,\n            View_Factor_to_Ground=0,\n            Vertex_1_Xcoordinate=vert_0[0],\n            Vertex_1_Ycoordinate=vert_0[1],\n            Vertex_1_Zcoordinate=vert_0[2],\n            Vertex_2_Xcoordinate=vert_1[0],\n            Vertex_2_Ycoordinate=vert_1[1],\n            Vertex_2_Zcoordinate=vert_1[2],\n            Vertex_3_Xcoordinate=vert_2[0],\n            Vertex_3_Ycoordinate=vert_2[1],\n            Vertex_3_Zcoordinate=vert_2[2],\n            Vertex_4_Xcoordinate=vert_3[0],\n            Vertex_4_Ycoordinate=vert_3[1],\n            Vertex_4_Zcoordinate=vert_3[2],\n            Zone_Name=\"Attic\",\n        )\n\n        vert_0 = (self.x + self.w, self.y, self.zones_height)\n        vert_1 = (self.x + self.w, self.y + self.d, self.zones_height)\n        vert_2 = (roof_centerline, self.y + self.d, self.total_height_with_gabling)\n        vert_3 = (roof_centerline, self.y, self.total_height_with_gabling)\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"Gable2\",\n            Surface_Type=\"Roof\",\n            Number_of_Vertices=4,\n            View_Factor_to_Ground=0,\n            Vertex_1_Xcoordinate=vert_0[0],\n            Vertex_1_Ycoordinate=vert_0[1],\n            Vertex_1_Zcoordinate=vert_0[2],\n            Vertex_2_Xcoordinate=vert_1[0],\n            Vertex_2_Ycoordinate=vert_1[1],\n            Vertex_2_Zcoordinate=vert_1[2],\n            Vertex_3_Xcoordinate=vert_2[0],\n            Vertex_3_Ycoordinate=vert_2[1],\n            Vertex_3_Zcoordinate=vert_2[2],\n            Vertex_4_Xcoordinate=vert_3[0],\n            Vertex_4_Ycoordinate=vert_3[1],\n            Vertex_4_Zcoordinate=vert_3[2],\n            Zone_Name=\"Attic\",\n        )\n\n        # make triangular endcaps\n        vert_0 = (self.x, self.y, self.zones_height)\n        vert_1 = (self.x + self.w, self.y, self.zones_height)\n        vert_2 = (roof_centerline, self.y, self.total_height_with_gabling)\n\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"Endcap1\",\n            Surface_Type=\"Wall\",\n            Number_of_Vertices=3,\n            Vertex_1_Xcoordinate=vert_0[0],\n            Vertex_1_Ycoordinate=vert_0[1],\n            Vertex_1_Zcoordinate=vert_0[2],\n            Vertex_2_Xcoordinate=vert_1[0],\n            Vertex_2_Ycoordinate=vert_1[1],\n            Vertex_2_Zcoordinate=vert_1[2],\n            Vertex_3_Xcoordinate=vert_2[0],\n            Vertex_3_Ycoordinate=vert_2[1],\n            Vertex_3_Zcoordinate=vert_2[2],\n            Zone_Name=\"Attic\",\n        )\n\n        vert_0 = (self.x + self.w, self.y + self.d, self.zones_height)\n        vert_1 = (self.x, self.y + self.d, self.zones_height)\n        vert_2 = (roof_centerline, self.y + self.d, self.total_height_with_gabling)\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"Endcap2\",\n            Surface_Type=\"Wall\",\n            Number_of_Vertices=3,\n            Vertex_1_Xcoordinate=vert_0[0],\n            Vertex_1_Ycoordinate=vert_0[1],\n            Vertex_1_Zcoordinate=vert_0[2],\n            Vertex_2_Xcoordinate=vert_1[0],\n            Vertex_2_Ycoordinate=vert_1[1],\n            Vertex_2_Zcoordinate=vert_1[2],\n            Vertex_3_Xcoordinate=vert_2[0],\n            Vertex_3_Ycoordinate=vert_2[1],\n            Vertex_3_Zcoordinate=vert_2[2],\n            Zone_Name=\"Attic\",\n        )\n\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"attic_bottom_plane\",\n            Surface_Type=\"Floor\",\n            Number_of_Vertices=4,\n            Vertex_1_Xcoordinate=self.x + self.w,\n            Vertex_1_Ycoordinate=self.y,\n            Vertex_1_Zcoordinate=self.zones_height,\n            Vertex_2_Xcoordinate=self.x,\n            Vertex_2_Ycoordinate=self.y,\n            Vertex_2_Zcoordinate=self.zones_height,\n            Vertex_3_Xcoordinate=self.x,\n            Vertex_3_Ycoordinate=self.y + self.d,\n            Vertex_3_Zcoordinate=self.zones_height,\n            Vertex_4_Xcoordinate=self.x + self.w,\n            Vertex_4_Ycoordinate=self.y + self.d,\n            Vertex_4_Zcoordinate=self.zones_height,\n            Zone_Name=\"Attic\",\n        )\n\n    idf.intersect_match()\n\n    idf.set_default_constructions()\n\n    # Handle Windows\n    window_walls = [\n        w\n        for w in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]\n        if w.Outside_Boundary_Condition.lower() == \"outdoors\"\n        and \"attic\" not in w.Zone_Name.lower()\n        and (\n            not w.Zone_Name.lower().endswith(self.basement_suffix.lower())\n            if self.basement\n            else True\n        )\n        and w.Surface_Type.lower() == \"wall\"\n    ]\n    idf.set_wwr(\n        wwr=self.wwr,\n        construction=\"Project External Window\",\n        force=True,\n        surfaces=window_walls,\n    )\n    return idf\n</code></pre>"},{"location":"modules/geometry/#epinterface.geometry.match_idf_to_building_and_neighbors","title":"<code>match_idf_to_building_and_neighbors(idf, building, neighbor_polys, neighbor_floors, neighbor_f2f_height, target_short_length, target_long_length, rotation_angle)</code>","text":"<p>Match an IDF model to a building and neighbors by scaling and rotating the IDF model and adding shading blocks for neighbors.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to match.</p> required <code>building</code> <code>Polygon | str</code> <p>The building to match.</p> required <code>neighbor_polys</code> <code>list[Polygon | str | None]</code> <p>The neighbors to inject as shading.</p> required <code>neighbor_floors</code> <code>list[float | int | None]</code> <p>The counts of the neighbors.</p> required <code>neighbor_f2f_height</code> <code>float | None</code> <p>The height of the building to match</p> required <code>target_short_length</code> <code>float</code> <p>The target short length of the building.</p> required <code>target_long_length</code> <code>float</code> <p>The target long length of the building.</p> required <code>rotation_angle</code> <code>float</code> <p>The rotation angle of the building (radians).</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The matched IDF model.</p> Source code in <code>epinterface\\geometry.py</code> <pre><code>def match_idf_to_building_and_neighbors(\n    idf: IDF,\n    building: Polygon | str,\n    neighbor_polys: list[Polygon | str | None],\n    neighbor_floors: list[float | int | None],\n    neighbor_f2f_height: float,\n    target_short_length: float,\n    target_long_length: float,\n    rotation_angle: float,\n) -&gt; IDF:\n    \"\"\"Match an IDF model to a building and neighbors by scaling and rotating the IDF model and adding shading blocks for neighbors.\n\n    Args:\n        idf (IDF): The IDF model to match.\n        building (Polygon | str): The building to match.\n        neighbor_polys (list[Polygon | str | None]): The neighbors to inject as shading.\n        neighbor_floors (list[float | int | None]): The counts of the neighbors.\n        neighbor_f2f_height (float | None): The height of the building to match\n        target_short_length (float): The target short length of the building.\n        target_long_length (float): The target long length of the building.\n        rotation_angle (float): The rotation angle of the building (radians).\n\n    Returns:\n        idf (IDF): The matched IDF model.\n    \"\"\"\n    building_geo = (\n        cast(Polygon, from_wkt(building)) if isinstance(building, str) else building\n    )\n    neighbor_geos = [\n        (cast(Polygon, from_wkt(n)), h * neighbor_f2f_height)\n        if isinstance(n, str)\n        else (n, h * neighbor_f2f_height)\n        for n, h in zip(neighbor_polys, neighbor_floors, strict=True)\n        if n is not None and h is not None\n    ]\n    centroid = building_geo.centroid\n    translated_neighbors = [\n        (translate(n, xoff=-centroid.x, yoff=-centroid.y), h) for n, h in neighbor_geos\n    ]\n    idf_lengths = {(e.p1 - e.p2).length for e in idf.bounding_box().edges}\n    if len(idf_lengths) &gt; 2:\n        raise NotImplementedError(\n            \"The IDF model is not a rectangle, which is not yet supported.\"\n        )\n\n    long_length = max(idf_lengths)\n    short_length = min(idf_lengths)\n    idf.scale(target_long_length / long_length, anchor=Vector2D(0, 0), axes=\"x\")\n    idf.scale(target_short_length / short_length, anchor=Vector2D(0, 0), axes=\"y\")\n    idf.translate((-target_long_length / 2, -target_short_length / 2, 0))\n    idf.rotate(rotation_angle * 180 / np.pi)\n    for i, (geom, height) in enumerate(translated_neighbors):\n        if not height:\n            height = 3.5 * 2\n        if np.isnan(height):\n            height = 3.5 * 2\n        idf.add_shading_block(\n            name=f\"shading_{i}\",\n            coordinates=[Vector2D(*coord) for coord in geom.exterior.coords[:-1]],\n            height=height,\n        )\n    return idf\n</code></pre>"},{"location":"modules/geometry/#epinterface.geometry.match_idf_to_scene","title":"<code>match_idf_to_scene(idf, gdf_buildings, building_ix, neighbor_threshold=50, apply_z_scale=False)</code>","text":"<p>Match an IDF model to a scene of buildings by scaling and rotating the IDF model.</p> <p>Additionally adds shading blocks for neighboring buildings.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to match.</p> required <code>gdf_buildings</code> <code>GeoDataFrame</code> <p>The scene of buildings.</p> required <code>building_ix</code> <code>int</code> <p>The index of the building in the scene to match.</p> required <code>neighbor_threshold</code> <code>float</code> <p>The distance threshold for a building to be considered a neighbor.</p> <code>50</code> <code>apply_z_scale</code> <code>bool</code> <p>Whether to scale the IDF model in the z direction.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The matched IDF model.</p> Source code in <code>epinterface\\geometry.py</code> <pre><code>def match_idf_to_scene(\n    idf: IDF,\n    gdf_buildings: gpd.GeoDataFrame,\n    building_ix: int,\n    neighbor_threshold: float = 50,\n    apply_z_scale: bool = False,\n):\n    \"\"\"Match an IDF model to a scene of buildings by scaling and rotating the IDF model.\n\n    Additionally adds shading blocks for neighboring buildings.\n\n    Args:\n        idf (IDF): The IDF model to match.\n        gdf_buildings (gpd.GeoDataFrame): The scene of buildings.\n        building_ix (int): The index of the building in the scene to match.\n        neighbor_threshold (float): The distance threshold for a building to be considered a neighbor.\n        apply_z_scale (bool): Whether to scale the IDF model in the z direction.\n\n\n    Returns:\n        idf (IDF): The matched IDF model.\n    \"\"\"\n    # TODO: add PANDERA schema validation\n    center = gdf_buildings.iloc[building_ix].rotated_rectangle\n    is_neighbor_mask = gdf_buildings.rotated_rectangle.apply(\n        lambda x: x.distance(center) &lt; neighbor_threshold\n    )\n    is_neighbor_mask.iloc[building_ix] = False\n    neighbor_intersects = gdf_buildings.rotated_rectangle[is_neighbor_mask].apply(\n        lambda x: x.intersects(center)\n    )\n    is_non_intersecting_neighbor = (\n        ~neighbor_intersects.reindex(gdf_buildings.index, fill_value=False)\n        &amp; is_neighbor_mask\n    )\n    non_intersecting_neighbor_geometry = gdf_buildings.rotated_rectangle[\n        is_non_intersecting_neighbor\n    ]\n    translated_neighbors = non_intersecting_neighbor_geometry.apply(\n        lambda x: translate(x, xoff=-center.centroid.x, yoff=-center.centroid.y)\n    )\n    translated_neighbor_heights = gdf_buildings.height[is_non_intersecting_neighbor]\n\n    idf_lengths = {(e.p1 - e.p2).length for e in idf.bounding_box().edges}\n    # TODO: handle the case where the idf model building is not a rectangle\n    # TODO: errors/warnings on scaling factors being too large or aspect ratio too\n    # TODO: handle cases where the base idf building is rotated\n    # different\n    if len(idf_lengths) != 2:\n        raise NotImplementedError(\n            \"The IDF model is not a rectangle, which is not yet supported.\"\n        )\n    short_length = min(idf_lengths)\n    long_length = max(idf_lengths)\n    z_coords = [\n        obj[f\"Vertex_{i}_Zcoordinate\"]\n        for obj in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]\n        for i in range(1, 5)\n    ]\n    z_coords = [float(z) for z in z_coords if z]\n    model_height = max(z_coords)\n    building_short_length = gdf_buildings.iloc[building_ix].short_edge\n    building_long_length = gdf_buildings.iloc[building_ix].long_edge\n    building_height = gdf_buildings.iloc[building_ix].height\n    idf.scale(building_long_length / long_length, anchor=Vector2D(0, 0), axes=\"x\")\n    idf.scale(building_short_length / short_length, anchor=Vector2D(0, 0), axes=\"y\")\n    if apply_z_scale:\n        idf.scale(building_height / model_height, anchor=Vector2D(0, 0), axes=\"z\")\n\n    idf.translate((-building_long_length / 2, -building_short_length / 2, 0))\n    rotation_angle = gdf_buildings.iloc[building_ix].long_edge_angle\n    idf.rotate(rotation_angle * 180 / np.pi)\n\n    # add the neighbors as shading blocks\n    for i, geom in enumerate(translated_neighbors):\n        height = translated_neighbor_heights.iloc[i]\n        if not height:\n            height = 3.5\n        if np.isnan(height):\n            height = 3.5\n        idf.add_shading_block(\n            name=f\"shading_{i}\",\n            coordinates=[Vector2D(*coord) for coord in geom.exterior.coords[:-1]],\n            height=height,\n        )\n    return idf\n</code></pre>"},{"location":"modules/interface/","title":"EnergyPlus Interface","text":"<p>This is a thin wrapper around Eppy for some opinionated control.</p> <p>Interface for EnergyPlus IDF objects.</p>"},{"location":"modules/interface/#epinterface.interface.AirGapMaterial","title":"<code>AirGapMaterial</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>AirGapMaterial object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class AirGapMaterial(BaseObj, extra=\"ignore\"):\n    \"\"\"AirGapMaterial object.\"\"\"\n\n    key: ClassVar[str] = \"MATERIAL:AIRGAP\"\n    Name: str\n    Thermal_Resistance: float\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.BaseMaterial","title":"<code>BaseMaterial</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A base material object for storing material definitions.</p> <p>Note that this is not an EnergyPlus object, but a base class for creating new material objects which can be turned into EP objects once assigned thicknesses.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class BaseMaterial(BaseModel, extra=\"ignore\", populate_by_name=True):\n    \"\"\"A base material object for storing material definitions.\n\n    Note that this is not an EnergyPlus object, but a base class for creating new\n    material objects which can be turned into EP objects once assigned thicknesses.\n    \"\"\"\n\n    Name: str\n    Roughness: str\n    Conductivity: float = Field(..., ge=0, validation_alias=\"Conductivity [W/m.K]\")\n    Density: float = Field(..., ge=0, validation_alias=\"Density [kg/m3]\")\n    Specific_Heat: float = Field(..., ge=0, validation_alias=\"SpecificHeat [J/kg.K]\")\n    Thermal_Absorptance: float | None = Field(\n        default=None, validation_alias=\"ThermalAbsorptance [0-1]\", ge=0, le=1\n    )\n    Solar_Absorptance: float | None = Field(\n        default=None, validation_alias=\"SolarAbsorptance [0-1]\", ge=0, le=1\n    )\n    Visible_Absorptance: float | None = Field(\n        default=None, validation_alias=\"VisibleAbsorptance [0-1]\", ge=0, le=1\n    )\n\n    def as_layer(self, thickness: float):\n        \"\"\"Create a new material object with a given thickness.\n\n        Args:\n            thickness (float): The thickness of the material.\n\n        Returns:\n            mat (Material): The new material object with the given thickness.\n        \"\"\"\n        name = f\"{self.Name}_{thickness}m\"\n        return Material(\n            Name=name, Thickness=thickness, **self.model_dump(exclude={\"Name\"})\n        )\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.BaseMaterial.as_layer","title":"<code>as_layer(thickness)</code>","text":"<p>Create a new material object with a given thickness.</p> <p>Parameters:</p> Name Type Description Default <code>thickness</code> <code>float</code> <p>The thickness of the material.</p> required <p>Returns:</p> Name Type Description <code>mat</code> <code>Material</code> <p>The new material object with the given thickness.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>def as_layer(self, thickness: float):\n    \"\"\"Create a new material object with a given thickness.\n\n    Args:\n        thickness (float): The thickness of the material.\n\n    Returns:\n        mat (Material): The new material object with the given thickness.\n    \"\"\"\n    name = f\"{self.Name}_{thickness}m\"\n    return Material(\n        Name=name, Thickness=thickness, **self.model_dump(exclude={\"Name\"})\n    )\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.BaseObj","title":"<code>BaseObj</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for EnergyPlus IDF objects.</p> <p>The class should be inherited by all EnergyPlus IDF objects. It provides methods to add and extract objects from an IDF object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class BaseObj(BaseModel):\n    \"\"\"Base class for EnergyPlus IDF objects.\n\n    The class should be inherited by all EnergyPlus IDF objects. It provides\n    methods to add and extract objects from an IDF object.\n    \"\"\"\n\n    key: ClassVar[str]\n\n    def add(self, idf: IDF):\n        \"\"\"Add the object to the IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the object to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        idf.newidfobject(self.key, **self.model_dump())\n        return idf\n\n    @classmethod\n    def extract(cls, idf: IDF):\n        \"\"\"Extract objects from an IDF object.\n\n        Args:\n            idf (IDF): The IDF object to extract objects from.\n\n        Returns:\n            objs (list[BaseObj]): A list of objects extracted from the IDF object.\n        \"\"\"\n        objs = idf.idfobjects[cls.key]\n        try:\n            return [cls(**obj) for obj in objs]\n        except ValidationError:\n            return [cls(**obj.to_dict()) for obj in objs]\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.BaseObj.add","title":"<code>add(idf)</code>","text":"<p>Add the object to the IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the object to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>def add(self, idf: IDF):\n    \"\"\"Add the object to the IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the object to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    idf.newidfobject(self.key, **self.model_dump())\n    return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.BaseObj.extract","title":"<code>extract(idf)</code>  <code>classmethod</code>","text":"<p>Extract objects from an IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to extract objects from.</p> required <p>Returns:</p> Name Type Description <code>objs</code> <code>list[BaseObj]</code> <p>A list of objects extracted from the IDF object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>@classmethod\ndef extract(cls, idf: IDF):\n    \"\"\"Extract objects from an IDF object.\n\n    Args:\n        idf (IDF): The IDF object to extract objects from.\n\n    Returns:\n        objs (list[BaseObj]): A list of objects extracted from the IDF object.\n    \"\"\"\n    objs = idf.idfobjects[cls.key]\n    try:\n        return [cls(**obj) for obj in objs]\n    except ValidationError:\n        return [cls(**obj.to_dict()) for obj in objs]\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.Construction","title":"<code>Construction</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>Construction object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class Construction(BaseObj, extra=\"ignore\"):\n    \"\"\"Construction object.\"\"\"\n\n    key: ClassVar[str] = \"CONSTRUCTION\"\n    name: str\n    layers: Sequence[Material | AirGapMaterial | SimpleGlazingMaterial | NoMassMaterial]\n\n    @property\n    def r_value(self):\n        \"\"\"Return the R-value of the construction.\n\n        Computed using the formula: R = sum(thickness_i / conductivity_i)\n\n        Returns:\n            r (float): The R-value of the construction (units: m^2.K/W).\n        \"\"\"\n        return (\n            sum([layer.r for layer in self.layers if isinstance(layer, Material)])\n            + sum([\n                layer.Thermal_Resistance\n                for layer in self.layers\n                if isinstance(layer, AirGapMaterial)\n            ])\n            + sum([\n                layer.Thermal_Resistance\n                for layer in self.layers\n                if isinstance(layer, NoMassMaterial)\n            ])\n            + sum([\n                1 / layer.UFactor\n                for layer in self.layers\n                if isinstance(layer, SimpleGlazingMaterial)\n            ])\n        )\n\n    @classmethod\n    def extract(cls, idf: IDF):\n        \"\"\"Extract objects from an IDF object.\n\n        Args:\n            idf (IDF): The IDF object to extract objects from.\n\n        Returns:\n            constructions (list[Construction]): A list of objects extracted from the IDF object.\n        \"\"\"\n        constructions = idf.idfobjects[\"CONSTRUCTION\"]\n        res: list[Construction] = []\n        for construction in constructions:\n            const_dict = construction.to_dict()\n            layer_names = [\n                const_dict[key]\n                for key in [\n                    \"Outside_Layer\",\n                    \"Layer_2\",\n                    \"Layer_3\",\n                    \"Layer_4\",\n                    \"Layer_5\",\n                    \"Layer_6\",\n                    \"Layer_7\",\n                    \"Layer_8\",\n                    \"Layer_9\",\n                    \"Layer_10\",\n                ]\n                if key in const_dict\n            ]\n\n            layer_names = [n for n in layer_names if n != \"\" and n]\n            material_defs = [\n                idf.getobject(\"MATERIAL\", name) for name in layer_names\n            ]  # TODO: handle air layers\n            airgap_material_defs = [\n                idf.getobject(\"MATERIAL:AIRGAP\", name) for name in layer_names\n            ]\n            simple_glazing_material_defs = [\n                idf.getobject(\"WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM\", name)\n                for name in layer_names\n            ]\n            no_mass_material_defs = [\n                idf.getobject(\"MATERIAL:NOMASS\", name) for name in layer_names\n            ]\n            materials = [Material(**m.to_dict()) if m else None for m in material_defs]\n            airgap_materials = [\n                AirGapMaterial(**m.to_dict()) if m else None\n                for m in airgap_material_defs\n            ]\n            simple_glazing_materials = [\n                SimpleGlazingMaterial(**m.to_dict()) if m else None\n                for m in simple_glazing_material_defs\n            ]\n            nomass_materials = [\n                NoMassMaterial(**m.to_dict()) if m else None\n                for m in no_mass_material_defs\n            ]\n\n            layers = [\n                m if m else (n if n else (o if o else p))\n                for m, n, o, p in zip(\n                    materials,\n                    airgap_materials,\n                    simple_glazing_materials,\n                    nomass_materials,\n                    strict=False,\n                )\n            ]\n\n            valid_layers = [layer for layer in layers if layer is not None]\n            if len(valid_layers) != len(layers):\n                logger.warning(\n                    f\"Construction {construction.Name} has missing layers. \"\n                    f\"Expected {len(layers)} layers, got {len(valid_layers)}.\"\n                    f\"Skipping construction extraction.\"\n                )\n                continue\n            construction = cls(name=construction.Name, layers=valid_layers)\n            res.append(construction)\n        return res\n\n    def add(self, idf: IDF):\n        \"\"\"Add the object to the IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the object to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        for layer in self.layers:\n            idf = layer.add(idf)\n        idf.newidfobject(\n            self.key,\n            Name=self.name,\n            **{\n                (f\"Layer_{i + 1}\" if i != 0 else \"Outside_Layer\"): layer.Name\n                for i, layer in enumerate(self.layers)\n            },\n        )\n        return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.Construction.r_value","title":"<code>r_value</code>  <code>property</code>","text":"<p>Return the R-value of the construction.</p> <p>Computed using the formula: R = sum(thickness_i / conductivity_i)</p> <p>Returns:</p> Name Type Description <code>r</code> <code>float</code> <p>The R-value of the construction (units: m^2.K/W).</p>"},{"location":"modules/interface/#epinterface.interface.Construction.add","title":"<code>add(idf)</code>","text":"<p>Add the object to the IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the object to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>def add(self, idf: IDF):\n    \"\"\"Add the object to the IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the object to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    for layer in self.layers:\n        idf = layer.add(idf)\n    idf.newidfobject(\n        self.key,\n        Name=self.name,\n        **{\n            (f\"Layer_{i + 1}\" if i != 0 else \"Outside_Layer\"): layer.Name\n            for i, layer in enumerate(self.layers)\n        },\n    )\n    return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.Construction.extract","title":"<code>extract(idf)</code>  <code>classmethod</code>","text":"<p>Extract objects from an IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to extract objects from.</p> required <p>Returns:</p> Name Type Description <code>constructions</code> <code>list[Construction]</code> <p>A list of objects extracted from the IDF object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>@classmethod\ndef extract(cls, idf: IDF):\n    \"\"\"Extract objects from an IDF object.\n\n    Args:\n        idf (IDF): The IDF object to extract objects from.\n\n    Returns:\n        constructions (list[Construction]): A list of objects extracted from the IDF object.\n    \"\"\"\n    constructions = idf.idfobjects[\"CONSTRUCTION\"]\n    res: list[Construction] = []\n    for construction in constructions:\n        const_dict = construction.to_dict()\n        layer_names = [\n            const_dict[key]\n            for key in [\n                \"Outside_Layer\",\n                \"Layer_2\",\n                \"Layer_3\",\n                \"Layer_4\",\n                \"Layer_5\",\n                \"Layer_6\",\n                \"Layer_7\",\n                \"Layer_8\",\n                \"Layer_9\",\n                \"Layer_10\",\n            ]\n            if key in const_dict\n        ]\n\n        layer_names = [n for n in layer_names if n != \"\" and n]\n        material_defs = [\n            idf.getobject(\"MATERIAL\", name) for name in layer_names\n        ]  # TODO: handle air layers\n        airgap_material_defs = [\n            idf.getobject(\"MATERIAL:AIRGAP\", name) for name in layer_names\n        ]\n        simple_glazing_material_defs = [\n            idf.getobject(\"WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM\", name)\n            for name in layer_names\n        ]\n        no_mass_material_defs = [\n            idf.getobject(\"MATERIAL:NOMASS\", name) for name in layer_names\n        ]\n        materials = [Material(**m.to_dict()) if m else None for m in material_defs]\n        airgap_materials = [\n            AirGapMaterial(**m.to_dict()) if m else None\n            for m in airgap_material_defs\n        ]\n        simple_glazing_materials = [\n            SimpleGlazingMaterial(**m.to_dict()) if m else None\n            for m in simple_glazing_material_defs\n        ]\n        nomass_materials = [\n            NoMassMaterial(**m.to_dict()) if m else None\n            for m in no_mass_material_defs\n        ]\n\n        layers = [\n            m if m else (n if n else (o if o else p))\n            for m, n, o, p in zip(\n                materials,\n                airgap_materials,\n                simple_glazing_materials,\n                nomass_materials,\n                strict=False,\n            )\n        ]\n\n        valid_layers = [layer for layer in layers if layer is not None]\n        if len(valid_layers) != len(layers):\n            logger.warning(\n                f\"Construction {construction.Name} has missing layers. \"\n                f\"Expected {len(layers)} layers, got {len(valid_layers)}.\"\n                f\"Skipping construction extraction.\"\n            )\n            continue\n        construction = cls(name=construction.Name, layers=valid_layers)\n        res.append(construction)\n    return res\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.DefaultMaterialLibrary","title":"<code>DefaultMaterialLibrary</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Default material library for storing some common material defs.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class DefaultMaterialLibrary(BaseModel):\n    \"\"\"Default material library for storing some common material defs.\"\"\"\n\n    wood: BaseMaterial = wood\n    gypsum: BaseMaterial = gypsum\n    drywall: BaseMaterial = drywall\n    osb: BaseMaterial = osb\n    concrete: BaseMaterial = concrete\n    insulation: BaseMaterial = insulation\n    stucco: BaseMaterial = stucco\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.ElectricEquipment","title":"<code>ElectricEquipment</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>ElectricEquipment object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class ElectricEquipment(BaseObj, extra=\"ignore\"):\n    \"\"\"ElectricEquipment object.\"\"\"\n\n    key: ClassVar[str] = \"ELECTRICEQUIPMENT\"\n    Name: str\n    Zone_or_ZoneList_Name: str\n    Schedule_Name: str\n    Design_Level_Calculation_Method: DesignLevelCalculationMethodType = \"Watts/Area\"\n    Design_Level: float | None = None\n    Watts_per_Zone_Floor_Area: float | None = None\n    Watts_per_Person: float | None = None\n    Fraction_Latent: float = 0.00\n    Fraction_Radiant: float = 0.2\n    Fraction_Lost: float = 0\n    EndUse_Subcategory: str | None = None\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.HVACTemplateThermostat","title":"<code>HVACTemplateThermostat</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>HVACTemplateThermostat object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class HVACTemplateThermostat(BaseModel):\n    \"\"\"HVACTemplateThermostat object.\"\"\"\n\n    Name: str\n    Heating_Setpoint_Schedule_Name: str | None = None\n    Constant_Heating_Setpoint: float | None = 21\n    Cooling_Setpoint_Schedule_Name: str | None = None\n    Constant_Cooling_Setpoint: float | None = 24\n\n    def add(self, idf: IDF):\n        \"\"\"Add the object to the IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the object to.\n\n        Returns:\n            idf (IDF): The updated IDF object\n        \"\"\"\n        idf.newidfobject(\"HVACTEMPLATE:THERMOSTAT\", **self.model_dump())\n        return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.HVACTemplateThermostat.add","title":"<code>add(idf)</code>","text":"<p>Add the object to the IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the object to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object</p> Source code in <code>epinterface\\interface.py</code> <pre><code>def add(self, idf: IDF):\n    \"\"\"Add the object to the IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the object to.\n\n    Returns:\n        idf (IDF): The updated IDF object\n    \"\"\"\n    idf.newidfobject(\"HVACTEMPLATE:THERMOSTAT\", **self.model_dump())\n    return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.HVACTemplateZoneIdealLoadsAirSystem","title":"<code>HVACTemplateZoneIdealLoadsAirSystem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>HVACTemplateZoneIdealLoadsAirSystem object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class HVACTemplateZoneIdealLoadsAirSystem(BaseModel):\n    \"\"\"HVACTemplateZoneIdealLoadsAirSystem object.\"\"\"\n\n    Zone_Name: str\n    Template_Thermostat_Name: str\n    System_Availability_Schedule_Name: str | None = None\n    Heating_Availability_Schedule_Name: str | None = None\n    Cooling_Availability_Schedule_Name: str | None = None\n    Maximum_Heating_Supply_Air_Temperature: float = 30\n    Minimum_Cooling_Supply_Air_Temperature: float = 18\n    Maximum_Heating_Supply_Air_Humidity_Ratio: float = 0.0156\n    Minimum_Cooling_Supply_Air_Humidity_Ratio: float = 0.0077\n    Heating_Limit: IdealLoadsLimitType = \"NoLimit\"\n    Maximum_Heating_Air_Flow_Rate: float | None | Literal[\"autosize\"] = None\n    Maximum_Sensible_Heating_Capacity: float | None | Literal[\"autosize\"] = None\n    Cooling_Limit: IdealLoadsLimitType = \"NoLimit\"\n    Maximum_Cooling_Air_Flow_Rate: float | None | Literal[\"autosize\"] = None\n    Maximum_Total_Cooling_Capacity: float | None | Literal[\"autosize\"] = None\n    Dehumidification_Control_Type: DehumidificationControlTypeType = \"None\"\n    Cooling_Sensible_Heat_Ratio: float = 0.7\n    Dehumidification_Setpoint: float = 60\n    Humidification_Control_Type: HumidificationControlTypeType = \"None\"\n    Humidification_Setpoint: float = 30\n    Outdoor_Air_Method: OutdoorAirMethodType = \"None\"\n    Outdoor_Air_Flow_Rate_per_Person: float = 0.00944\n    Outdoor_Air_Flow_Rate_per_Zone_Floor_Area: float = 0.00025\n    Outdoor_Air_Flow_Rate_per_Zone: float = 0.0\n    # Design_Specification_Outdoor_Air_Object_Name: Optional[str] = None\n    Demand_Controlled_Ventilation_Type: DemandControlledVentilationTypeType = \"None\"\n    Outdoor_Air_Economizer_Type: OutdoorAirEconomizerTypeType = \"NoEconomizer\"\n    Heat_Recovery_Type: HeatRecoveryTypeType = \"None\"\n    Sensible_Heat_Recovery_Effectiveness: float = 0.7\n    Latent_Heat_Recovery_Effectiveness: float = 0.65\n\n    def add(self, idf: IDF):\n        \"\"\"Add the object to the IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the object to.\n\n        Returns:\n            idf (IDF): The updated IDF object\n        \"\"\"\n        idf.newidfobject(\"HVACTEMPLATE:ZONE:IDEALLOADSAIRSYSTEM\", **self.model_dump())\n        return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.HVACTemplateZoneIdealLoadsAirSystem.add","title":"<code>add(idf)</code>","text":"<p>Add the object to the IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the object to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object</p> Source code in <code>epinterface\\interface.py</code> <pre><code>def add(self, idf: IDF):\n    \"\"\"Add the object to the IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the object to.\n\n    Returns:\n        idf (IDF): The updated IDF object\n    \"\"\"\n    idf.newidfobject(\"HVACTEMPLATE:ZONE:IDEALLOADSAIRSYSTEM\", **self.model_dump())\n    return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.Lights","title":"<code>Lights</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>Lights object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class Lights(BaseObj, extra=\"ignore\"):\n    \"\"\"Lights object.\"\"\"\n\n    key: ClassVar[str] = \"LIGHTS\"\n    Name: str\n    Zone_or_ZoneList_Name: str\n    Schedule_Name: str\n    Design_Level_Calculation_Method: DesignLevelCalculationMethodType = \"Watts/Area\"\n    Lighting_Level: float | None = None\n    Watts_per_Zone_Floor_Area: float | None = None\n    Watts_per_Person: float | None = None\n    Return_Air_Fraction: float = 0\n    Fraction_Radiant: float = 0.42\n    Fraction_Visible: float = 0.18\n    Fraction_Replaceable: float | None = 1\n    EndUse_Subcategory: str | None = None\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.Material","title":"<code>Material</code>","text":"<p>               Bases: <code>BaseObj</code>, <code>BaseMaterial</code></p> <p>Material object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class Material(BaseObj, BaseMaterial, extra=\"ignore\"):\n    \"\"\"Material object.\"\"\"\n\n    key: ClassVar[str] = \"MATERIAL\"\n    Name: str\n    Thickness: float\n\n    @field_validator(\"Thermal_Absorptance\", mode=\"before\")\n    def str_cast(cls, v):\n        \"\"\"Cast the value to a float if it is a string or empty.\n\n        Args:\n            v (Any): The value to cast.\n\n        Returns:\n            v (float): The casted value.\n        \"\"\"\n        if v == \"\" or v is None:\n            return None\n        return float(v)\n\n    @property\n    def r(self):\n        \"\"\"Return the R of the material.\"\"\"\n        return self.Thickness / self.Conductivity\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.Material.r","title":"<code>r</code>  <code>property</code>","text":"<p>Return the R of the material.</p>"},{"location":"modules/interface/#epinterface.interface.Material.str_cast","title":"<code>str_cast(v)</code>","text":"<p>Cast the value to a float if it is a string or empty.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Any</code> <p>The value to cast.</p> required <p>Returns:</p> Name Type Description <code>v</code> <code>float</code> <p>The casted value.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>@field_validator(\"Thermal_Absorptance\", mode=\"before\")\ndef str_cast(cls, v):\n    \"\"\"Cast the value to a float if it is a string or empty.\n\n    Args:\n        v (Any): The value to cast.\n\n    Returns:\n        v (float): The casted value.\n    \"\"\"\n    if v == \"\" or v is None:\n        return None\n    return float(v)\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.NoMassMaterial","title":"<code>NoMassMaterial</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>NoMassMaterial object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class NoMassMaterial(BaseObj, extra=\"ignore\"):\n    \"\"\"NoMassMaterial object.\"\"\"\n\n    key: ClassVar[str] = \"MATERIAL:NOMASS\"\n    Name: str\n    Roughness: str\n    Thermal_Resistance: float\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.People","title":"<code>People</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>People object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class People(BaseObj, extra=\"ignore\"):\n    \"\"\"People object.\"\"\"\n\n    key: ClassVar[str] = \"PEOPLE\"\n    Name: str\n    Zone_or_ZoneList_Name: str\n    Number_of_People_Schedule_Name: str\n    Number_of_People_Calculation_Method: NumberOfPeopleCalculationMethodType\n    Number_of_People: float | None = None\n    People_per_Floor_Area: float | None = None\n    Floor_Area_per_Person: float | None = None\n    Fraction_Radiant: float = 0.3\n    Sensible_Heat_Fraction: float | Literal[\"autocalculate\"] = \"autocalculate\"\n    Activity_Level_Schedule_Name: str\n    # Carbon_Dioxide_Generation_Rate: Optional[float] = None\n    Enable_ASHRAE_55_Comfort_Warnings: Literal[\"Yes\", \"No\"] = \"No\"\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.RunPeriod","title":"<code>RunPeriod</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>RunPeriod object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class RunPeriod(BaseObj, extra=\"ignore\"):\n    \"\"\"RunPeriod object.\"\"\"\n\n    key: ClassVar[str] = \"RUNPERIOD\"\n    Name: str\n    Begin_Month: int\n    Begin_Day_of_Month: int\n    Begin_Year: int | None = None\n    End_Month: int\n    End_Day_of_Month: int\n    End_Year: int | None = None\n    Day_of_Week_for_Start_Day: Literal[\n        \"Sunday\",\n        \"Monday\",\n        \"Tuesday\",\n        \"Wednesday\",\n        \"Thursday\",\n        \"Friday\",\n        \"Saturday\",\n    ] = \"Sunday\"\n    Use_Weather_File_Daylight_Saving_Period: Literal[\"Yes\", \"No\"] = \"No\"\n    Use_Weather_File_Holidays_and_Special_Days: Literal[\"Yes\", \"No\"] = \"No\"\n    Apply_Weekend_Holiday_Rule: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Use_Weather_File_Rain_Indicators: Literal[\"Yes\", \"No\"] = \"No\"\n    Use_Weather_File_Snow_Indicators: Literal[\"Yes\", \"No\"] = \"No\"\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.ScheduleTypeLimits","title":"<code>ScheduleTypeLimits</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>ScheduleTypeLimits object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class ScheduleTypeLimits(BaseObj, extra=\"ignore\"):\n    \"\"\"ScheduleTypeLimits object.\"\"\"\n\n    key: ClassVar[str] = \"SCHEDULETYPELIMITS\"\n    Name: str\n    Lower_Limit_Value: float | None = None\n    Upper_Limit_Value: float | None = None\n    Numeric_Type: Literal[\"Continuous\", \"Discrete\"] | None = None\n    Unit_Type: (\n        Literal[\n            \"Dimensionless\",\n            \"Temperature\",\n            \"DeltaTemperature\",\n            \"PrecipitationRate\",\n            \"Angle\",\n            \"ConvectionCoefficient\",\n            \"ActivityLevel\",\n            \"Velocity\",\n            \"Capacity\",\n            \"Power\",\n            \"Availability\",\n            \"Percent\",\n            \"Control\",\n            \"Mode\",\n        ]\n        | None\n    ) = None\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.SimpleGlazingMaterial","title":"<code>SimpleGlazingMaterial</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>SimpleGlazingMaterial object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class SimpleGlazingMaterial(BaseObj, extra=\"ignore\"):\n    \"\"\"SimpleGlazingMaterial object.\"\"\"\n\n    key: ClassVar[str] = \"WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM\"\n    Name: str\n    UFactor: float\n    Solar_Heat_Gain_Coefficient: float\n    Visible_Transmittance: float\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.SimulationControl","title":"<code>SimulationControl</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>SimulationControl object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class SimulationControl(BaseObj, extra=\"ignore\"):\n    \"\"\"SimulationControl object.\"\"\"\n\n    key: ClassVar[str] = \"SIMULATIONCONTROL\"\n    Do_Zone_Sizing_Calculation: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Do_System_Sizing_Calculation: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Do_Plant_Sizing_Calculation: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Run_Simulation_for_Sizing_Periods: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Run_Simulation_for_Weather_File_Run_Periods: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Do_HVAC_Sizing_Simulation_for_Sizing_Periods: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Maximum_Number_of_HVAC_Sizing_Simulation_Passes: int = 1\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.SiteGroundTemperature","title":"<code>SiteGroundTemperature</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>GroundTemperature object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class SiteGroundTemperature(BaseObj, extra=\"ignore\"):\n    \"\"\"GroundTemperature object.\"\"\"\n\n    key: ClassVar[str] = \"SITE:GROUNDTEMPERATURE:BUILDINGSURFACE\"\n    January_Ground_Temperature: float\n    February_Ground_Temperature: float\n    March_Ground_Temperature: float\n    April_Ground_Temperature: float\n    May_Ground_Temperature: float\n    June_Ground_Temperature: float\n    July_Ground_Temperature: float\n    August_Ground_Temperature: float\n    September_Ground_Temperature: float\n    October_Ground_Temperature: float\n    November_Ground_Temperature: float\n    December_Ground_Temperature: float\n\n    @classmethod\n    def FromValues(cls, values: list[float]):\n        \"\"\"Create a new SiteGroundTemperature object from a list of 12 monthly values.\n\n        Args:\n            values (list[float]): A list of 12 monthly values.\n\n        Returns:\n            ground_temp (SiteGroundTemperature): The new SiteGroundTemperature object.\n        \"\"\"\n        if len(values) != 12:\n            raise ValueError(f\"GROUNDTEMP:EXPECTED_12:RECEIVED_{len(values)}\")\n        return cls(\n            January_Ground_Temperature=values[0],\n            February_Ground_Temperature=values[1],\n            March_Ground_Temperature=values[2],\n            April_Ground_Temperature=values[3],\n            May_Ground_Temperature=values[4],\n            June_Ground_Temperature=values[5],\n            July_Ground_Temperature=values[6],\n            August_Ground_Temperature=values[7],\n            September_Ground_Temperature=values[8],\n            October_Ground_Temperature=values[9],\n            November_Ground_Temperature=values[10],\n            December_Ground_Temperature=values[11],\n        )\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.SiteGroundTemperature.FromValues","title":"<code>FromValues(values)</code>  <code>classmethod</code>","text":"<p>Create a new SiteGroundTemperature object from a list of 12 monthly values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list[float]</code> <p>A list of 12 monthly values.</p> required <p>Returns:</p> Name Type Description <code>ground_temp</code> <code>SiteGroundTemperature</code> <p>The new SiteGroundTemperature object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>@classmethod\ndef FromValues(cls, values: list[float]):\n    \"\"\"Create a new SiteGroundTemperature object from a list of 12 monthly values.\n\n    Args:\n        values (list[float]): A list of 12 monthly values.\n\n    Returns:\n        ground_temp (SiteGroundTemperature): The new SiteGroundTemperature object.\n    \"\"\"\n    if len(values) != 12:\n        raise ValueError(f\"GROUNDTEMP:EXPECTED_12:RECEIVED_{len(values)}\")\n    return cls(\n        January_Ground_Temperature=values[0],\n        February_Ground_Temperature=values[1],\n        March_Ground_Temperature=values[2],\n        April_Ground_Temperature=values[3],\n        May_Ground_Temperature=values[4],\n        June_Ground_Temperature=values[5],\n        July_Ground_Temperature=values[6],\n        August_Ground_Temperature=values[7],\n        September_Ground_Temperature=values[8],\n        October_Ground_Temperature=values[9],\n        November_Ground_Temperature=values[10],\n        December_Ground_Temperature=values[11],\n    )\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.SizingParameters","title":"<code>SizingParameters</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>SizingParameters object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class SizingParameters(BaseObj, extra=\"ignore\"):\n    \"\"\"SizingParameters object.\"\"\"\n\n    key: ClassVar[str] = \"SIZING:PARAMETERS\"\n    Heating_Sizing_Factor: float\n    Cooling_Sizing_Factor: float\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.Timestep","title":"<code>Timestep</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>Timestep object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class Timestep(BaseObj, extra=\"ignore\"):\n    \"\"\"Timestep object.\"\"\"\n\n    key: ClassVar[str] = \"TIMESTEP\"\n    Number_of_Timesteps_per_Hour: int = 6\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.WaterUseEquipment","title":"<code>WaterUseEquipment</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>WaterUseEquipment object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class WaterUseEquipment(BaseObj, extra=\"ignore\"):\n    \"\"\"WaterUseEquipment object.\"\"\"\n\n    key: ClassVar[str] = \"WATERUSE:EQUIPMENT\"\n    Name: str\n    EndUse_Subcategory: str | None = None\n    Peak_Flow_Rate: float\n    Flow_Rate_Fraction_Schedule_Name: str | None = None\n    Target_Temperature_Schedule_Name: str | None = None\n    Hot_Water_Supply_Temperature_Schedule_Name: str | None = None\n    Cold_Water_Supply_Temperature_Schedule_Name: str | None = None\n    Zone_Name: str | None = None\n    Sensible_Fraction_Schedule_Name: str | None = None\n    Latent_Fraction_Schedule_Name: str | None = None\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.ZoneInfiltrationDesignFlowRate","title":"<code>ZoneInfiltrationDesignFlowRate</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>ZoneInfiltrationDesignFlowRate object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class ZoneInfiltrationDesignFlowRate(BaseObj, extra=\"ignore\"):\n    \"\"\"ZoneInfiltrationDesignFlowRate object.\"\"\"\n\n    key: ClassVar[str] = \"ZONEINFILTRATION:DESIGNFLOWRATE\"\n    Name: str\n    Zone_or_ZoneList_Name: str\n    Schedule_Name: str\n    Design_Flow_Rate_Calculation_Method: InfDesignFlowRateCalculationMethodType\n    Design_Flow_Rate: float | None = None\n    Flow_Rate_per_Floor_Area: float | None = None\n    Flow_Rate_per_Exterior_Surface_Area: float | None = None\n    Air_Changes_per_Hour: float | None = None\n    Constant_Term_Coefficient: float = 0.606\n    Temperature_Term_Coefficient: float = 3.6359996e-2\n    Velocity_Term_Coefficient: float = 0.117765\n    Velocity_Squared_Term_Coefficient: float = 0\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.ZoneList","title":"<code>ZoneList</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>ZoneList object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>class ZoneList(BaseModel, extra=\"ignore\"):\n    \"\"\"ZoneList object.\"\"\"\n\n    Name: str\n    Names: list[str]\n\n    def add(self, idf: IDF):\n        \"\"\"Add the object to the IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the object to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        names = {\n            f\"Zone_{i + 1}_Name\": zone for i, zone in enumerate(self.Names) if zone\n        }\n        idf.newidfobject(\"ZONELIST\", Name=self.Name, **names)\n        return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.ZoneList.add","title":"<code>add(idf)</code>","text":"<p>Add the object to the IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the object to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>def add(self, idf: IDF):\n    \"\"\"Add the object to the IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the object to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    names = {\n        f\"Zone_{i + 1}_Name\": zone for i, zone in enumerate(self.Names) if zone\n    }\n    idf.newidfobject(\"ZONELIST\", Name=self.Name, **names)\n    return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.add_default_schedules","title":"<code>add_default_schedules(idf)</code>","text":"<p>Helper to add default schedules to the IDF model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the schedules to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The IDF model with the added schedules.</p> <code>scheds</code> <code>dict[str, Schedule]</code> <p>A dictionary of the added schedules.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>def add_default_schedules(idf: IDF) -&gt; tuple[IDF, dict[str, Schedule]]:\n    \"\"\"Helper to add default schedules to the IDF model.\n\n    Args:\n        idf (IDF): The IDF model to add the schedules to.\n\n    Returns:\n        idf (IDF): The IDF model with the added schedules.\n        scheds (dict[str, Schedule]): A dictionary of the added schedules.\n    \"\"\"\n    # create constant scheds\n    all_scheds: dict[str, Schedule] = {}\n    always_on_schedule = Schedule.constant_schedule(Name=\"Always_On\", value=1)\n    always_off_schedule = Schedule.constant_schedule(Name=\"Always_Off\", value=0)\n    all_scheds[\"Always_On\"] = always_on_schedule\n    all_scheds[\"Always_Off\"] = always_off_schedule\n    year, *_ = always_on_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n    year, *_ = always_off_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n\n    always_on_schedule = Schedule.constant_schedule(Name=\"Always On\", value=1)\n    always_off_schedule = Schedule.constant_schedule(Name=\"Always Off\", value=0)\n    all_scheds[\"Always On\"] = always_on_schedule\n    all_scheds[\"Always Off\"] = always_off_schedule\n    year, *_ = always_on_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n    year, *_ = always_off_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n\n    always_on_schedule = Schedule.constant_schedule(Name=\"On\", value=1)\n    always_off_schedule = Schedule.constant_schedule(Name=\"Off\", value=0)\n    all_scheds[\"On\"] = always_on_schedule\n    all_scheds[\"Off\"] = always_off_schedule\n    year, *_ = always_on_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n    year, *_ = always_off_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n\n    always_on_schedule = Schedule.constant_schedule(Name=\"AllOn\", value=1)\n    always_off_schedule = Schedule.constant_schedule(Name=\"AllOff\", value=0)\n    all_scheds[\"AllOn\"] = always_on_schedule\n    all_scheds[\"AllOff\"] = always_off_schedule\n    year, *_ = always_on_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n    year, *_ = always_off_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n\n    always_on_schedule = Schedule.constant_schedule(Name=\"AlwaysOn\", value=1)\n    always_off_schedule = Schedule.constant_schedule(Name=\"AlwaysOff\", value=0)\n    all_scheds[\"AlwaysOn\"] = always_on_schedule\n    all_scheds[\"AlwaysOff\"] = always_off_schedule\n    year, *_ = always_on_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n    year, *_ = always_off_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n\n    return idf, all_scheds\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.add_default_sim_controls","title":"<code>add_default_sim_controls(idf)</code>","text":"<p>Helper to add default simulation controls to the IDF model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the simulation controls to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The IDF model with the added simulation controls.</p> Source code in <code>epinterface\\interface.py</code> <pre><code>def add_default_sim_controls(idf: IDF) -&gt; IDF:\n    \"\"\"Helper to add default simulation controls to the IDF model.\n\n    Args:\n        idf (IDF): The IDF model to add the simulation controls to.\n\n    Returns:\n        IDF: The IDF model with the added simulation controls.\n    \"\"\"\n    # Configure simulation\n    sim_control = SimulationControl(\n        Do_Zone_Sizing_Calculation=\"Yes\",\n        Do_System_Sizing_Calculation=\"Yes\",\n        Do_Plant_Sizing_Calculation=\"Yes\",\n        Run_Simulation_for_Sizing_Periods=\"Yes\",\n        Run_Simulation_for_Weather_File_Run_Periods=\"Yes\",\n        Do_HVAC_Sizing_Simulation_for_Sizing_Periods=\"Yes\",\n        Maximum_Number_of_HVAC_Sizing_Simulation_Passes=2,\n    )\n    sim_control.add(idf)\n\n    # Configure run period\n    run_period = RunPeriod(\n        Name=\"Year\",\n        Use_Weather_File_Daylight_Saving_Period=\"No\",\n        Use_Weather_File_Rain_Indicators=\"No\",\n        Use_Weather_File_Snow_Indicators=\"No\",\n        Use_Weather_File_Holidays_and_Special_Days=\"No\",\n        Begin_Month=1,\n        Begin_Day_of_Month=1,\n        End_Month=12,\n        End_Day_of_Month=31,\n        Day_of_Week_for_Start_Day=\"Sunday\",\n    )\n    run_period.add(idf)\n\n    # configure timestep\n    timestep = Timestep(\n        Number_of_Timesteps_per_Hour=6,\n    )\n    timestep.add(idf)\n\n    sizing = SizingParameters(\n        Heating_Sizing_Factor=1.15,\n        Cooling_Sizing_Factor=1.15,\n    )\n    sizing.add(idf)\n\n    return idf\n</code></pre>"},{"location":"modules/weather/","title":"Weather","text":"<p>Weather file fetching and caching.</p>"},{"location":"modules/weather/#epinterface.weather.BaseWeather","title":"<code>BaseWeather</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A base class for fetching weather files.</p> <p>Responsible for fetching weather files from a URL and extracting the .epw and .ddy files.</p> <p>Also takes care of caching the weather files in a directory.</p> Source code in <code>epinterface\\weather.py</code> <pre><code>class BaseWeather(BaseModel):\n    \"\"\"A base class for fetching weather files.\n\n    Responsible for fetching weather files from a URL and extracting the .epw and .ddy files.\n\n    Also takes care of caching the weather files in a directory.\n    \"\"\"\n\n    Weather: WeatherUrl = Field(\n        default=WeatherUrl(  # pyright: ignore [reportCallIssue]\n            \"https://climate.onebuilding.org/WMO_Region_4_North_and_Central_America/USA_United_States_of_America/MA_Massachusetts/USA_MA_Boston-Logan.Intl.AP.725090_TMYx.2009-2023.zip\"\n        )\n    )\n\n    async def fetch_weather(self, cache_dir: Path | str):\n        \"\"\"Fetch the weather file from the URL and extract the .epw and .ddy files.\n\n        Args:\n            cache_dir (Path | str): The directory to cache the weather files.\n\n        Returns:\n            epw_path (Path): The path to the .epw file.\n            ddy_path (Path): The path to the .ddy file.\n        \"\"\"\n        if isinstance(cache_dir, str):\n            cache_dir = Path(cache_dir)\n\n        if not self.Weather.path or not self.Weather.path.endswith(\".zip\"):\n            raise NotAZipError()\n\n        weather_path = Path(self.Weather.path).relative_to(\"/\")\n        weather_dir = cache_dir / weather_path.with_suffix(\"\")\n        epw_path = weather_dir / weather_path.with_suffix(\".epw\").name\n        ddy_path = weather_dir / weather_path.with_suffix(\".ddy\").name\n        weather_dir.mkdir(parents=True, exist_ok=True)\n        if not epw_path.exists() or not ddy_path.exists():\n            logger.info(f\"Fetching weather file from {self.Weather}\")\n            # fetch the .zip file, unzip it, and extract the .epw and .ddy files\n            client = httpx.AsyncClient()\n            response = await client.get(str(self.Weather))\n            with tempfile.TemporaryFile() as f:\n                f.write(response.content)\n                f.seek(0)\n                with zipfile.ZipFile(f, \"r\") as z:\n                    # z.extractall(weather_dir)\n                    z.extract(epw_path.name, weather_dir)\n                    z.extract(ddy_path.name, weather_dir)\n            await client.aclose()\n        else:\n            logger.info(f\"Using cached weather file from {weather_dir}\")\n        return epw_path, ddy_path\n</code></pre>"},{"location":"modules/weather/#epinterface.weather.BaseWeather.fetch_weather","title":"<code>fetch_weather(cache_dir)</code>  <code>async</code>","text":"<p>Fetch the weather file from the URL and extract the .epw and .ddy files.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>Path | str</code> <p>The directory to cache the weather files.</p> required <p>Returns:</p> Name Type Description <code>epw_path</code> <code>Path</code> <p>The path to the .epw file.</p> <code>ddy_path</code> <code>Path</code> <p>The path to the .ddy file.</p> Source code in <code>epinterface\\weather.py</code> <pre><code>async def fetch_weather(self, cache_dir: Path | str):\n    \"\"\"Fetch the weather file from the URL and extract the .epw and .ddy files.\n\n    Args:\n        cache_dir (Path | str): The directory to cache the weather files.\n\n    Returns:\n        epw_path (Path): The path to the .epw file.\n        ddy_path (Path): The path to the .ddy file.\n    \"\"\"\n    if isinstance(cache_dir, str):\n        cache_dir = Path(cache_dir)\n\n    if not self.Weather.path or not self.Weather.path.endswith(\".zip\"):\n        raise NotAZipError()\n\n    weather_path = Path(self.Weather.path).relative_to(\"/\")\n    weather_dir = cache_dir / weather_path.with_suffix(\"\")\n    epw_path = weather_dir / weather_path.with_suffix(\".epw\").name\n    ddy_path = weather_dir / weather_path.with_suffix(\".ddy\").name\n    weather_dir.mkdir(parents=True, exist_ok=True)\n    if not epw_path.exists() or not ddy_path.exists():\n        logger.info(f\"Fetching weather file from {self.Weather}\")\n        # fetch the .zip file, unzip it, and extract the .epw and .ddy files\n        client = httpx.AsyncClient()\n        response = await client.get(str(self.Weather))\n        with tempfile.TemporaryFile() as f:\n            f.write(response.content)\n            f.seek(0)\n            with zipfile.ZipFile(f, \"r\") as z:\n                # z.extractall(weather_dir)\n                z.extract(epw_path.name, weather_dir)\n                z.extract(ddy_path.name, weather_dir)\n        await client.aclose()\n    else:\n        logger.info(f\"Using cached weather file from {weather_dir}\")\n    return epw_path, ddy_path\n</code></pre>"},{"location":"modules/weather/#epinterface.weather.NotAZipError","title":"<code>NotAZipError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a URL does not end with a .zip extension.</p> Source code in <code>epinterface\\weather.py</code> <pre><code>class NotAZipError(ValueError):\n    \"\"\"Raised when a URL does not end with a .zip extension.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the error.\"\"\"\n        super().__init__(\"The URL provided does not end with a .zip extension.\")\n</code></pre>"},{"location":"modules/weather/#epinterface.weather.NotAZipError.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the error.</p> Source code in <code>epinterface\\weather.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the error.\"\"\"\n    super().__init__(\"The URL provided does not end with a .zip extension.\")\n</code></pre>"},{"location":"modules/weather/#epinterface.weather.check_path_ends_with_zip","title":"<code>check_path_ends_with_zip(url)</code>","text":"<p>Check that the path of the URL ends with a .zip extension.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>AnyUrl</code> <p>The URL to check.</p> required <p>Raises:</p> Type Description <code>NotAZipError</code> <p>If the URL does not end with a .zip extension.</p> <p>Returns:</p> Name Type Description <code>url</code> <code>AnyUrl</code> <p>The URL.</p> Source code in <code>epinterface\\weather.py</code> <pre><code>def check_path_ends_with_zip(url: AnyUrl):\n    \"\"\"Check that the path of the URL ends with a .zip extension.\n\n    Args:\n        url (AnyUrl): The URL to check.\n\n    Raises:\n        NotAZipError: If the URL does not end with a .zip extension.\n\n    Returns:\n        url (AnyUrl): The URL.\n    \"\"\"\n    if not url.path:\n        raise NotAZipError()\n    if not url.path.endswith(\".zip\"):\n        raise NotAZipError()\n    return url\n</code></pre>"}]}