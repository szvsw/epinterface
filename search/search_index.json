{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"epinterface","text":"<p>This is a repository for dynamically generating energy models within Python, relying on Archetypal and Eppy for most of its functionality.</p>"},{"location":"cli/","title":"CLI","text":"<p>A CLI is provided to assist with dev workflows as well as component library database creation and more.</p> <p>The CLI is installed as <code>epinterface</code> or <code>epi</code> in your environment.</p>"},{"location":"cli/#epi","title":"epi","text":"<p>CLI for epinterface.</p> <p>Usage:</p> <pre><code>epi [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre> <p>Subcommands</p> <ul> <li>components: Commands for working with components</li> <li>db: Commands for working with epinterface databases.</li> <li>prisma: Commands related to Prisma ORM for epinterface.</li> </ul>"},{"location":"cli/#epi-components","title":"epi components","text":"<p>Commands for working with components</p> <p>Usage:</p> <pre><code>epi components [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre> <p>Subcommands</p> <ul> <li>check: Check if all semantic field combinations resolve to a valid zone component.  Will randomly sample the semantic fields as listed in the semantic fields file.</li> <li>template: Create a yaml template file for entering component maps.</li> </ul>"},{"location":"cli/#epi-components-check","title":"epi components check","text":"<p>Check if all semantic field combinations resolve to a valid zone component.  Will randomly sample the semantic fields as listed in the semantic fields file.</p> <p>Usage:</p> <pre><code>epi components check [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --component-map-path PATH\n  --semantic-fields-path PATH\n  --db-path PATH\n  --max-tests INTEGER\n  --help                       Show this message and exit.\n</code></pre>"},{"location":"cli/#epi-components-template","title":"epi components template","text":"<p>Create a yaml template file for entering component maps.</p> <p>Usage:</p> <pre><code>epi components template [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --path PATH\n  --help       Show this message and exit.\n</code></pre>"},{"location":"cli/#epi-db","title":"epi db","text":"<p>Commands for working with epinterface databases.</p> <p>Usage:</p> <pre><code>epi db [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre> <p>Subcommands</p> <ul> <li>convert: Convert an excel file to a database file.</li> <li>make: Create a new database file at the given path.</li> </ul>"},{"location":"cli/#epi-db-convert","title":"epi db convert","text":"<p>Convert an excel file to a database file.</p> <p>Usage:</p> <pre><code>epi db convert [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --excel-path PATH  The excel file should be a template excel file.  See\n                     https://github.com/mitsustainabledesignlab/epinterface\n                     for more info.\n  --db-path PATH     The database file will be created at the given path.  If\n                     the file already exists, an error will be raised.\n  --help             Show this message and exit.\n</code></pre>"},{"location":"cli/#epi-db-make","title":"epi db make","text":"<p>Create a new database file at the given path.</p> <p>Usage:</p> <pre><code>epi db make [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --path PATH\n  --if-exists [raise|overwrite|ignore]\n                                  What to do if the database file already\n                                  exists. 'raise' will raise an error,\n                                  'overwrite' will create a new empty\n                                  database, 'migrate' will preserve the data\n                                  and apply any schema changes, 'ignore' will\n                                  use the existing database as-is.\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"cli/#epi-prisma","title":"epi prisma","text":"<p>Commands related to Prisma ORM for epinterface.</p> <p>Usage:</p> <pre><code>epi prisma [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre> <p>Subcommands</p> <ul> <li>generate: Generate the prisma client for epinterface.</li> <li>partials-path: Return the path to the prisma partials file. This is useful for passing the <code>--partials</code> flag to <code>prisma &lt;subcommand&gt;</code>.</li> <li>schemapath: Return the path to the prisma schema file. This is useful for passing the <code>--schema</code> flag to <code>prisma &lt;subcommand&gt;</code>.</li> </ul>"},{"location":"cli/#epi-prisma-generate","title":"epi prisma generate","text":"<p>Generate the prisma client for epinterface.</p> <p>Usage:</p> <pre><code>epi prisma generate [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"cli/#epi-prisma-partials-path","title":"epi prisma partials-path","text":"<p>Return the path to the prisma partials file. This is useful for passing the <code>--partials</code> flag to <code>prisma &lt;subcommand&gt;</code>.</p> <p>Usage:</p> <pre><code>epi prisma partials-path [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"cli/#epi-prisma-schemapath","title":"epi prisma schemapath","text":"<p>Return the path to the prisma schema file. This is useful for passing the <code>--schema</code> flag to <code>prisma &lt;subcommand&gt;</code>.</p> <p>Usage:</p> <pre><code>epi prisma schemapath [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"modules/actions/","title":"Actions","text":"<p>Actions are a way to mutate an object, typically used for defining retrofits for building energy models in this library.</p> <p>Actions to modify a library object.</p>"},{"location":"modules/actions/#epinterface.actions.Action","title":"<code>Action</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>An action to modify a library object.</p> <p>This base class should be inherited by classes that represent actions to modify a library object. It provides an abstract method <code>run</code> that should be implemented by subclasses to perform the modification.</p> Source code in <code>epinterface/actions.py</code> <pre><code>class Action(BaseModel, Generic[T]):\n    \"\"\"An action to modify a library object.\n\n    This base class should be inherited by classes that represent actions to modify\n    a library object. It provides an abstract method `run` that should be implemented\n    by subclasses to perform the modification.\n    \"\"\"\n\n    target: ParameterPath[T] = Field(\n        ..., description=\"The path to the parameter to modify.\"\n    )\n    priority: Priority | None = Field(\n        default=None,\n        description=\"The priority of the action (low will execute if the new value is less than the old value).\",\n    )\n\n    def run(self, lib: LibT) -&gt; LibT:\n        \"\"\"Run the action to modify the library object.\n\n        Args:\n            lib (LibT): The library object to modify.\n\n        Returns:\n            lib (LibT): The modified library object.\n        \"\"\"\n        new_val = self.new_val(lib)\n        original_val = self.get_original_val(lib)\n        if self.check_priority(original_val, new_val):\n            original_obj = self.get_original_obj(lib)\n            key = self.original_key\n            set_dict_val_or_attr(original_obj, key, new_val)\n        return lib\n\n    def check_priority(self, original: T, new: T) -&gt; bool:\n        \"\"\"Check if the new value should be applied based on the action priority.\n\n        Args:\n            original (T): The original value in the library object.\n            new (T): The new value to apply.\n\n        Returns:\n            apply (bool): True if the new value should be applied, False otherwise.\n        \"\"\"\n        if self.priority is None:\n            return True\n\n        if not isinstance(original, int | float) or not isinstance(new, int | float):\n            msg = \"priority comparison only supported for numerical values.\"\n            raise TypeError(msg)\n\n        if self.priority == \"low\":\n            return original &gt; new\n\n        elif self.priority == \"high\":\n            return original &lt; new\n        else:\n            msg = f\"Invalid priority value: {self.priority}\"\n            raise ValueError(msg)\n\n    def get_original_val(self, lib: LibT) -&gt; T:\n        \"\"\"Retrieve the original value from the library object.\n\n        Args:\n            lib (LibT): The library object from which to retrieve the original value.\n\n        Returns:\n            val (T): The original value from the library object.\n        \"\"\"\n        return self.target.get_lib_val(lib)\n\n    @property\n    def original_key(self) -&gt; str | int | ParameterPath:\n        \"\"\"Retrieve the key of the original value in the library object.\n\n        Returns:\n            key (str | int | ParameterPath): The key of the original value in the library object.\n        \"\"\"\n        # TODO: handle cases where final key is a ParameterPath!!\n        return self.target.path[-1]\n\n    def get_original_obj(self, lib: LibT):\n        \"\"\"Retrieve the object containing the original value in the library object.\n\n        Args:\n            lib (LibT): The library object from which to retrieve the original object.\n\n        Returns:\n            obj (Any): The object containing the original value in the library object.\n        \"\"\"\n        return self.target.parent_path.get_lib_val(lib)\n\n    @abstractmethod\n    def new_val(self, lib: LibT) -&gt; T:\n        \"\"\"Calculate the new value to apply to the library object.\n\n        NB: This method should be implemented by subclasses to calculate the new value.\n\n        Args:\n            lib (LibT): The library object on which to apply the new value.\n\n        Returns:\n            val (T): The new value to apply to the library object.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.Action.original_key","title":"<code>original_key</code>  <code>property</code>","text":"<p>Retrieve the key of the original value in the library object.</p> <p>Returns:</p> Name Type Description <code>key</code> <code>str | int | ParameterPath</code> <p>The key of the original value in the library object.</p>"},{"location":"modules/actions/#epinterface.actions.Action.check_priority","title":"<code>check_priority(original, new)</code>","text":"<p>Check if the new value should be applied based on the action priority.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>T</code> <p>The original value in the library object.</p> required <code>new</code> <code>T</code> <p>The new value to apply.</p> required <p>Returns:</p> Name Type Description <code>apply</code> <code>bool</code> <p>True if the new value should be applied, False otherwise.</p> Source code in <code>epinterface/actions.py</code> <pre><code>def check_priority(self, original: T, new: T) -&gt; bool:\n    \"\"\"Check if the new value should be applied based on the action priority.\n\n    Args:\n        original (T): The original value in the library object.\n        new (T): The new value to apply.\n\n    Returns:\n        apply (bool): True if the new value should be applied, False otherwise.\n    \"\"\"\n    if self.priority is None:\n        return True\n\n    if not isinstance(original, int | float) or not isinstance(new, int | float):\n        msg = \"priority comparison only supported for numerical values.\"\n        raise TypeError(msg)\n\n    if self.priority == \"low\":\n        return original &gt; new\n\n    elif self.priority == \"high\":\n        return original &lt; new\n    else:\n        msg = f\"Invalid priority value: {self.priority}\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.Action.get_original_obj","title":"<code>get_original_obj(lib)</code>","text":"<p>Retrieve the object containing the original value in the library object.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library object from which to retrieve the original object.</p> required <p>Returns:</p> Name Type Description <code>obj</code> <code>Any</code> <p>The object containing the original value in the library object.</p> Source code in <code>epinterface/actions.py</code> <pre><code>def get_original_obj(self, lib: LibT):\n    \"\"\"Retrieve the object containing the original value in the library object.\n\n    Args:\n        lib (LibT): The library object from which to retrieve the original object.\n\n    Returns:\n        obj (Any): The object containing the original value in the library object.\n    \"\"\"\n    return self.target.parent_path.get_lib_val(lib)\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.Action.get_original_val","title":"<code>get_original_val(lib)</code>","text":"<p>Retrieve the original value from the library object.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library object from which to retrieve the original value.</p> required <p>Returns:</p> Name Type Description <code>val</code> <code>T</code> <p>The original value from the library object.</p> Source code in <code>epinterface/actions.py</code> <pre><code>def get_original_val(self, lib: LibT) -&gt; T:\n    \"\"\"Retrieve the original value from the library object.\n\n    Args:\n        lib (LibT): The library object from which to retrieve the original value.\n\n    Returns:\n        val (T): The original value from the library object.\n    \"\"\"\n    return self.target.get_lib_val(lib)\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.Action.new_val","title":"<code>new_val(lib)</code>  <code>abstractmethod</code>","text":"<p>Calculate the new value to apply to the library object.</p> <p>NB: This method should be implemented by subclasses to calculate the new value.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library object on which to apply the new value.</p> required <p>Returns:</p> Name Type Description <code>val</code> <code>T</code> <p>The new value to apply to the library object.</p> Source code in <code>epinterface/actions.py</code> <pre><code>@abstractmethod\ndef new_val(self, lib: LibT) -&gt; T:\n    \"\"\"Calculate the new value to apply to the library object.\n\n    NB: This method should be implemented by subclasses to calculate the new value.\n\n    Args:\n        lib (LibT): The library object on which to apply the new value.\n\n    Returns:\n        val (T): The new value to apply to the library object.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.Action.run","title":"<code>run(lib)</code>","text":"<p>Run the action to modify the library object.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library object to modify.</p> required <p>Returns:</p> Name Type Description <code>lib</code> <code>LibT</code> <p>The modified library object.</p> Source code in <code>epinterface/actions.py</code> <pre><code>def run(self, lib: LibT) -&gt; LibT:\n    \"\"\"Run the action to modify the library object.\n\n    Args:\n        lib (LibT): The library object to modify.\n\n    Returns:\n        lib (LibT): The modified library object.\n    \"\"\"\n    new_val = self.new_val(lib)\n    original_val = self.get_original_val(lib)\n    if self.check_priority(original_val, new_val):\n        original_obj = self.get_original_obj(lib)\n        key = self.original_key\n        set_dict_val_or_attr(original_obj, key, new_val)\n    return lib\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.ActionLibrary","title":"<code>ActionLibrary</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A library of action sequences, e.g. to represent deep and shallow retrofits for different types of buildings.</p> Source code in <code>epinterface/actions.py</code> <pre><code>class ActionLibrary(BaseModel):\n    \"\"\"A library of action sequences, e.g. to represent deep and shallow retrofits for different types of buildings.\"\"\"\n\n    name: str = Field(..., description=\"The name of the action library.\")\n    actions: list[ActionSequence] = Field(\n        ..., description=\"A list of action sequences to perform on a library object.\"\n    )\n\n    @model_validator(mode=\"after\")\n    def check_action_names_are_unique(self):\n        \"\"\"Check that the names of the action sequences in the action library are unique.\n\n        Raises:\n            ValueError: If the names of the action sequences are not unique.\n        \"\"\"\n        action_names = self.action_names\n        if len(action_names) != len(set(action_names)):\n            msg = f\"Action names must be unique: {', '.join(action_names)}\"\n            raise ValueError(msg)\n        return self\n\n    @property\n    def action_names(self):\n        \"\"\"Return the names of the action sequences in the action library.\n\n        Returns:\n            action_names (list[str]): The names of the action sequences in the action\n        \"\"\"\n        return [action.name for action in self.actions]\n\n    def get(self, name: str) -&gt; ActionSequence:\n        \"\"\"Retrieve an action sequence by name.\n\n        Args:\n            name (str): The name of the action sequence to retrieve.\n\n        Returns:\n            action (ActionSequence): The action sequence with the specified name.\n\n        Raises:\n            KeyError: If the action sequence with the specified name is not found in the action library.\n        \"\"\"\n        if name in self.action_names:\n            return self.actions[self.action_names.index(name)]\n        else:\n            msg = f\"Action sequence not found: {name}\\nAvailable action sequences: {', '.join(self.action_names)}\"\n            raise KeyError(msg)\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.ActionLibrary.action_names","title":"<code>action_names</code>  <code>property</code>","text":"<p>Return the names of the action sequences in the action library.</p> <p>Returns:</p> Name Type Description <code>action_names</code> <code>list[str]</code> <p>The names of the action sequences in the action</p>"},{"location":"modules/actions/#epinterface.actions.ActionLibrary.check_action_names_are_unique","title":"<code>check_action_names_are_unique()</code>","text":"<p>Check that the names of the action sequences in the action library are unique.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the names of the action sequences are not unique.</p> Source code in <code>epinterface/actions.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_action_names_are_unique(self):\n    \"\"\"Check that the names of the action sequences in the action library are unique.\n\n    Raises:\n        ValueError: If the names of the action sequences are not unique.\n    \"\"\"\n    action_names = self.action_names\n    if len(action_names) != len(set(action_names)):\n        msg = f\"Action names must be unique: {', '.join(action_names)}\"\n        raise ValueError(msg)\n    return self\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.ActionLibrary.get","title":"<code>get(name)</code>","text":"<p>Retrieve an action sequence by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the action sequence to retrieve.</p> required <p>Returns:</p> Name Type Description <code>action</code> <code>ActionSequence</code> <p>The action sequence with the specified name.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the action sequence with the specified name is not found in the action library.</p> Source code in <code>epinterface/actions.py</code> <pre><code>def get(self, name: str) -&gt; ActionSequence:\n    \"\"\"Retrieve an action sequence by name.\n\n    Args:\n        name (str): The name of the action sequence to retrieve.\n\n    Returns:\n        action (ActionSequence): The action sequence with the specified name.\n\n    Raises:\n        KeyError: If the action sequence with the specified name is not found in the action library.\n    \"\"\"\n    if name in self.action_names:\n        return self.actions[self.action_names.index(name)]\n    else:\n        msg = f\"Action sequence not found: {name}\\nAvailable action sequences: {', '.join(self.action_names)}\"\n        raise KeyError(msg)\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.ActionSequence","title":"<code>ActionSequence</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A sequence of actions to perform on a library object.</p> Source code in <code>epinterface/actions.py</code> <pre><code>class ActionSequence(BaseModel):\n    \"\"\"A sequence of actions to perform on a library object.\"\"\"\n\n    name: str = Field(..., description=\"The name of the action sequence.\")\n    actions: list[\n        \"DeltaVal | ReplaceWithExisting | ReplaceWithVal | ActionSequence\"\n    ] = Field(  # TODO: should we allow nested actionsequences?\n        ..., description=\"A sequence of actions to perform on a library object.\"\n    )\n\n    def run(self, lib: LibT) -&gt; LibT:\n        \"\"\"Run the sequence of actions on the library object.\n\n        Args:\n            lib (LibT): The library object to modify.\n\n        Returns:\n            lib (LibT): The modified library object.\n        \"\"\"\n        for action in self.actions:\n            lib = action.run(lib)\n        return lib\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.ActionSequence.run","title":"<code>run(lib)</code>","text":"<p>Run the sequence of actions on the library object.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library object to modify.</p> required <p>Returns:</p> Name Type Description <code>lib</code> <code>LibT</code> <p>The modified library object.</p> Source code in <code>epinterface/actions.py</code> <pre><code>def run(self, lib: LibT) -&gt; LibT:\n    \"\"\"Run the sequence of actions on the library object.\n\n    Args:\n        lib (LibT): The library object to modify.\n\n    Returns:\n        lib (LibT): The modified library object.\n    \"\"\"\n    for action in self.actions:\n        lib = action.run(lib)\n    return lib\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.DeltaVal","title":"<code>DeltaVal</code>","text":"<p>               Bases: <code>Action[Numeric]</code></p> <p>Add a value to a parameter in a library object.</p> Source code in <code>epinterface/actions.py</code> <pre><code>class DeltaVal(Action[Numeric]):\n    \"\"\"Add a value to a parameter in a library object.\"\"\"\n\n    delta: Numeric = Field(\n        ..., description=\"The value to modify to the original value.\"\n    )\n    op: Operation = Field(\n        ..., description=\"The operation to perform on the original value.\"\n    )\n\n    def new_val(self, lib: LibT) -&gt; Numeric:\n        \"\"\"Calculate a new value by combining the original value from the given library with a delta.\n\n        Args:\n            lib (LibT): The library from which to retrieve the original value.\n\n        Returns:\n            new_val (Numeric): The new value obtained by combining the original value with the delta.\n        \"\"\"\n        original_val = self.get_original_val(lib)\n\n        return self.combine(original_val, self.delta)\n\n    @property\n    def combine(self) -&gt; Callable[[Numeric, Numeric], Numeric]:\n        \"\"\"Combines two numeric values based on the specified operation.\n\n        Supported operations:\n            - \"+\": Addition\n            - \"*\": Multiplication\n\n        Returns:\n            fn (Callable[[Numeric, Numeric], Numeric]): A function that takes two numeric arguments and returns a numeric result.\n\n        Raises:\n            ValueError: If the operation specified by `self.op` is not supported.\n\n        \"\"\"\n        if self.op == \"+\":\n            return lambda x, y: x + y\n        elif self.op == \"*\":\n            return lambda x, y: x * y\n        else:\n            msg = f\"Invalid operation: {self.op}\"\n            raise ValueError(msg)\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.DeltaVal.combine","title":"<code>combine</code>  <code>property</code>","text":"<p>Combines two numeric values based on the specified operation.</p> Supported operations <ul> <li>\"+\": Addition</li> <li>\"*\": Multiplication</li> </ul> <p>Returns:</p> Name Type Description <code>fn</code> <code>Callable[[Numeric, Numeric], Numeric]</code> <p>A function that takes two numeric arguments and returns a numeric result.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operation specified by <code>self.op</code> is not supported.</p>"},{"location":"modules/actions/#epinterface.actions.DeltaVal.new_val","title":"<code>new_val(lib)</code>","text":"<p>Calculate a new value by combining the original value from the given library with a delta.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library from which to retrieve the original value.</p> required <p>Returns:</p> Name Type Description <code>new_val</code> <code>Numeric</code> <p>The new value obtained by combining the original value with the delta.</p> Source code in <code>epinterface/actions.py</code> <pre><code>def new_val(self, lib: LibT) -&gt; Numeric:\n    \"\"\"Calculate a new value by combining the original value from the given library with a delta.\n\n    Args:\n        lib (LibT): The library from which to retrieve the original value.\n\n    Returns:\n        new_val (Numeric): The new value obtained by combining the original value with the delta.\n    \"\"\"\n    original_val = self.get_original_val(lib)\n\n    return self.combine(original_val, self.delta)\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.ParameterPath","title":"<code>ParameterPath</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>Pathing to find a parameter in a library/object.</p> <p>ParameterPath is a generic class that represents a path consisting of strings, integers, or other ParameterPath instances. It provides methods to resolve the path and retrieve values from a given library.</p> Source code in <code>epinterface/actions.py</code> <pre><code>class ParameterPath(BaseModel, Generic[T]):\n    \"\"\"Pathing to find a parameter in a library/object.\n\n    ParameterPath is a generic class that represents a path consisting of strings, integers,\n    or other ParameterPath instances. It provides methods to resolve the path and retrieve\n    values from a given library.\n    \"\"\"\n\n    path: list[\"str | int | ParameterPath\"] = Field(\n        ..., description=\"The path to the parameter to select.\"\n    )\n\n    def resolved_path(self, lib: LibT):\n        \"\"\"Resolve the path to the parameter in the library.\n\n        Args:\n            lib (LibT): The library to search for the parameter.\n\n        Returns:\n            path (list[Any]): The resolved path to the parameter in the library.\n        \"\"\"\n        return [\n            p if isinstance(p, str | int) else p.get_lib_val(lib) for p in self.path\n        ]\n\n    def get_lib_val(self, lib: LibT) -&gt; T:\n        \"\"\"Retrieves a value from a nested dictionary or object attribute path.\n\n        Args:\n            lib (LibT): The library object from which to retrieve the value.\n\n        Returns:\n            val (T): The value retrieved from the nested dictionary or object attribute path.\n        \"\"\"\n        return cast(T, reduce(get_dict_val_or_attr, self.resolved_path(lib), lib))\n\n    @property\n    def parent_path(self):\n        \"\"\"Returns the parent path of the current path.\n\n        Returns:\n            parent_path (ParameterPath): The parent path of the current path.\n        \"\"\"\n        # TODO: how can we type-narrow the generic parameterpath here?\n        # get the parent using the similar reduction technique as before\n        return ParameterPath[Any](path=self.path[:-1])\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.ParameterPath.parent_path","title":"<code>parent_path</code>  <code>property</code>","text":"<p>Returns the parent path of the current path.</p> <p>Returns:</p> Name Type Description <code>parent_path</code> <code>ParameterPath</code> <p>The parent path of the current path.</p>"},{"location":"modules/actions/#epinterface.actions.ParameterPath.get_lib_val","title":"<code>get_lib_val(lib)</code>","text":"<p>Retrieves a value from a nested dictionary or object attribute path.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library object from which to retrieve the value.</p> required <p>Returns:</p> Name Type Description <code>val</code> <code>T</code> <p>The value retrieved from the nested dictionary or object attribute path.</p> Source code in <code>epinterface/actions.py</code> <pre><code>def get_lib_val(self, lib: LibT) -&gt; T:\n    \"\"\"Retrieves a value from a nested dictionary or object attribute path.\n\n    Args:\n        lib (LibT): The library object from which to retrieve the value.\n\n    Returns:\n        val (T): The value retrieved from the nested dictionary or object attribute path.\n    \"\"\"\n    return cast(T, reduce(get_dict_val_or_attr, self.resolved_path(lib), lib))\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.ParameterPath.resolved_path","title":"<code>resolved_path(lib)</code>","text":"<p>Resolve the path to the parameter in the library.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library to search for the parameter.</p> required <p>Returns:</p> Name Type Description <code>path</code> <code>list[Any]</code> <p>The resolved path to the parameter in the library.</p> Source code in <code>epinterface/actions.py</code> <pre><code>def resolved_path(self, lib: LibT):\n    \"\"\"Resolve the path to the parameter in the library.\n\n    Args:\n        lib (LibT): The library to search for the parameter.\n\n    Returns:\n        path (list[Any]): The resolved path to the parameter in the library.\n    \"\"\"\n    return [\n        p if isinstance(p, str | int) else p.get_lib_val(lib) for p in self.path\n    ]\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.ReplaceWithExisting","title":"<code>ReplaceWithExisting</code>","text":"<p>               Bases: <code>Action[T]</code></p> <p>Replace a value in a library object with a value from another location in the library.</p> Source code in <code>epinterface/actions.py</code> <pre><code>class ReplaceWithExisting(Action[T]):\n    \"\"\"Replace a value in a library object with a value from another location in the library.\"\"\"\n\n    source: ParameterPath[T]\n\n    def new_val(self, lib: LibT) -&gt; T:\n        \"\"\"Retrieve the value from the source path to replace the target value.\n\n        Args:\n            lib (LibT): The library object from which to retrieve the new value.\n\n        Returns:\n            val (T): The new value to replace the target value.\n        \"\"\"\n        return self.source.get_lib_val(lib)\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.ReplaceWithExisting.new_val","title":"<code>new_val(lib)</code>","text":"<p>Retrieve the value from the source path to replace the target value.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>The library object from which to retrieve the new value.</p> required <p>Returns:</p> Name Type Description <code>val</code> <code>T</code> <p>The new value to replace the target value.</p> Source code in <code>epinterface/actions.py</code> <pre><code>def new_val(self, lib: LibT) -&gt; T:\n    \"\"\"Retrieve the value from the source path to replace the target value.\n\n    Args:\n        lib (LibT): The library object from which to retrieve the new value.\n\n    Returns:\n        val (T): The new value to replace the target value.\n    \"\"\"\n    return self.source.get_lib_val(lib)\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.ReplaceWithVal","title":"<code>ReplaceWithVal</code>","text":"<p>               Bases: <code>Action[T]</code></p> <p>Replace a value in a library object with a new value.</p> Source code in <code>epinterface/actions.py</code> <pre><code>class ReplaceWithVal(Action[T]):\n    \"\"\"Replace a value in a library object with a new value.\"\"\"\n\n    val: T\n\n    def new_val(self, lib: LibT) -&gt; T:\n        \"\"\"Returns the current value of the instance to use for updating.\n\n        Args:\n            lib (LibT): A library instance of type LibT.\n\n        Returns:\n            val (T): The current value of the instance.\n        \"\"\"\n        return self.val\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.ReplaceWithVal.new_val","title":"<code>new_val(lib)</code>","text":"<p>Returns the current value of the instance to use for updating.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>LibT</code> <p>A library instance of type LibT.</p> required <p>Returns:</p> Name Type Description <code>val</code> <code>T</code> <p>The current value of the instance.</p> Source code in <code>epinterface/actions.py</code> <pre><code>def new_val(self, lib: LibT) -&gt; T:\n    \"\"\"Returns the current value of the instance to use for updating.\n\n    Args:\n        lib (LibT): A library instance of type LibT.\n\n    Returns:\n        val (T): The current value of the instance.\n    \"\"\"\n    return self.val\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.get_dict_val_or_attr","title":"<code>get_dict_val_or_attr(obj, key)</code>","text":"<p>Retrieve a value from a dictionary or list, or an attribute from an object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[dict, list, Any]</code> <p>The object from which to retrieve the value or attribute.</p> required <code>key</code> <code>Any</code> <p>The key or attribute name to retrieve.</p> required <p>Returns:</p> Name Type Description <code>val</code> <code>Any</code> <p>The value associated with the key if <code>obj</code> is a dictionary or list,  or the attribute value if <code>obj</code> is an object.</p> Source code in <code>epinterface/actions.py</code> <pre><code>def get_dict_val_or_attr(obj, key):\n    \"\"\"Retrieve a value from a dictionary or list, or an attribute from an object.\n\n    Args:\n        obj (Union[dict, list, Any]): The object from which to retrieve the value or attribute.\n        key (Any): The key or attribute name to retrieve.\n\n    Returns:\n        val (Any): The value associated with the key if `obj` is a dictionary or list,\n             or the attribute value if `obj` is an object.\n    \"\"\"\n    if isinstance(obj, dict | list):\n        return obj[key]\n    else:\n        return getattr(obj, key)\n</code></pre>"},{"location":"modules/actions/#epinterface.actions.set_dict_val_or_attr","title":"<code>set_dict_val_or_attr(obj, key, val)</code>","text":"<p>Sets a value in a dictionary or list, or sets an attribute on an object.</p> <p>If the provided object is a dictionary or list, the function sets the value at the specified key or index. If the object is not a dictionary or list, the function sets an attribute on the object with the specified key and value.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[dict, list, object]</code> <p>The object to modify.</p> required <code>key</code> <code>Union[str, int]</code> <p>The key or attribute name to set.</p> required <code>val</code> <code>Any</code> <p>The value to set.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the object is a list and the key is not an integer.</p> Source code in <code>epinterface/actions.py</code> <pre><code>def set_dict_val_or_attr(obj, key, val):\n    \"\"\"Sets a value in a dictionary or list, or sets an attribute on an object.\n\n    If the provided object is a dictionary or list, the function sets the value\n    at the specified key or index. If the object is not a dictionary or list,\n    the function sets an attribute on the object with the specified key and value.\n\n    Args:\n        obj (Union[dict, list, object]): The object to modify.\n        key (Union[str, int]): The key or attribute name to set.\n        val (Any): The value to set.\n\n    Raises:\n        TypeError: If the object is a list and the key is not an integer.\n    \"\"\"\n    if isinstance(obj, dict | list):\n        obj[key] = val\n    else:\n        setattr(obj, key, val)\n</code></pre>"},{"location":"modules/builder/","title":"ClimateStudio Model Builder","text":"<p>A module for building the energy model using the Climate Studio API.</p>"},{"location":"modules/builder/#epinterface.climate_studio.builder.ClimateStudioBuilderNotImplementedError","title":"<code>ClimateStudioBuilderNotImplementedError</code>","text":"<p>               Bases: <code>NotImplementedError</code></p> <p>Raised when a parameter is not yet implemented in the climate studio shoebox builder.</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>class ClimateStudioBuilderNotImplementedError(NotImplementedError):\n    \"\"\"Raised when a parameter is not yet implemented in the climate studio shoebox builder.\"\"\"\n\n    def __init__(self, parameter: str):\n        \"\"\"Initialize the error.\n\n        Args:\n            parameter (str): The parameter that is not yet implemented.\n        \"\"\"\n        self.parameter = parameter\n        super().__init__(\n            f\"Parameter {parameter} is not yet implemented in the climate studio shoebox builder.\"\n        )\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.ClimateStudioBuilderNotImplementedError.__init__","title":"<code>__init__(parameter)</code>","text":"<p>Initialize the error.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>str</code> <p>The parameter that is not yet implemented.</p> required Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>def __init__(self, parameter: str):\n    \"\"\"Initialize the error.\n\n    Args:\n        parameter (str): The parameter that is not yet implemented.\n    \"\"\"\n    self.parameter = parameter\n    super().__init__(\n        f\"Parameter {parameter} is not yet implemented in the climate studio shoebox builder.\"\n    )\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>BaseWeather</code></p> <p>A simple model constructor for the IDF model.</p> <p>Creates geometry as well as zone definitions.</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>class Model(BaseWeather, validate_assignment=True):\n    \"\"\"A simple model constructor for the IDF model.\n\n    Creates geometry as well as zone definitions.\n    \"\"\"\n\n    geometry: ShoeboxGeometry\n    space_use_name: str\n    envelope_name: str\n    conditioned_basement: bool = False\n    lib: ClimateStudioLibraryV2\n\n    @property\n    def space_use(self) -&gt; ZoneUse:\n        \"\"\"The space use definition for the model.\"\"\"\n        if self.space_use_name not in self.lib.SpaceUses:\n            raise KeyError(f\"MISSING:SPACE_USE:{self.space_use_name}\")\n        return self.lib.SpaceUses[self.space_use_name]\n\n    @property\n    def envelope(self) -&gt; ZoneEnvelope:\n        \"\"\"The envelope definition for the model.\"\"\"\n        if self.envelope_name not in self.lib.Envelopes:\n            raise KeyError(f\"MISSING:ENVELOPE:{self.envelope_name}\")\n\n        return self.lib.Envelopes[self.envelope_name]\n\n    @property\n    def total_conditioned_area(self) -&gt; float:\n        \"\"\"The total conditioned area of the model.\n\n        Returns:\n            float: The total conditioned area of the model.\n        \"\"\"\n        return self.geometry.total_living_area + (\n            self.geometry.footprint_area\n            if self.geometry.basement and self.conditioned_basement\n            else 0\n        )\n\n    @property\n    def total_people(self) -&gt; float:\n        \"\"\"The total number of people in the model.\n\n        Returns:\n            ppl (float): The total number of people in the model\n\n        \"\"\"\n        ppl_per_m2 = (\n            self.space_use.Loads.PeopleDensity if self.space_use.Loads.PeopleIsOn else 0\n        )\n        total_area = self.total_conditioned_area\n        total_ppl = ppl_per_m2 * total_area\n        return total_ppl\n\n    def compute_dhw(self) -&gt; float:\n        \"\"\"Compute the domestic hot water energy demand.\n\n        Returns:\n            energy (float): The domestic hot water energy demand (kWh/m2)\n        \"\"\"\n        # TODO: this should be computed from the DHW schedule\n        if not self.space_use.HotWater.IsOn:\n            return 0\n        flow_rate_per_person = self.space_use.HotWater.FlowRatePerPerson  # m3/hr/person\n        temperature_rise = (\n            self.space_use.HotWater.WaterSupplyTemperature\n            - self.space_use.HotWater.WaterTemperatureInlet\n        )  # K\n        water_density = 1000  # kg/m3\n        c = 4186  # J/kg.K\n        total_flow_rate = flow_rate_per_person * self.total_people  # m3/hr\n        total_volume = total_flow_rate * 8760  # m3 / yr\n        total_energy = total_volume * temperature_rise * water_density * c  # J / yr\n        total_energy_kWh = total_energy / 3600000  # kWh / yr\n        total_energy_kWh_per_m2 = (\n            total_energy_kWh / self.total_conditioned_area\n        )  # kWh/m2 / yr\n        return total_energy_kWh_per_m2\n\n    def build(self, config: SimulationPathConfig) -&gt; IDF:\n        \"\"\"Build the energy model using the Climate Studio API.\n\n        Args:\n            config (SimulationConfig): The configuration for the simulation.\n\n        Returns:\n            IDF: The built energy model.\n        \"\"\"\n        if (not self.geometry.basement) and self.conditioned_basement:\n            raise ValueError(\"CONDITIONEDBASEMENT:TRUE:BASEMENT:FALSE\")\n\n        if self.geometry.roof_height:\n            raise ClimateStudioBuilderNotImplementedError(\"roof_height\")\n        config.output_dir.mkdir(parents=True, exist_ok=True)\n        base_filepath = EnergyPlusArtifactDir / \"Minimal.idf\"\n        target_base_filepath = config.output_dir / \"Minimal.idf\"\n        shutil.copy(base_filepath, target_base_filepath)\n        epw_path, ddy_path = self.fetch_weather(config.weather_dir)\n        idf = IDF(\n            target_base_filepath.as_posix(),\n            as_version=energyplus_settings.energyplus_version,  # pyright: ignore [reportArgumentType]\n            prep_outputs=True,\n            epw=epw_path.as_posix(),\n            output_directory=config.output_dir.as_posix(),\n        )\n        ddy = IDF(\n            ddy_path.as_posix(),\n            as_version=energyplus_settings.energyplus_version,\n            file_version=energyplus_settings.energyplus_version,\n            prep_outputs=False,\n        )\n        ddy_spec = DDYSizingSpec(\n            match=False, conditions_types=[\"Summer Extreme\", \"Winter Extreme\"]\n        )\n        ddy_spec.inject_ddy(idf, ddy)\n\n        idf = add_default_sim_controls(idf)\n        idf, scheds = add_default_schedules(idf)\n        self.lib.Schedules.update(scheds)\n\n        idf = SiteGroundTemperature.FromValues([\n            18.3,\n            18.2,\n            18.3,\n            18.4,\n            20.1,\n            22.0,\n            22.3,\n            22.5,\n            22.5,\n            20.7,\n            18.9,\n            18.5,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 18,\n            # 7.9,\n            # 6.05,\n            # 5.65,\n            # 6.21,\n            # 8.98,\n            # 11.97,\n            # 14.71,\n            # 16.62,\n            # 17.06,\n            # 15.98,\n            # 13.61,\n            # 10.71,\n            # 1.11,\n            # 0.1,\n            # 1.89,\n            # 4.69,\n            # 12.02,\n            # 17.68,\n            # 21.5,\n            # 22.66,\n            # 20.68,\n            # 16.29,\n            # 10.42,\n            # 4.97,\n        ]).add(idf)\n\n        idf = self.geometry.add(idf)\n\n        # construct zone lists\n        idf, conditioned_zone_list, all_zones_list = self.add_zone_lists(idf)\n\n        # TODO: Handle separately ventilated attic/basement?\n        idf = self.add_space_use(idf, self.space_use, conditioned_zone_list)\n        idf = self.add_envelope(idf, self.envelope, all_zones_list)\n\n        return idf\n\n    def add_hot_water_to_zone_list(\n        self, idf: IDF, space_use: ZoneUse, zone_list: ZoneList\n    ) -&gt; IDF:\n        \"\"\"Add the hot water to the zone list.\n\n        Args:\n            idf (IDF): The IDF model to add the hot water to.\n            space_use (ZoneUse): The zone use template.\n            zone_list (ZoneList): The list of zones to add the hot water to.\n\n        Returns:\n            idf (IDF): The IDF model with the added hot water.\n        \"\"\"\n        for zone_name in zone_list.Names:\n            idf = self.add_hot_water_to_zone(idf, space_use, zone_name)\n        return idf\n\n    def add_hot_water_to_zone(\n        self, idf: IDF, space_use: ZoneUse, zone_name: str\n    ) -&gt; IDF:\n        \"\"\"Add the hot water to the zone.\n\n        Args:\n            idf (IDF): The IDF model to add the hot water to.\n            space_use (ZoneUse): The zone use template.\n            zone_name (str): The name of the zone to add the hot water to.\n\n        Returns:\n            idf (IDF): The IDF model with the added hot water.\n        \"\"\"\n        zone = next(filter(lambda x: x.Name == zone_name, idf.idfobjects[\"ZONE\"]), None)\n        if zone is None:\n            raise ValueError(f\"NO_ZONE:{zone_name}\")\n        area = 0\n        area_ct = 0\n        for srf in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]:\n            if srf.Zone_Name == zone.Name and srf.Surface_Type.lower() == \"floor\":\n                poly = Polygon(srf.coords)\n                area += poly.area\n                area_ct += 1\n        if area_ct &gt; 1:\n            raise ValueError(f\"TOO_MANY_FLOORS:{zone.Name}\")\n        if area == 0 or area_ct == 0:\n            raise ValueError(f\"NO_AREA:{zone.Name}\")\n        ppl_density = space_use.Loads.PeopleDensity\n        total_ppl = ppl_density * area\n        idf = space_use.HotWater.add_water_to_idf_zone(idf, zone.Name, total_ppl)\n        return idf\n\n    def add_envelope(\n        self, idf: IDF, envelope: ZoneEnvelope, inf_zone_list: ZoneList\n    ) -&gt; IDF:\n        \"\"\"Add the envelope to the IDF model.\n\n        Takes care of both the constructions and infiltration and windows.\n\n        Args:\n            idf (IDF): The IDF model to add the envelope to.\n            envelope (ZoneEnvelope): The envelope template.\n            inf_zone_list (ZoneList): The list of zones to add the infiltration to.\n\n\n        Returns:\n            IDF: The IDF model with the added envelope.\n        \"\"\"\n        constructions = envelope.Constructions\n        infiltration = envelope.Infiltration\n        window_def = envelope.WindowDefinition\n        _other_settings = envelope.OtherSettings\n        _foundation_settings = envelope.Foundation\n        # TODO: other settings\n\n        self.add_srf_constructions(idf, constructions, window_def)\n        self.add_infiltration(idf, infiltration, inf_zone_list)\n\n        sch_names = self.envelope.schedule_names\n        idf = self.add_schedules_by_name(idf, sch_names)\n\n        return idf\n\n    def add_srf_constructions(\n        self,\n        idf: IDF,\n        constructions: ZoneConstruction,\n        window_def: WindowDefinition | None,\n    ) -&gt; IDF:\n        \"\"\"Assigns the constructions to the surfaces in the model.\n\n        Args:\n            idf (IDF): The IDF model to select the surfaces from.\n            constructions (ZoneConstruction): The construction template.\n            window_def (WindowDefinition): The window definition template.\n\n        Returns:\n            IDF: The IDF model with the selected surfaces.\n        \"\"\"\n        if self.geometry.roof_height:\n            raise ClimateStudioBuilderNotImplementedError(\"roof_height\")\n\n        if (\n            constructions.FacadeIsAdiabatic\n            or constructions.RoofIsAdiabatic\n            or constructions.GroundIsAdiabatic\n            or constructions.PartitionIsAdiabatic\n            or constructions.SlabIsAdiabatic\n        ):\n            raise ClimateStudioBuilderNotImplementedError(\"_IsAdiabatic\")\n\n        if constructions.InternalMassIsOn:\n            raise ClimateStudioBuilderNotImplementedError(\"InternalMassIsOn\")\n\n        handlers = SurfaceHandlers.Default()\n        idf = handlers.handle_envelope(idf, self.lib, constructions, window_def)\n\n        return idf\n\n    def add_zone_lists(\n        self,\n        idf: IDF,\n    ):\n        \"\"\"Add the zone lists to the IDF model.\n\n        Note that this attempts to automatically determine\n        the zones from the IDF model which are conditioned\n        as well as a separate list for all zones.\n\n        Args:\n            idf (IDF): The IDF model to add the zone lists to.\n\n        Returns:\n            idf (IDF): The IDF model with the added zone lists\n            conditioned_zone_list (ZoneList): The list of conditioned zones\n            all_zones_list (ZoneList): The list of all zones\n        \"\"\"\n        all_zone_names = [zone.Name for zone in idf.idfobjects[\"ZONE\"]]\n        all_zones_list = ZoneList(Name=\"All_Zones\", Names=all_zone_names)\n        conditioned_zone_names = [\n            zone.Name\n            for zone in idf.idfobjects[\"ZONE\"]\n            if \"attic\" not in zone.Name.lower()\n            and (\n                not zone.Name.lower().endswith(self.geometry.basement_suffix.lower())\n                if ((not self.conditioned_basement) and self.geometry.basement)\n                else True\n            )\n        ]\n\n        conditioned_storey_count = self.geometry.num_stories + (\n            1 if self.conditioned_basement else 0\n        )\n        zones_per_storey = 1 if self.geometry.zoning == \"by_storey\" else 5\n        expected_zone_count = conditioned_storey_count * zones_per_storey\n        if len(conditioned_zone_names) != expected_zone_count:\n            msg = f\"Expected {expected_zone_count} zones, but found {len(conditioned_zone_names)}.\"\n            raise ValueError(msg)\n\n        conditioned_zone_list = ZoneList(\n            Name=\"Conditioned_Zones\", Names=conditioned_zone_names\n        )\n        idf = conditioned_zone_list.add(idf)\n        idf = all_zones_list.add(idf)\n        return idf, conditioned_zone_list, all_zones_list\n\n    def add_infiltration(\n        self, idf: IDF, infiltration: ZoneInfiltration, zone_list: ZoneList\n    ):\n        \"\"\"Add the infiltration to the IDF model.\n\n        Args:\n            idf (IDF): The IDF model to add the infiltration to.\n            infiltration: The infiltration object.\n            zone_list (ZoneList): The list of zones to add the infiltration to.\n\n        Returns:\n            idf (IDF): The IDF model with the added infiltration.\n        \"\"\"\n        idf = infiltration.add_infiltration_to_idf_zone(idf, zone_list.Name)\n        # idf = self.add_schedules_by_name(idf, infiltration.schedule_names)\n        return idf\n\n    def add_space_use(self, idf: IDF, space_use: ZoneUse, zone_list: ZoneList) -&gt; IDF:\n        \"\"\"Add the space use to the IDF model.\n\n        Args:\n            idf (IDF): The IDF model to add the space use to.\n            space_use (ZoneUse): The zone use template.\n            zone_list (ZoneList): The list of zones to add the space use to.\n\n        Returns:\n            IDF: The IDF model with the added space use.\n        \"\"\"\n        idf = space_use.add_space_use_to_idf_zone(idf, zone_list)\n        idf = self.add_hot_water_to_zone_list(idf, space_use, zone_list)\n        idf = self.add_schedules_by_name(idf, space_use.schedule_names)\n        return idf\n\n    def add_schedules_by_name(self, idf: IDF, schedule_names: set[str]) -&gt; IDF:\n        \"\"\"Add schedules to the IDF model by name.\n\n        Args:\n            idf (IDF): The IDF model to add the schedules to.\n            schedule_names (set[str]): The names of the schedules to add.\n\n        Returns:\n            IDF: The IDF model with the added schedules.\n        \"\"\"\n        schedules = [self.lib.Schedules[s] for s in schedule_names]\n        for schedule in schedules:\n            yr_sch, *_ = schedule.to_year_week_day()\n            yr_sch.to_epbunch(idf)\n        return idf\n\n    def simulate(\n        self,\n        config: SimulationPathConfig,\n        post_build_callback: Callable[[IDF], IDF] | None = None,\n    ) -&gt; tuple[IDF, Sql]:\n        \"\"\"Build and simualte the idf model.\n\n        Args:\n            config (SimulationConfig): The configuration for the simulation.\n            post_build_callback (Callable[[IDF],IDF] | None): A callback to run after the model is built.\n\n        Returns:\n            tuple[IDF, Sql]: The built energy model and the sql file.\n        \"\"\"\n        idf = self.build(config)\n        if post_build_callback is not None:\n            idf = post_build_callback(idf)\n        idf.simulate()\n        sql = Sql(idf.sql_file)\n        return idf, sql\n\n    def get_warnings(self, idf: IDF) -&gt; str:\n        \"\"\"Get the warning text from the idf model.\n\n        Args:\n            idf (IDF): The IDF model to get the warning text from.\n\n        Returns:\n            str: The warning text.\n        \"\"\"\n        err_files = filter(\n            lambda x: x.suffix == \".err\",\n            [idf.output_directory / Path(f) for f in idf.simulation_files],\n        )\n        err_text = \"\\n\".join([f.read_text() for f in err_files])\n        return err_text\n\n    def standard_results_postprocess(self, sql: Sql, move_energy: bool) -&gt; pd.Series:\n        \"\"\"Postprocess the sql file to get the standard results.\n\n        Args:\n            sql (Sql): The sql file to postprocess.\n            move_energy (bool): Whether to move the energy to fuels based off of the CoP/Fuel Types.\n\n        Returns:\n            pd.DataFrame: The postprocessed results.\n        \"\"\"\n        res_df = sql.tabular_data_by_name(\n            \"AnnualBuildingUtilityPerformanceSummary\", \"End Uses\"\n        )\n        gc.collect()\n        kWh_per_GJ = 277.778\n        res_df = (\n            res_df[\n                [\n                    \"Electricity\",\n                    \"District Cooling\",\n                    \"District Heating\",\n                ]\n            ].droplevel(-1, axis=1)\n            * kWh_per_GJ\n        ) / self.total_conditioned_area\n        res_series_hot_water = res_df.loc[\"Water Systems\"]\n        res_series = res_df.loc[\"Total End Uses\"] - res_series_hot_water\n        res_series[\"Domestic Hot Water\"] = res_series_hot_water.sum()\n\n        res_series.name = \"kWh/m2\"\n\n        if move_energy:\n            heat_cop = self.space_use.Conditioning.HeatingCOP\n            cool_cop = self.space_use.Conditioning.CoolingCOP\n            dhw_cop = self.space_use.HotWater.DomHotWaterCOP\n            heat_fuel = self.space_use.Conditioning.HeatingFuelType\n            cool_fuel = self.space_use.Conditioning.CoolingFuelType\n            dhw_fuel = self.space_use.HotWater.HotWaterFuelType\n            heat_energy = res_series[\"District Heating\"] / heat_cop\n            cool_energy = res_series[\"District Cooling\"] / cool_cop\n            dhw_energy = res_series[\"Domestic Hot Water\"] / dhw_cop\n            if heat_fuel not in res_series.index:\n                res_series[heat_fuel] = 0\n            if cool_fuel not in res_series.index:\n                res_series[cool_fuel] = 0\n            if dhw_fuel not in res_series.index:\n                res_series[dhw_fuel] = 0\n            res_series[heat_fuel] += heat_energy\n            res_series[cool_fuel] += cool_energy\n            res_series[dhw_fuel] += dhw_energy\n            res_series = res_series.drop([\n                \"District Cooling\",\n                \"District Heating\",\n                \"Domestic Hot Water\",\n            ])\n\n        return cast(pd.Series, res_series)\n\n    def run(\n        self,\n        weather_dir: Path | None = None,\n        post_build_callback: Callable[[IDF], IDF] | None = None,\n        move_energy: bool = False,\n    ) -&gt; tuple[IDF, pd.Series, str]:\n        \"\"\"Build and simualte the idf model.\n\n        Args:\n            weather_dir (Path): The directory to store the weather files.\n            post_build_callback (Callable[[IDF],IDF] | None): A callback to run after the model is built.\n            move_energy (bool): Whether to move the energy to fuels based off of the CoP/Fuel Types.\n\n        Returns:\n            idf (IDF): The built energy model.\n            results (pd.Series): The postprocessed results.\n            err_text (str): The warning text.\n        \"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            output_dir = Path(temp_dir)\n            config = (\n                SimulationPathConfig(\n                    output_dir=output_dir,\n                    weather_dir=weather_dir,\n                )\n                if weather_dir is not None\n                else SimulationPathConfig(output_dir=output_dir)\n            )\n\n            idf, sql = self.simulate(\n                config,\n                post_build_callback=post_build_callback,\n            )\n            results = self.standard_results_postprocess(sql, move_energy=move_energy)\n            err_text = self.get_warnings(idf)\n            return idf, results, err_text\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.envelope","title":"<code>envelope</code>  <code>property</code>","text":"<p>The envelope definition for the model.</p>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.space_use","title":"<code>space_use</code>  <code>property</code>","text":"<p>The space use definition for the model.</p>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.total_conditioned_area","title":"<code>total_conditioned_area</code>  <code>property</code>","text":"<p>The total conditioned area of the model.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The total conditioned area of the model.</p>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.total_people","title":"<code>total_people</code>  <code>property</code>","text":"<p>The total number of people in the model.</p> <p>Returns:</p> Name Type Description <code>ppl</code> <code>float</code> <p>The total number of people in the model</p>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.add_envelope","title":"<code>add_envelope(idf, envelope, inf_zone_list)</code>","text":"<p>Add the envelope to the IDF model.</p> <p>Takes care of both the constructions and infiltration and windows.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the envelope to.</p> required <code>envelope</code> <code>ZoneEnvelope</code> <p>The envelope template.</p> required <code>inf_zone_list</code> <code>ZoneList</code> <p>The list of zones to add the infiltration to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The IDF model with the added envelope.</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>def add_envelope(\n    self, idf: IDF, envelope: ZoneEnvelope, inf_zone_list: ZoneList\n) -&gt; IDF:\n    \"\"\"Add the envelope to the IDF model.\n\n    Takes care of both the constructions and infiltration and windows.\n\n    Args:\n        idf (IDF): The IDF model to add the envelope to.\n        envelope (ZoneEnvelope): The envelope template.\n        inf_zone_list (ZoneList): The list of zones to add the infiltration to.\n\n\n    Returns:\n        IDF: The IDF model with the added envelope.\n    \"\"\"\n    constructions = envelope.Constructions\n    infiltration = envelope.Infiltration\n    window_def = envelope.WindowDefinition\n    _other_settings = envelope.OtherSettings\n    _foundation_settings = envelope.Foundation\n    # TODO: other settings\n\n    self.add_srf_constructions(idf, constructions, window_def)\n    self.add_infiltration(idf, infiltration, inf_zone_list)\n\n    sch_names = self.envelope.schedule_names\n    idf = self.add_schedules_by_name(idf, sch_names)\n\n    return idf\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.add_hot_water_to_zone","title":"<code>add_hot_water_to_zone(idf, space_use, zone_name)</code>","text":"<p>Add the hot water to the zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the hot water to.</p> required <code>space_use</code> <code>ZoneUse</code> <p>The zone use template.</p> required <code>zone_name</code> <code>str</code> <p>The name of the zone to add the hot water to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The IDF model with the added hot water.</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>def add_hot_water_to_zone(\n    self, idf: IDF, space_use: ZoneUse, zone_name: str\n) -&gt; IDF:\n    \"\"\"Add the hot water to the zone.\n\n    Args:\n        idf (IDF): The IDF model to add the hot water to.\n        space_use (ZoneUse): The zone use template.\n        zone_name (str): The name of the zone to add the hot water to.\n\n    Returns:\n        idf (IDF): The IDF model with the added hot water.\n    \"\"\"\n    zone = next(filter(lambda x: x.Name == zone_name, idf.idfobjects[\"ZONE\"]), None)\n    if zone is None:\n        raise ValueError(f\"NO_ZONE:{zone_name}\")\n    area = 0\n    area_ct = 0\n    for srf in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]:\n        if srf.Zone_Name == zone.Name and srf.Surface_Type.lower() == \"floor\":\n            poly = Polygon(srf.coords)\n            area += poly.area\n            area_ct += 1\n    if area_ct &gt; 1:\n        raise ValueError(f\"TOO_MANY_FLOORS:{zone.Name}\")\n    if area == 0 or area_ct == 0:\n        raise ValueError(f\"NO_AREA:{zone.Name}\")\n    ppl_density = space_use.Loads.PeopleDensity\n    total_ppl = ppl_density * area\n    idf = space_use.HotWater.add_water_to_idf_zone(idf, zone.Name, total_ppl)\n    return idf\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.add_hot_water_to_zone_list","title":"<code>add_hot_water_to_zone_list(idf, space_use, zone_list)</code>","text":"<p>Add the hot water to the zone list.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the hot water to.</p> required <code>space_use</code> <code>ZoneUse</code> <p>The zone use template.</p> required <code>zone_list</code> <code>ZoneList</code> <p>The list of zones to add the hot water to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The IDF model with the added hot water.</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>def add_hot_water_to_zone_list(\n    self, idf: IDF, space_use: ZoneUse, zone_list: ZoneList\n) -&gt; IDF:\n    \"\"\"Add the hot water to the zone list.\n\n    Args:\n        idf (IDF): The IDF model to add the hot water to.\n        space_use (ZoneUse): The zone use template.\n        zone_list (ZoneList): The list of zones to add the hot water to.\n\n    Returns:\n        idf (IDF): The IDF model with the added hot water.\n    \"\"\"\n    for zone_name in zone_list.Names:\n        idf = self.add_hot_water_to_zone(idf, space_use, zone_name)\n    return idf\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.add_infiltration","title":"<code>add_infiltration(idf, infiltration, zone_list)</code>","text":"<p>Add the infiltration to the IDF model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the infiltration to.</p> required <code>infiltration</code> <code>ZoneInfiltration</code> <p>The infiltration object.</p> required <code>zone_list</code> <code>ZoneList</code> <p>The list of zones to add the infiltration to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The IDF model with the added infiltration.</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>def add_infiltration(\n    self, idf: IDF, infiltration: ZoneInfiltration, zone_list: ZoneList\n):\n    \"\"\"Add the infiltration to the IDF model.\n\n    Args:\n        idf (IDF): The IDF model to add the infiltration to.\n        infiltration: The infiltration object.\n        zone_list (ZoneList): The list of zones to add the infiltration to.\n\n    Returns:\n        idf (IDF): The IDF model with the added infiltration.\n    \"\"\"\n    idf = infiltration.add_infiltration_to_idf_zone(idf, zone_list.Name)\n    # idf = self.add_schedules_by_name(idf, infiltration.schedule_names)\n    return idf\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.add_schedules_by_name","title":"<code>add_schedules_by_name(idf, schedule_names)</code>","text":"<p>Add schedules to the IDF model by name.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the schedules to.</p> required <code>schedule_names</code> <code>set[str]</code> <p>The names of the schedules to add.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The IDF model with the added schedules.</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>def add_schedules_by_name(self, idf: IDF, schedule_names: set[str]) -&gt; IDF:\n    \"\"\"Add schedules to the IDF model by name.\n\n    Args:\n        idf (IDF): The IDF model to add the schedules to.\n        schedule_names (set[str]): The names of the schedules to add.\n\n    Returns:\n        IDF: The IDF model with the added schedules.\n    \"\"\"\n    schedules = [self.lib.Schedules[s] for s in schedule_names]\n    for schedule in schedules:\n        yr_sch, *_ = schedule.to_year_week_day()\n        yr_sch.to_epbunch(idf)\n    return idf\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.add_space_use","title":"<code>add_space_use(idf, space_use, zone_list)</code>","text":"<p>Add the space use to the IDF model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the space use to.</p> required <code>space_use</code> <code>ZoneUse</code> <p>The zone use template.</p> required <code>zone_list</code> <code>ZoneList</code> <p>The list of zones to add the space use to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The IDF model with the added space use.</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>def add_space_use(self, idf: IDF, space_use: ZoneUse, zone_list: ZoneList) -&gt; IDF:\n    \"\"\"Add the space use to the IDF model.\n\n    Args:\n        idf (IDF): The IDF model to add the space use to.\n        space_use (ZoneUse): The zone use template.\n        zone_list (ZoneList): The list of zones to add the space use to.\n\n    Returns:\n        IDF: The IDF model with the added space use.\n    \"\"\"\n    idf = space_use.add_space_use_to_idf_zone(idf, zone_list)\n    idf = self.add_hot_water_to_zone_list(idf, space_use, zone_list)\n    idf = self.add_schedules_by_name(idf, space_use.schedule_names)\n    return idf\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.add_srf_constructions","title":"<code>add_srf_constructions(idf, constructions, window_def)</code>","text":"<p>Assigns the constructions to the surfaces in the model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to select the surfaces from.</p> required <code>constructions</code> <code>ZoneConstruction</code> <p>The construction template.</p> required <code>window_def</code> <code>WindowDefinition</code> <p>The window definition template.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The IDF model with the selected surfaces.</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>def add_srf_constructions(\n    self,\n    idf: IDF,\n    constructions: ZoneConstruction,\n    window_def: WindowDefinition | None,\n) -&gt; IDF:\n    \"\"\"Assigns the constructions to the surfaces in the model.\n\n    Args:\n        idf (IDF): The IDF model to select the surfaces from.\n        constructions (ZoneConstruction): The construction template.\n        window_def (WindowDefinition): The window definition template.\n\n    Returns:\n        IDF: The IDF model with the selected surfaces.\n    \"\"\"\n    if self.geometry.roof_height:\n        raise ClimateStudioBuilderNotImplementedError(\"roof_height\")\n\n    if (\n        constructions.FacadeIsAdiabatic\n        or constructions.RoofIsAdiabatic\n        or constructions.GroundIsAdiabatic\n        or constructions.PartitionIsAdiabatic\n        or constructions.SlabIsAdiabatic\n    ):\n        raise ClimateStudioBuilderNotImplementedError(\"_IsAdiabatic\")\n\n    if constructions.InternalMassIsOn:\n        raise ClimateStudioBuilderNotImplementedError(\"InternalMassIsOn\")\n\n    handlers = SurfaceHandlers.Default()\n    idf = handlers.handle_envelope(idf, self.lib, constructions, window_def)\n\n    return idf\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.add_zone_lists","title":"<code>add_zone_lists(idf)</code>","text":"<p>Add the zone lists to the IDF model.</p> <p>Note that this attempts to automatically determine the zones from the IDF model which are conditioned as well as a separate list for all zones.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the zone lists to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The IDF model with the added zone lists</p> <code>conditioned_zone_list</code> <code>ZoneList</code> <p>The list of conditioned zones</p> <code>all_zones_list</code> <code>ZoneList</code> <p>The list of all zones</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>def add_zone_lists(\n    self,\n    idf: IDF,\n):\n    \"\"\"Add the zone lists to the IDF model.\n\n    Note that this attempts to automatically determine\n    the zones from the IDF model which are conditioned\n    as well as a separate list for all zones.\n\n    Args:\n        idf (IDF): The IDF model to add the zone lists to.\n\n    Returns:\n        idf (IDF): The IDF model with the added zone lists\n        conditioned_zone_list (ZoneList): The list of conditioned zones\n        all_zones_list (ZoneList): The list of all zones\n    \"\"\"\n    all_zone_names = [zone.Name for zone in idf.idfobjects[\"ZONE\"]]\n    all_zones_list = ZoneList(Name=\"All_Zones\", Names=all_zone_names)\n    conditioned_zone_names = [\n        zone.Name\n        for zone in idf.idfobjects[\"ZONE\"]\n        if \"attic\" not in zone.Name.lower()\n        and (\n            not zone.Name.lower().endswith(self.geometry.basement_suffix.lower())\n            if ((not self.conditioned_basement) and self.geometry.basement)\n            else True\n        )\n    ]\n\n    conditioned_storey_count = self.geometry.num_stories + (\n        1 if self.conditioned_basement else 0\n    )\n    zones_per_storey = 1 if self.geometry.zoning == \"by_storey\" else 5\n    expected_zone_count = conditioned_storey_count * zones_per_storey\n    if len(conditioned_zone_names) != expected_zone_count:\n        msg = f\"Expected {expected_zone_count} zones, but found {len(conditioned_zone_names)}.\"\n        raise ValueError(msg)\n\n    conditioned_zone_list = ZoneList(\n        Name=\"Conditioned_Zones\", Names=conditioned_zone_names\n    )\n    idf = conditioned_zone_list.add(idf)\n    idf = all_zones_list.add(idf)\n    return idf, conditioned_zone_list, all_zones_list\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.build","title":"<code>build(config)</code>","text":"<p>Build the energy model using the Climate Studio API.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SimulationConfig</code> <p>The configuration for the simulation.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The built energy model.</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>def build(self, config: SimulationPathConfig) -&gt; IDF:\n    \"\"\"Build the energy model using the Climate Studio API.\n\n    Args:\n        config (SimulationConfig): The configuration for the simulation.\n\n    Returns:\n        IDF: The built energy model.\n    \"\"\"\n    if (not self.geometry.basement) and self.conditioned_basement:\n        raise ValueError(\"CONDITIONEDBASEMENT:TRUE:BASEMENT:FALSE\")\n\n    if self.geometry.roof_height:\n        raise ClimateStudioBuilderNotImplementedError(\"roof_height\")\n    config.output_dir.mkdir(parents=True, exist_ok=True)\n    base_filepath = EnergyPlusArtifactDir / \"Minimal.idf\"\n    target_base_filepath = config.output_dir / \"Minimal.idf\"\n    shutil.copy(base_filepath, target_base_filepath)\n    epw_path, ddy_path = self.fetch_weather(config.weather_dir)\n    idf = IDF(\n        target_base_filepath.as_posix(),\n        as_version=energyplus_settings.energyplus_version,  # pyright: ignore [reportArgumentType]\n        prep_outputs=True,\n        epw=epw_path.as_posix(),\n        output_directory=config.output_dir.as_posix(),\n    )\n    ddy = IDF(\n        ddy_path.as_posix(),\n        as_version=energyplus_settings.energyplus_version,\n        file_version=energyplus_settings.energyplus_version,\n        prep_outputs=False,\n    )\n    ddy_spec = DDYSizingSpec(\n        match=False, conditions_types=[\"Summer Extreme\", \"Winter Extreme\"]\n    )\n    ddy_spec.inject_ddy(idf, ddy)\n\n    idf = add_default_sim_controls(idf)\n    idf, scheds = add_default_schedules(idf)\n    self.lib.Schedules.update(scheds)\n\n    idf = SiteGroundTemperature.FromValues([\n        18.3,\n        18.2,\n        18.3,\n        18.4,\n        20.1,\n        22.0,\n        22.3,\n        22.5,\n        22.5,\n        20.7,\n        18.9,\n        18.5,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 18,\n        # 7.9,\n        # 6.05,\n        # 5.65,\n        # 6.21,\n        # 8.98,\n        # 11.97,\n        # 14.71,\n        # 16.62,\n        # 17.06,\n        # 15.98,\n        # 13.61,\n        # 10.71,\n        # 1.11,\n        # 0.1,\n        # 1.89,\n        # 4.69,\n        # 12.02,\n        # 17.68,\n        # 21.5,\n        # 22.66,\n        # 20.68,\n        # 16.29,\n        # 10.42,\n        # 4.97,\n    ]).add(idf)\n\n    idf = self.geometry.add(idf)\n\n    # construct zone lists\n    idf, conditioned_zone_list, all_zones_list = self.add_zone_lists(idf)\n\n    # TODO: Handle separately ventilated attic/basement?\n    idf = self.add_space_use(idf, self.space_use, conditioned_zone_list)\n    idf = self.add_envelope(idf, self.envelope, all_zones_list)\n\n    return idf\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.compute_dhw","title":"<code>compute_dhw()</code>","text":"<p>Compute the domestic hot water energy demand.</p> <p>Returns:</p> Name Type Description <code>energy</code> <code>float</code> <p>The domestic hot water energy demand (kWh/m2)</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>def compute_dhw(self) -&gt; float:\n    \"\"\"Compute the domestic hot water energy demand.\n\n    Returns:\n        energy (float): The domestic hot water energy demand (kWh/m2)\n    \"\"\"\n    # TODO: this should be computed from the DHW schedule\n    if not self.space_use.HotWater.IsOn:\n        return 0\n    flow_rate_per_person = self.space_use.HotWater.FlowRatePerPerson  # m3/hr/person\n    temperature_rise = (\n        self.space_use.HotWater.WaterSupplyTemperature\n        - self.space_use.HotWater.WaterTemperatureInlet\n    )  # K\n    water_density = 1000  # kg/m3\n    c = 4186  # J/kg.K\n    total_flow_rate = flow_rate_per_person * self.total_people  # m3/hr\n    total_volume = total_flow_rate * 8760  # m3 / yr\n    total_energy = total_volume * temperature_rise * water_density * c  # J / yr\n    total_energy_kWh = total_energy / 3600000  # kWh / yr\n    total_energy_kWh_per_m2 = (\n        total_energy_kWh / self.total_conditioned_area\n    )  # kWh/m2 / yr\n    return total_energy_kWh_per_m2\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.get_warnings","title":"<code>get_warnings(idf)</code>","text":"<p>Get the warning text from the idf model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to get the warning text from.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The warning text.</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>def get_warnings(self, idf: IDF) -&gt; str:\n    \"\"\"Get the warning text from the idf model.\n\n    Args:\n        idf (IDF): The IDF model to get the warning text from.\n\n    Returns:\n        str: The warning text.\n    \"\"\"\n    err_files = filter(\n        lambda x: x.suffix == \".err\",\n        [idf.output_directory / Path(f) for f in idf.simulation_files],\n    )\n    err_text = \"\\n\".join([f.read_text() for f in err_files])\n    return err_text\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.run","title":"<code>run(weather_dir=None, post_build_callback=None, move_energy=False)</code>","text":"<p>Build and simualte the idf model.</p> <p>Parameters:</p> Name Type Description Default <code>weather_dir</code> <code>Path</code> <p>The directory to store the weather files.</p> <code>None</code> <code>post_build_callback</code> <code>Callable[[IDF], IDF] | None</code> <p>A callback to run after the model is built.</p> <code>None</code> <code>move_energy</code> <code>bool</code> <p>Whether to move the energy to fuels based off of the CoP/Fuel Types.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The built energy model.</p> <code>results</code> <code>Series</code> <p>The postprocessed results.</p> <code>err_text</code> <code>str</code> <p>The warning text.</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>def run(\n    self,\n    weather_dir: Path | None = None,\n    post_build_callback: Callable[[IDF], IDF] | None = None,\n    move_energy: bool = False,\n) -&gt; tuple[IDF, pd.Series, str]:\n    \"\"\"Build and simualte the idf model.\n\n    Args:\n        weather_dir (Path): The directory to store the weather files.\n        post_build_callback (Callable[[IDF],IDF] | None): A callback to run after the model is built.\n        move_energy (bool): Whether to move the energy to fuels based off of the CoP/Fuel Types.\n\n    Returns:\n        idf (IDF): The built energy model.\n        results (pd.Series): The postprocessed results.\n        err_text (str): The warning text.\n    \"\"\"\n    with tempfile.TemporaryDirectory() as temp_dir:\n        output_dir = Path(temp_dir)\n        config = (\n            SimulationPathConfig(\n                output_dir=output_dir,\n                weather_dir=weather_dir,\n            )\n            if weather_dir is not None\n            else SimulationPathConfig(output_dir=output_dir)\n        )\n\n        idf, sql = self.simulate(\n            config,\n            post_build_callback=post_build_callback,\n        )\n        results = self.standard_results_postprocess(sql, move_energy=move_energy)\n        err_text = self.get_warnings(idf)\n        return idf, results, err_text\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.simulate","title":"<code>simulate(config, post_build_callback=None)</code>","text":"<p>Build and simualte the idf model.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SimulationConfig</code> <p>The configuration for the simulation.</p> required <code>post_build_callback</code> <code>Callable[[IDF], IDF] | None</code> <p>A callback to run after the model is built.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[IDF, Sql]</code> <p>tuple[IDF, Sql]: The built energy model and the sql file.</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>def simulate(\n    self,\n    config: SimulationPathConfig,\n    post_build_callback: Callable[[IDF], IDF] | None = None,\n) -&gt; tuple[IDF, Sql]:\n    \"\"\"Build and simualte the idf model.\n\n    Args:\n        config (SimulationConfig): The configuration for the simulation.\n        post_build_callback (Callable[[IDF],IDF] | None): A callback to run after the model is built.\n\n    Returns:\n        tuple[IDF, Sql]: The built energy model and the sql file.\n    \"\"\"\n    idf = self.build(config)\n    if post_build_callback is not None:\n        idf = post_build_callback(idf)\n    idf.simulate()\n    sql = Sql(idf.sql_file)\n    return idf, sql\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.Model.standard_results_postprocess","title":"<code>standard_results_postprocess(sql, move_energy)</code>","text":"<p>Postprocess the sql file to get the standard results.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>Sql</code> <p>The sql file to postprocess.</p> required <code>move_energy</code> <code>bool</code> <p>Whether to move the energy to fuels based off of the CoP/Fuel Types.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.DataFrame: The postprocessed results.</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>def standard_results_postprocess(self, sql: Sql, move_energy: bool) -&gt; pd.Series:\n    \"\"\"Postprocess the sql file to get the standard results.\n\n    Args:\n        sql (Sql): The sql file to postprocess.\n        move_energy (bool): Whether to move the energy to fuels based off of the CoP/Fuel Types.\n\n    Returns:\n        pd.DataFrame: The postprocessed results.\n    \"\"\"\n    res_df = sql.tabular_data_by_name(\n        \"AnnualBuildingUtilityPerformanceSummary\", \"End Uses\"\n    )\n    gc.collect()\n    kWh_per_GJ = 277.778\n    res_df = (\n        res_df[\n            [\n                \"Electricity\",\n                \"District Cooling\",\n                \"District Heating\",\n            ]\n        ].droplevel(-1, axis=1)\n        * kWh_per_GJ\n    ) / self.total_conditioned_area\n    res_series_hot_water = res_df.loc[\"Water Systems\"]\n    res_series = res_df.loc[\"Total End Uses\"] - res_series_hot_water\n    res_series[\"Domestic Hot Water\"] = res_series_hot_water.sum()\n\n    res_series.name = \"kWh/m2\"\n\n    if move_energy:\n        heat_cop = self.space_use.Conditioning.HeatingCOP\n        cool_cop = self.space_use.Conditioning.CoolingCOP\n        dhw_cop = self.space_use.HotWater.DomHotWaterCOP\n        heat_fuel = self.space_use.Conditioning.HeatingFuelType\n        cool_fuel = self.space_use.Conditioning.CoolingFuelType\n        dhw_fuel = self.space_use.HotWater.HotWaterFuelType\n        heat_energy = res_series[\"District Heating\"] / heat_cop\n        cool_energy = res_series[\"District Cooling\"] / cool_cop\n        dhw_energy = res_series[\"Domestic Hot Water\"] / dhw_cop\n        if heat_fuel not in res_series.index:\n            res_series[heat_fuel] = 0\n        if cool_fuel not in res_series.index:\n            res_series[cool_fuel] = 0\n        if dhw_fuel not in res_series.index:\n            res_series[dhw_fuel] = 0\n        res_series[heat_fuel] += heat_energy\n        res_series[cool_fuel] += cool_energy\n        res_series[dhw_fuel] += dhw_energy\n        res_series = res_series.drop([\n            \"District Cooling\",\n            \"District Heating\",\n            \"Domestic Hot Water\",\n        ])\n\n    return cast(pd.Series, res_series)\n</code></pre>"},{"location":"modules/builder/#epinterface.climate_studio.builder.SimulationPathConfig","title":"<code>SimulationPathConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The configuration for the simulation's pathing.</p> Source code in <code>epinterface/climate_studio/builder.py</code> <pre><code>class SimulationPathConfig(BaseModel):\n    \"\"\"The configuration for the simulation's pathing.\"\"\"\n\n    output_dir: Path = Field(\n        default_factory=lambda: EnergyPlusArtifactDir / \"cache\" / str(uuid4())[:8],\n        description=\"The output directory for the IDF model.\",\n    )\n    weather_dir: Path = Field(\n        default_factory=lambda: EnergyPlusArtifactDir / \"cache\" / \"weather\",\n        description=\"The directory to store the weather files.\",\n    )\n</code></pre>"},{"location":"modules/climate-studio/","title":"ClimateStudio Interface","text":"<p>A module for parsing climate studio data and generating EnergyPlus objects.</p>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioException","title":"<code>ClimateStudioException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>A base exception for the climate studio library.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ClimateStudioException(Exception):\n    \"\"\"A base exception for the climate studio library.\"\"\"\n\n    def __init__(self, message: str):\n        \"\"\"Initialize the exception with a message.\"\"\"\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioException.__init__","title":"<code>__init__(message)</code>","text":"<p>Initialize the exception with a message.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def __init__(self, message: str):\n    \"\"\"Initialize the exception with a message.\"\"\"\n    self.message = message\n    super().__init__(self.message)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioLibraryDuplicatesFound","title":"<code>ClimateStudioLibraryDuplicatesFound</code>","text":"<p>               Bases: <code>ClimateStudioException</code></p> <p>An error raised when duplicates are found in a climate studio library.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ClimateStudioLibraryDuplicatesFound(ClimateStudioException):\n    \"\"\"An error raised when duplicates are found in a climate studio library.\"\"\"\n\n    def __init__(self, duplicate_field: str):\n        \"\"\"Initialize the exception with a message.\n\n        Args:\n            duplicate_field (str): The field with duplicates\n        \"\"\"\n        self.duplicate_field = duplicate_field\n        self.message = f\"Duplicate objects found in library: {duplicate_field}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioLibraryDuplicatesFound.__init__","title":"<code>__init__(duplicate_field)</code>","text":"<p>Initialize the exception with a message.</p> <p>Parameters:</p> Name Type Description Default <code>duplicate_field</code> <code>str</code> <p>The field with duplicates</p> required Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def __init__(self, duplicate_field: str):\n    \"\"\"Initialize the exception with a message.\n\n    Args:\n        duplicate_field (str): The field with duplicates\n    \"\"\"\n    self.duplicate_field = duplicate_field\n    self.message = f\"Duplicate objects found in library: {duplicate_field}\"\n    super().__init__(self.message)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioLibraryV1","title":"<code>ClimateStudioLibraryV1</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Climate Studio library object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ClimateStudioLibraryV1(BaseModel, arbitrary_types_allowed=True):\n    \"\"\"Climate Studio library object.\"\"\"\n\n    # DaySchedules: dict[str, DaySchedule]\n    # DomHotWater: dict[str, DomHotWater]\n    # WindowSettings: dict[str, WindowSettings]\n    # NaturalVentilation: dict[str, NaturalVentilation] ?\n    GasMaterials: dict[str, GasMaterial]\n    GlazingConstructionSimple: dict[str, GlazingConstructionSimple]\n    GlazingMaterials: dict[str, GlazingMaterial]\n    OpaqueMaterials: dict[str, OpaqueMaterial]\n    OpaqueConstructions: dict[str, OpaqueConstruction]\n    ZoneConditioning: dict[str, ZoneConditioning]\n    ZoneConstruction: dict[str, ZoneConstruction]\n    ZoneDefinition: dict[str, ZoneDefinition]\n    ZoneInfiltration: dict[str, ZoneInfiltration]\n    ZoneLoad: dict[str, ZoneLoad]\n    Schedules: dict[str, Schedule]\n\n    @classmethod\n    @validate_call\n    def Load(cls, base_path: Path):\n        \"\"\"Load a Climate Studio library from a directory.\n\n        The directory should have all the necessary named files.\n\n        Args:\n            base_path (Path): The base path to the library directory.\n\n        Returns:\n            lib (ClimateStudioLibrary): The Climate Studio library object.\n        \"\"\"\n        if isinstance(base_path, str):\n            base_path = Path(base_path)\n\n        gas_materials = cls.LoadObjects(base_path, GasMaterial, pluralize=True)\n        glass_consts_simple = cls.LoadObjects(base_path, GlazingConstructionSimple)\n        glazing_materials = cls.LoadObjects(base_path, GlazingMaterial, pluralize=True)\n        opaque_materials = cls.LoadObjects(base_path, OpaqueMaterial, pluralize=True)\n        opaque_consts = cls.LoadObjects(base_path, OpaqueConstruction, pluralize=True)\n        zone_constructions = cls.LoadObjects(base_path, ZoneConstruction)\n        zone_definitions = cls.LoadObjects(base_path, ZoneDefinition)\n        zone_conditioning = cls.LoadObjects(base_path, ZoneConditioning)\n        zone_infiltrations = cls.LoadObjects(base_path, ZoneInfiltration)\n        zone_loads = cls.LoadObjects(base_path, ZoneLoad)\n\n        year_schs = pd.read_csv(base_path / \"YearSchedules.csv\", dtype=str)\n        sch_names = year_schs.columns\n        schedules_list = [extract_sch(year_schs, sch_name) for sch_name in sch_names]\n        schedules = {sch.Name: sch for sch in schedules_list}\n        if len(schedules) != len(schedules_list):\n            raise ClimateStudioLibraryDuplicatesFound(\"Schedules\")\n\n        return cls(\n            GasMaterials=gas_materials,\n            GlazingConstructionSimple=glass_consts_simple,\n            GlazingMaterials=glazing_materials,\n            OpaqueMaterials=opaque_materials,\n            OpaqueConstructions=opaque_consts,\n            ZoneConditioning=zone_conditioning,\n            ZoneConstruction=zone_constructions,\n            ZoneDefinition=zone_definitions,\n            ZoneInfiltration=zone_infiltrations,\n            ZoneLoad=zone_loads,\n            Schedules=schedules,\n        )\n\n    @classmethod\n    def LoadObjects(\n        cls, base_path: Path, obj_class: type[NamedType], pluralize: bool = False\n    ) -&gt; dict[str, NamedType]:\n        \"\"\"Handles deserializing a ClimateStudio CSV to the appropriate class.\n\n        Args:\n            base_path (Path): The base path to the library directory.\n            obj_class (Type[NamedObject]): The class to deserialize to.\n            pluralize (bool, optional): Whether to pluralize the filename. Defaults to False.\n\n        Returns:\n            dict[str, NamedObject]: The deserialized objects.\n        \"\"\"\n        df = pd.read_csv(\n            base_path / f\"{obj_class.__name__}{'s' if pluralize else ''}.csv\"\n        )\n        data = df.to_dict(orient=\"records\")\n        obj_list = [obj_class.model_validate(d) for d in data]\n        obj_dict = {obj.Name: obj for obj in obj_list}\n        if len(obj_dict) != len(obj_list):\n            raise ClimateStudioLibraryDuplicatesFound(obj_class.__name__)\n        return obj_dict\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioLibraryV1.Load","title":"<code>Load(base_path)</code>  <code>classmethod</code>","text":"<p>Load a Climate Studio library from a directory.</p> <p>The directory should have all the necessary named files.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>Path</code> <p>The base path to the library directory.</p> required <p>Returns:</p> Name Type Description <code>lib</code> <code>ClimateStudioLibrary</code> <p>The Climate Studio library object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>@classmethod\n@validate_call\ndef Load(cls, base_path: Path):\n    \"\"\"Load a Climate Studio library from a directory.\n\n    The directory should have all the necessary named files.\n\n    Args:\n        base_path (Path): The base path to the library directory.\n\n    Returns:\n        lib (ClimateStudioLibrary): The Climate Studio library object.\n    \"\"\"\n    if isinstance(base_path, str):\n        base_path = Path(base_path)\n\n    gas_materials = cls.LoadObjects(base_path, GasMaterial, pluralize=True)\n    glass_consts_simple = cls.LoadObjects(base_path, GlazingConstructionSimple)\n    glazing_materials = cls.LoadObjects(base_path, GlazingMaterial, pluralize=True)\n    opaque_materials = cls.LoadObjects(base_path, OpaqueMaterial, pluralize=True)\n    opaque_consts = cls.LoadObjects(base_path, OpaqueConstruction, pluralize=True)\n    zone_constructions = cls.LoadObjects(base_path, ZoneConstruction)\n    zone_definitions = cls.LoadObjects(base_path, ZoneDefinition)\n    zone_conditioning = cls.LoadObjects(base_path, ZoneConditioning)\n    zone_infiltrations = cls.LoadObjects(base_path, ZoneInfiltration)\n    zone_loads = cls.LoadObjects(base_path, ZoneLoad)\n\n    year_schs = pd.read_csv(base_path / \"YearSchedules.csv\", dtype=str)\n    sch_names = year_schs.columns\n    schedules_list = [extract_sch(year_schs, sch_name) for sch_name in sch_names]\n    schedules = {sch.Name: sch for sch in schedules_list}\n    if len(schedules) != len(schedules_list):\n        raise ClimateStudioLibraryDuplicatesFound(\"Schedules\")\n\n    return cls(\n        GasMaterials=gas_materials,\n        GlazingConstructionSimple=glass_consts_simple,\n        GlazingMaterials=glazing_materials,\n        OpaqueMaterials=opaque_materials,\n        OpaqueConstructions=opaque_consts,\n        ZoneConditioning=zone_conditioning,\n        ZoneConstruction=zone_constructions,\n        ZoneDefinition=zone_definitions,\n        ZoneInfiltration=zone_infiltrations,\n        ZoneLoad=zone_loads,\n        Schedules=schedules,\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioLibraryV1.LoadObjects","title":"<code>LoadObjects(base_path, obj_class, pluralize=False)</code>  <code>classmethod</code>","text":"<p>Handles deserializing a ClimateStudio CSV to the appropriate class.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>Path</code> <p>The base path to the library directory.</p> required <code>obj_class</code> <code>Type[NamedObject]</code> <p>The class to deserialize to.</p> required <code>pluralize</code> <code>bool</code> <p>Whether to pluralize the filename. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, NamedType]</code> <p>dict[str, NamedObject]: The deserialized objects.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>@classmethod\ndef LoadObjects(\n    cls, base_path: Path, obj_class: type[NamedType], pluralize: bool = False\n) -&gt; dict[str, NamedType]:\n    \"\"\"Handles deserializing a ClimateStudio CSV to the appropriate class.\n\n    Args:\n        base_path (Path): The base path to the library directory.\n        obj_class (Type[NamedObject]): The class to deserialize to.\n        pluralize (bool, optional): Whether to pluralize the filename. Defaults to False.\n\n    Returns:\n        dict[str, NamedObject]: The deserialized objects.\n    \"\"\"\n    df = pd.read_csv(\n        base_path / f\"{obj_class.__name__}{'s' if pluralize else ''}.csv\"\n    )\n    data = df.to_dict(orient=\"records\")\n    obj_list = [obj_class.model_validate(d) for d in data]\n    obj_dict = {obj.Name: obj for obj in obj_list}\n    if len(obj_dict) != len(obj_list):\n        raise ClimateStudioLibraryDuplicatesFound(obj_class.__name__)\n    return obj_dict\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioLibraryV2","title":"<code>ClimateStudioLibraryV2</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Climate Studio library object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ClimateStudioLibraryV2(BaseModel, arbitrary_types_allowed=True):\n    \"\"\"Climate Studio library object.\"\"\"\n\n    SpaceUses: dict[str, ZoneUse]\n    Envelopes: dict[str, ZoneEnvelope]\n    GlazingConstructions: dict[str, GlazingConstructionSimple]\n    OpaqueConstructions: dict[str, OpaqueConstruction]\n    OpaqueMaterials: dict[str, OpaqueMaterial]\n    Schedules: dict[str, Schedule]\n\n    @field_validator(\"Schedules\", mode=\"before\")\n    @classmethod\n    def validate_schedules(cls, value: dict[str, Any]):\n        \"\"\"Validate the schedules.\"\"\"\n        for key, val in value.items():\n            if isinstance(val, dict):\n                transfer = ScheduleTransferObject.model_validate(val)\n                limit_type = ScheduleTypeLimits.from_dict(transfer.Type)\n                value[key] = Schedule.from_values(\n                    Name=transfer.Name,\n                    Type=limit_type,  # pyright: ignore [reportArgumentType]\n                    Values=transfer.Values,\n                )\n            elif isinstance(val, ScheduleTransferObject):\n                limit_type = ScheduleTypeLimits.from_dict(val.Type)\n                value[key] = Schedule.from_values(\n                    Name=val.Name,\n                    Type=limit_type,  # pyright: ignore [reportArgumentType]\n                    Values=val.Values,\n                )\n            elif not isinstance(val, Schedule):\n                raise TypeError(f\"SCHEDULE_LOAD_ERROR:{type(val)}\")\n            else:\n                continue\n        return value\n\n    @field_serializer(\"Schedules\")\n    def serialize_schedules(\n        self, schedules: dict[str, Schedule]\n    ) -&gt; dict[str, \"ScheduleTransferObject\"]:\n        \"\"\"Serialize the schedules to a dataframe.\n\n        Args:\n            schedules (dict[str, Schedule]): The schedules to serialize.\n\n        Returns:\n            serialized_schedules (dict[str, list[float]])\n        \"\"\"\n        out_result: dict[str, ScheduleTransferObject] = {}\n        for name, sch in schedules.items():\n            out_result[name] = ScheduleTransferObject(\n                Name=sch.Name,\n                Type=sch.Type.to_dict(),\n                Values=list(cast(np.ndarray, sch.Values)),\n            )\n\n        return out_result\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioLibraryV2.serialize_schedules","title":"<code>serialize_schedules(schedules)</code>","text":"<p>Serialize the schedules to a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>schedules</code> <code>dict[str, Schedule]</code> <p>The schedules to serialize.</p> required <p>Returns:</p> Type Description <code>dict[str, ScheduleTransferObject]</code> <p>serialized_schedules (dict[str, list[float]])</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>@field_serializer(\"Schedules\")\ndef serialize_schedules(\n    self, schedules: dict[str, Schedule]\n) -&gt; dict[str, \"ScheduleTransferObject\"]:\n    \"\"\"Serialize the schedules to a dataframe.\n\n    Args:\n        schedules (dict[str, Schedule]): The schedules to serialize.\n\n    Returns:\n        serialized_schedules (dict[str, list[float]])\n    \"\"\"\n    out_result: dict[str, ScheduleTransferObject] = {}\n    for name, sch in schedules.items():\n        out_result[name] = ScheduleTransferObject(\n            Name=sch.Name,\n            Type=sch.Type.to_dict(),\n            Values=list(cast(np.ndarray, sch.Values)),\n        )\n\n    return out_result\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioLibraryV2.validate_schedules","title":"<code>validate_schedules(value)</code>  <code>classmethod</code>","text":"<p>Validate the schedules.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>@field_validator(\"Schedules\", mode=\"before\")\n@classmethod\ndef validate_schedules(cls, value: dict[str, Any]):\n    \"\"\"Validate the schedules.\"\"\"\n    for key, val in value.items():\n        if isinstance(val, dict):\n            transfer = ScheduleTransferObject.model_validate(val)\n            limit_type = ScheduleTypeLimits.from_dict(transfer.Type)\n            value[key] = Schedule.from_values(\n                Name=transfer.Name,\n                Type=limit_type,  # pyright: ignore [reportArgumentType]\n                Values=transfer.Values,\n            )\n        elif isinstance(val, ScheduleTransferObject):\n            limit_type = ScheduleTypeLimits.from_dict(val.Type)\n            value[key] = Schedule.from_values(\n                Name=val.Name,\n                Type=limit_type,  # pyright: ignore [reportArgumentType]\n                Values=val.Values,\n            )\n        elif not isinstance(val, Schedule):\n            raise TypeError(f\"SCHEDULE_LOAD_ERROR:{type(val)}\")\n        else:\n            continue\n    return value\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioMetadata","title":"<code>ClimateStudioMetadata</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Metadata for a climate studio table object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ClimateStudioMetadata(BaseModel):\n    \"\"\"Metadata for a climate studio table object.\"\"\"\n\n    Category: str = Field(..., title=\"Category of the object\")\n    Comment: NanStr = Field(..., title=\"Comment on the object\")\n    DataSource: NanStr = Field(..., title=\"Data source of the object\")\n    ClimateZone: str = Field(..., title=\"Climate zone of the object\")\n    Standard: str = Field(..., title=\"Standard of the object\")\n    Program: str = Field(..., title=\"Program of the object\")\n    Version: NanStr | None = Field(default=None, title=\"Version of the object\")\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioValueNotFound","title":"<code>ClimateStudioValueNotFound</code>","text":"<p>               Bases: <code>ClimateStudioException</code></p> <p>An error raised when a value is not found in a climate studio library.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ClimateStudioValueNotFound(ClimateStudioException):\n    \"\"\"An error raised when a value is not found in a climate studio library.\"\"\"\n\n    def __init__(self, obj_type: str, value: str):\n        \"\"\"Initialize the exception with a message.\n\n        Args:\n            obj_type (str): The type of object that was not found.\n            value (str): The value that was not found.\n        \"\"\"\n        self.obj_type = obj_type\n        self.value = value\n        self.message = f\"Value not found in library: {obj_type}:{value}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ClimateStudioValueNotFound.__init__","title":"<code>__init__(obj_type, value)</code>","text":"<p>Initialize the exception with a message.</p> <p>Parameters:</p> Name Type Description Default <code>obj_type</code> <code>str</code> <p>The type of object that was not found.</p> required <code>value</code> <code>str</code> <p>The value that was not found.</p> required Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def __init__(self, obj_type: str, value: str):\n    \"\"\"Initialize the exception with a message.\n\n    Args:\n        obj_type (str): The type of object that was not found.\n        value (str): The value that was not found.\n    \"\"\"\n    self.obj_type = obj_type\n    self.value = value\n    self.message = f\"Value not found in library: {obj_type}:{value}\"\n    super().__init__(self.message)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.CommonMaterialProperties","title":"<code>CommonMaterialProperties</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Common material properties for glazing and opaque materials.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class CommonMaterialProperties(BaseModel):\n    \"\"\"Common material properties for glazing and opaque materials.\"\"\"\n\n    Conductivity: float = Field(\n        ...,\n        title=\"Conductivity [W/mK]\",\n        validation_alias=\"Conductivity [W/m.K]\",\n        ge=0,\n    )\n    Density: float = Field(\n        ...,\n        title=\"Density [kg/m3]\",\n        ge=0,\n        validation_alias=AliasChoices(\n            \"Density [kg/m\u00b3]\",\n            \"Density [kg/m3]\",\n        ),\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.EmbodiedCarbonData","title":"<code>EmbodiedCarbonData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Embodied carbon data for a material or construction.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class EmbodiedCarbonData(BaseModel):\n    \"\"\"Embodied carbon data for a material or construction.\"\"\"\n\n    EmbodiedEnergy: float = Field(\n        ...,\n        title=\"Embodied energy [MJ/unit]\",\n        validation_alias=AliasChoices(\n            \"EmbodiedEnergy [MJ/Kg]\",\n            \"EmbodiedEnergy\",\n            \"EmbodiedEnergy [MJ/m\u00b2]\",\n            \"EmbodiedEnergy [MJ/m\u00c2\u00b2]\",\n            \"EmbodiedEnergy [MJ/m\u00c3\u201a\u00c2\u00b2]\",  # noqa: RUF001\n        ),\n    )\n    EmbodiedEnergyStdDev: float = Field(\n        0,\n        title=\"Standard deviation of embodied energy [MJ/unit]\",\n        validation_alias=\"EmbodiedEnergyStdDev\",\n        ge=0,\n    )\n    EmbodiedCarbon: float = Field(\n        ...,\n        title=\"Embodied carbon [kgCO2eq/unit]\",\n        validation_alias=AliasChoices(\n            \"EmbodiedCarbon [kgCO2eq/Kg]\",\n            \"EmbodiedCarbon\",\n            \"EmbodiedCarbon [kgCO2eq/m\u00b2]\",\n            \"EmbodiedCarbon [kgCO2eq/m\u00c2\u00b2]\",\n            \"EmbodiedCarbon [kgCO2eq/m\u00c3\u201a\u00c2\u00b2]\",  # noqa: RUF001\n        ),\n    )\n    EmbodiedCarbonStdDev: float = Field(\n        0,\n        title=\"Standard deviation of embodied carbon [kgCO2eq/unit]\",\n        validation_alias=\"EmbodiedCarbonStdDev\",\n        ge=0,\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.Foundation","title":"<code>Foundation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Foundation object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class Foundation(BaseModel, extra=\"ignore\"):\n    \"\"\"Foundation object.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.GasMaterial","title":"<code>GasMaterial</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MaterialWithThickness</code>, <code>StandardMaterializedMetadata</code></p> <p>Gas Material object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class GasMaterial(\n    NamedObject, MaterialWithThickness, StandardMaterializedMetadata, extra=\"forbid\"\n):\n    \"\"\"Gas Material object.\"\"\"\n\n    Model: Literal[\"Gas\"] = Field(default=\"Gas\", title=\"Model of the gas material\")\n    GasType1: str = Field(..., title=\"Type of the gas material\")\n    GasType2: str = Field(..., title=\"Type of the gas material\")\n    GasType3: str = Field(..., title=\"Type of the gas material\")\n    GasesInMix: int = Field(..., title=\"Number of gases in the mix\", ge=1)\n    Ratio1: float = Field(..., title=\"Ratio of the gas material\", ge=0, le=1)\n    Ratio2: float = Field(..., title=\"Ratio of the gas material\", ge=0, le=1)\n    Ratio3: float = Field(..., title=\"Ratio of the gas material\", ge=0, le=1)\n    ConductivityCoefficientA: float = Field(\n        ..., title=\"Conductivity coefficient A\", ge=0\n    )\n    ConductivityCoefficientB: float = Field(\n        ..., title=\"Conductivity coefficient B\", ge=0\n    )\n    ConductivityCoefficientC: float = Field(\n        ..., title=\"Conductivity coefficient C\", ge=0\n    )\n    MolecularWeight: float = Field(..., title=\"Molecular weight\", ge=0)\n    SpecificHeatCoefficientA: float = Field(\n        ..., title=\"Specific heat coefficient A\", ge=0\n    )\n    SpecificHeatCoefficientB: float = Field(\n        ..., title=\"Specific heat coefficient B\", ge=0\n    )\n    SpecificHeatCoefficientC: float = Field(\n        ..., title=\"Specific heat coefficient C\", ge=0\n    )\n    SpecificHeatRatio: float = Field(..., title=\"Specific heat ratio\", ge=0)\n    ViscosityCoefficientA: float = Field(..., title=\"Viscosity coefficient A\", ge=0)\n    ViscosityCoefficientB: float = Field(..., title=\"Viscosity coefficient B\", ge=0)\n    ViscosityCoefficientC: float = Field(..., title=\"Viscosity coefficient C\", ge=0)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.GlazingConstructionSimple","title":"<code>GlazingConstructionSimple</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>StandardMaterializedMetadata</code>, <code>ManufacturerData</code></p> <p>Simple glazing construction object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class GlazingConstructionSimple(\n    NamedObject,\n    StandardMaterializedMetadata,\n    ManufacturerData,\n    extra=\"forbid\",\n    populate_by_name=True,\n):\n    \"\"\"Simple glazing construction object.\"\"\"\n\n    SHGF: float = Field(..., title=\"Solar heat gain factor\", ge=0, le=1)\n    UValue: float = Field(\n        ...,\n        title=\"U-value [W/m\u00b2K]\",\n        validation_alias=\"UValue [W/m2-k]\",\n        ge=0,\n    )\n    TVis: float = Field(..., title=\"Visible transmittance\", ge=0, le=1)\n    Type: WindowType = Field(..., title=\"Type of the glazing construction\")\n\n    def add_to_idf(self, idf: IDF) -&gt; IDF:\n        \"\"\"Adds the glazing construction to an IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the construction to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        glazing_mat = SimpleGlazingMaterial(\n            Name=self.Name,\n            UFactor=self.UValue,\n            Solar_Heat_Gain_Coefficient=self.SHGF,\n            Visible_Transmittance=self.TVis,\n        )\n\n        construction = Construction(\n            name=self.Name,\n            layers=[glazing_mat],\n        )\n\n        idf = construction.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.GlazingConstructionSimple.add_to_idf","title":"<code>add_to_idf(idf)</code>","text":"<p>Adds the glazing construction to an IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the construction to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def add_to_idf(self, idf: IDF) -&gt; IDF:\n    \"\"\"Adds the glazing construction to an IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the construction to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    glazing_mat = SimpleGlazingMaterial(\n        Name=self.Name,\n        UFactor=self.UValue,\n        Solar_Heat_Gain_Coefficient=self.SHGF,\n        Visible_Transmittance=self.TVis,\n    )\n\n    construction = Construction(\n        name=self.Name,\n        layers=[glazing_mat],\n    )\n\n    idf = construction.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.GlazingMaterial","title":"<code>GlazingMaterial</code>","text":"<p>               Bases: <code>GlazingMaterialProperties</code>, <code>MaterialWithThickness</code>, <code>StandardMaterializedMetadata</code>, <code>NamedObject</code></p> <p>Glazing material object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class GlazingMaterial(\n    GlazingMaterialProperties,\n    MaterialWithThickness,\n    StandardMaterializedMetadata,\n    NamedObject,\n    extra=\"forbid\",\n):\n    \"\"\"Glazing material object.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.GlazingMaterialProperties","title":"<code>GlazingMaterialProperties</code>","text":"<p>               Bases: <code>CommonMaterialProperties</code></p> <p>Properties of a glazing material.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class GlazingMaterialProperties(CommonMaterialProperties):\n    \"\"\"Properties of a glazing material.\"\"\"\n\n    Optical: str = Field(..., title=\"Optical properties of the glazing material\")\n    OpticalDataName: NanStr = Field(\n        ..., title=\"Optical data name of the glazing material\"\n    )\n    NFRC_ID: int = Field(..., title=\"NFRC ID of the glazing material\")\n    Glazing_ID: int = Field(..., title=\"Glazing ID of the glazing material\")\n    CoatingSide: NanStr = Field(..., title=\"Coating side of the glazing material\")\n    SpectralDataPointWavelength: FloatListStr = Field(\n        ...,\n        title=\"Spectral data point wavelength\",\n        validation_alias=\"SpectralDataPointWavelength [Microns]\",\n    )\n    SpectralDataPointTransmittance: FloatListStr = Field(\n        ...,\n        title=\"Spectral data point transmittance\",\n        validation_alias=\"SpectralDataPointTransmittance [0-1]\",\n    )\n    SpectralDataPointFrontReflectance: FloatListStr = Field(\n        ...,\n        title=\"Spectral data point front reflectance\",\n        validation_alias=\"SpectralDataPointFrontReflectance [0-1]\",\n    )\n    SpectralDataPointBackReflectance: FloatListStr = Field(\n        ...,\n        title=\"Spectral data point back reflectance\",\n        validation_alias=\"SpectralDataPointBackReflectance [0-1]\",\n    )\n    SolarTransmittance: float = Field(\n        ...,\n        title=\"Solar transmittance of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"SolarTransmittance [0-1]\",\n    )\n    SolarReflectanceFront: float = Field(\n        ...,\n        title=\"Solar reflectance front of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"SolarReflectanceFront [0-1]\",\n    )\n    SolarReflectanceBack: float = Field(\n        ...,\n        title=\"Solar reflectance back of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"SolarReflectanceBack [0-1]\",\n    )\n    VisibleTransmittance: float = Field(\n        ...,\n        title=\"Visible transmittance of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"VisibleTransmittance [0-1]\",\n    )\n    VisibleReflectanceFront: float = Field(\n        ...,\n        title=\"Visible reflectance front of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"VisibleReflectanceFront [0-1]\",\n    )\n    VisibleReflectanceBack: float = Field(\n        ...,\n        title=\"Visible reflectance back of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"VisibleReflectanceBack [0-1]\",\n    )\n    IRTransmittance: float = Field(\n        ...,\n        title=\"IR transmittance of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"IRTransmittance [0-1]\",\n    )\n    IREmissivityFront: float = Field(\n        ...,\n        title=\"IR emissivity front of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"IREmissivityFront [0-1]\",\n    )\n    IREmissivityBack: float = Field(\n        ...,\n        title=\"IR emissivity back of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"IREmissivityBack [0-1]\",\n    )\n    DirtFactor: float = Field(\n        ...,\n        title=\"Dirt factor of the glazing material\",\n        ge=0,\n        le=1,\n        validation_alias=\"DirtFactor [0-1]\",\n    )\n    Type: str = Field(..., title=\"Type of the glazing material\")\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.LifecycleData","title":"<code>LifecycleData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Lifecycle data for a material or construction.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class LifecycleData(BaseModel):\n    \"\"\"Lifecycle data for a material or construction.\"\"\"\n\n    Cost: float = Field(\n        ...,\n        title=\"Cost [$/unit]\",\n        # a superscript 3 looks like this:\n        validation_alias=AliasChoices(\n            \"Cost [$/m\u00b3]\",\n            \"Cost [$/m3]\",\n            \"Cost [$/m\u00b2]\",\n            \"Cost [$/m2]\",\n            \"Cost [$/m]\",\n            \"Cost [$/kg]\",\n            \"Cost [$/m\u00c2\u00b2]\",\n            \"Cost [$/m\u00c3\u201a\u00c2\u00b2]\",  # noqa: RUF001\n        ),\n        ge=0,\n    )\n    Life: float = Field(\n        ...,\n        title=\"Life [years]\",\n        validation_alias=\"Life [yr]\",\n        ge=0,\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ManufacturerData","title":"<code>ManufacturerData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Manufacturer data for a construction.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ManufacturerData(BaseModel):\n    \"\"\"Manufacturer data for a construction.\"\"\"\n\n    Manufacturer: NanStr = Field(..., title=\"Manufacturer of the object\")\n    ProductName: NanStr = Field(..., title=\"Product name of the object\")\n    Appearance: NanStr = Field(..., title=\"Appearance of the glazing construction\")\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.MaterialWithThickness","title":"<code>MaterialWithThickness</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Material with a thickness.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class MaterialWithThickness(BaseModel, populate_by_name=True):\n    \"\"\"Material with a thickness.\"\"\"\n\n    Thickness: float = Field(\n        ...,\n        title=\"Thickness of the material [m]\",\n        validation_alias=\"Thickness [m]\",\n        ge=0,\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.NamedObject","title":"<code>NamedObject</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A Named object (with a name field).</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class NamedObject(BaseModel):\n    \"\"\"A Named object (with a name field).\"\"\"\n\n    Name: str = Field(..., title=\"Name of the object used in referencing.\")\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.NotImplementedClimateStudioParameter","title":"<code>NotImplementedClimateStudioParameter</code>","text":"<p>               Bases: <code>ClimateStudioException</code></p> <p>An error raised when a climate studio parameter is not implemented.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class NotImplementedClimateStudioParameter(ClimateStudioException):\n    \"\"\"An error raised when a climate studio parameter is not implemented.\"\"\"\n\n    def __init__(self, parameter_name: str, obj_name: str, obj_type: str):\n        \"\"\"Initialize the exception with a message.\n\n        Args:\n            parameter_name (str): The name of the parameter.\n            obj_name (str): The name of the object.\n            obj_type (str): The type of the object.\n        \"\"\"\n        self.parameter_name = parameter_name\n        self.obj_name = obj_name\n        self.obj_type = obj_type\n        self.message = f\"Parameter {parameter_name} not implemented for {obj_type.upper()}:{obj_name}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.NotImplementedClimateStudioParameter.__init__","title":"<code>__init__(parameter_name, obj_name, obj_type)</code>","text":"<p>Initialize the exception with a message.</p> <p>Parameters:</p> Name Type Description Default <code>parameter_name</code> <code>str</code> <p>The name of the parameter.</p> required <code>obj_name</code> <code>str</code> <p>The name of the object.</p> required <code>obj_type</code> <code>str</code> <p>The type of the object.</p> required Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def __init__(self, parameter_name: str, obj_name: str, obj_type: str):\n    \"\"\"Initialize the exception with a message.\n\n    Args:\n        parameter_name (str): The name of the parameter.\n        obj_name (str): The name of the object.\n        obj_type (str): The type of the object.\n    \"\"\"\n    self.parameter_name = parameter_name\n    self.obj_name = obj_name\n    self.obj_type = obj_type\n    self.message = f\"Parameter {parameter_name} not implemented for {obj_type.upper()}:{obj_name}\"\n    super().__init__(self.message)\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.OpaqueConstruction","title":"<code>OpaqueConstruction</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>StandardMaterializedMetadata</code>, <code>ManufacturerData</code></p> <p>Opaque construction object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class OpaqueConstruction(\n    NamedObject,\n    StandardMaterializedMetadata,\n    ManufacturerData,\n    extra=\"forbid\",\n    populate_by_name=True,\n):\n    \"\"\"Opaque construction object.\"\"\"\n\n    Layers: LayerListStr = Field(..., title=\"Layers of the opaque construction\")\n    VegetationLayer: NanStr = Field(\n        ..., title=\"Vegetation layer of the opaque construction\"\n    )\n    Type: OpaqueConstructionType = Field(..., title=\"Type of the opaque construction\")\n\n    def add_to_idf(self, idf: IDF, material_defs: dict[str, OpaqueMaterial]) -&gt; IDF:\n        \"\"\"Adds an opaque construction to an IDF object.\n\n        Note that this will add the individual materials as well.\n\n        Args:\n            idf (IDF): The IDF object to add the construction to.\n            material_defs (list[OpaqueMaterial]): List of opaque material definitions.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        layers = [layer.dereference_to_material(material_defs) for layer in self.Layers]\n\n        construction = Construction(\n            name=self.Name,\n            layers=layers,\n        )\n        idf = construction.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.OpaqueConstruction.add_to_idf","title":"<code>add_to_idf(idf, material_defs)</code>","text":"<p>Adds an opaque construction to an IDF object.</p> <p>Note that this will add the individual materials as well.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the construction to.</p> required <code>material_defs</code> <code>list[OpaqueMaterial]</code> <p>List of opaque material definitions.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def add_to_idf(self, idf: IDF, material_defs: dict[str, OpaqueMaterial]) -&gt; IDF:\n    \"\"\"Adds an opaque construction to an IDF object.\n\n    Note that this will add the individual materials as well.\n\n    Args:\n        idf (IDF): The IDF object to add the construction to.\n        material_defs (list[OpaqueMaterial]): List of opaque material definitions.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    layers = [layer.dereference_to_material(material_defs) for layer in self.Layers]\n\n    construction = Construction(\n        name=self.Name,\n        layers=layers,\n    )\n    idf = construction.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.OpaqueConstructionLayer","title":"<code>OpaqueConstructionLayer</code>","text":"<p>               Bases: <code>MaterialWithThickness</code>, <code>NamedObject</code></p> <p>Layer of an opaque construction.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class OpaqueConstructionLayer(MaterialWithThickness, NamedObject, extra=\"forbid\"):\n    \"\"\"Layer of an opaque construction.\"\"\"\n\n    def dereference_to_material(\n        self, material_defs: dict[str, OpaqueMaterial]\n    ) -&gt; Material:\n        \"\"\"Converts a referenced material into a direct EP material object.\n\n        Args:\n            material_defs (list[OpaqueMaterial]): List of opaque material definitions.\n\n        Returns:\n            Material: The material object.\n        \"\"\"\n        if self.Name not in material_defs:\n            raise ClimateStudioValueNotFound(\"Material\", self.Name)\n\n        mat_def = material_defs[self.Name]\n\n        material = Material(\n            Name=f\"{self.Name}_{self.Thickness}\",\n            Thickness=self.Thickness,\n            Conductivity=mat_def.Conductivity,\n            Density=mat_def.Density,\n            Specific_Heat=mat_def.SpecificHeat,\n            Thermal_Absorptance=mat_def.ThermalAbsorptance,\n            Solar_Absorptance=mat_def.SolarAbsorptance,\n            Visible_Absorptance=mat_def.VisibleAbsorptance,\n            Roughness=mat_def.Roughness,\n        )\n        return material\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.OpaqueConstructionLayer.dereference_to_material","title":"<code>dereference_to_material(material_defs)</code>","text":"<p>Converts a referenced material into a direct EP material object.</p> <p>Parameters:</p> Name Type Description Default <code>material_defs</code> <code>list[OpaqueMaterial]</code> <p>List of opaque material definitions.</p> required <p>Returns:</p> Name Type Description <code>Material</code> <code>Material</code> <p>The material object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def dereference_to_material(\n    self, material_defs: dict[str, OpaqueMaterial]\n) -&gt; Material:\n    \"\"\"Converts a referenced material into a direct EP material object.\n\n    Args:\n        material_defs (list[OpaqueMaterial]): List of opaque material definitions.\n\n    Returns:\n        Material: The material object.\n    \"\"\"\n    if self.Name not in material_defs:\n        raise ClimateStudioValueNotFound(\"Material\", self.Name)\n\n    mat_def = material_defs[self.Name]\n\n    material = Material(\n        Name=f\"{self.Name}_{self.Thickness}\",\n        Thickness=self.Thickness,\n        Conductivity=mat_def.Conductivity,\n        Density=mat_def.Density,\n        Specific_Heat=mat_def.SpecificHeat,\n        Thermal_Absorptance=mat_def.ThermalAbsorptance,\n        Solar_Absorptance=mat_def.SolarAbsorptance,\n        Visible_Absorptance=mat_def.VisibleAbsorptance,\n        Roughness=mat_def.Roughness,\n    )\n    return material\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.OpaqueMaterial","title":"<code>OpaqueMaterial</code>","text":"<p>               Bases: <code>OpaqueMaterialProperties</code>, <code>StandardMaterializedMetadata</code>, <code>NamedObject</code></p> <p>Opaque material object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class OpaqueMaterial(\n    OpaqueMaterialProperties,\n    StandardMaterializedMetadata,\n    NamedObject,\n    extra=\"forbid\",\n):\n    \"\"\"Opaque material object.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.OpaqueMaterialProperties","title":"<code>OpaqueMaterialProperties</code>","text":"<p>               Bases: <code>CommonMaterialProperties</code></p> <p>Properties of an opaque material.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class OpaqueMaterialProperties(CommonMaterialProperties, populate_by_name=True):\n    \"\"\"Properties of an opaque material.\"\"\"\n\n    Roughness: str = Field(..., title=\"Roughness of the opaque material\")\n    SpecificHeat: float = Field(\n        ...,\n        title=\"Specific heat [J/kgK]\",\n        validation_alias=\"SpecificHeat [J/kg.K]\",\n        ge=0,\n    )\n    ThermalAbsorptance: float = Field(\n        ...,\n        title=\"Thermal absorptance\",\n        ge=0,\n        le=1,\n        validation_alias=\"ThermalAbsorptance [0-1]\",\n    )\n    SolarAbsorptance: float = Field(\n        ...,\n        title=\"Solar absorptance\",\n        ge=0,\n        le=1,\n        validation_alias=\"SolarAbsorptance [0-1]\",\n    )\n    VisibleAbsorptance: float = Field(\n        ...,\n        title=\"Visible absorptance\",\n        ge=0,\n        le=1,\n        validation_alias=\"VisibleAbsorptance [0-1]\",\n    )\n    PhaseChange: BoolStr = Field(\n        ...,\n        title=\"Phase change\",\n        validation_alias=\"PhaseChange [Bool]\",\n    )\n    VariableConductivity: BoolStr = Field(\n        ...,\n        title=\"Variable conductivity\",\n        validation_alias=\"VariableConductivity [Bool]\",\n    )\n    TemperatureCoefficientThermalConductivity: float = Field(\n        ...,\n        # a superscript 2 looks like this:\n        title=\"Temperature coefficient of thermal conductivity [W/m.K2\u00b2]\",\n        ge=0,\n        validation_alias=\"TemperatureCoefficientThermalConductivity [W/m-K2]\",\n    )\n    TemperatureArray: FloatListStr = Field(\n        ...,\n        title=\"Temperature array\",\n        validation_alias=\"TemperatureArray [C]\",\n    )\n    EnthalpyArray: FloatListStr = Field(\n        ...,\n        title=\"Enthalpy array\",\n        validation_alias=\"EnthalpyArray [J/kg]\",\n    )\n    VariableConductivityArray: FloatListStr = Field(\n        ...,\n        title=\"Variable conductivity array\",\n        validation_alias=\"VariableConductivityArray [W/m-K]\",\n    )\n    Type: OpaqueMaterialType = Field(\n        ..., title=\"Type of the opaque material\", validation_alias=\"Type [enum]\"\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.OtherSettings","title":"<code>OtherSettings</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Other settings object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class OtherSettings(BaseModel, extra=\"ignore\"):\n    \"\"\"Other settings object.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ScheduleParseError","title":"<code>ScheduleParseError</code>","text":"<p>               Bases: <code>ClimateStudioException</code></p> <p>An error raised when a schedule cannot be parsed.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ScheduleParseError(ClimateStudioException):\n    \"\"\"An error raised when a schedule cannot be parsed.\"\"\"\n\n    def __init__(self, schedule_name: str):\n        \"\"\"Initialize the exception with a message.\n\n        Args:\n            schedule_name (str): The name of the schedule.\n        \"\"\"\n        self.schedule_name = schedule_name\n        super().__init__(f\"Failed to parse schedule {schedule_name}\")\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ScheduleParseError.__init__","title":"<code>__init__(schedule_name)</code>","text":"<p>Initialize the exception with a message.</p> <p>Parameters:</p> Name Type Description Default <code>schedule_name</code> <code>str</code> <p>The name of the schedule.</p> required Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def __init__(self, schedule_name: str):\n    \"\"\"Initialize the exception with a message.\n\n    Args:\n        schedule_name (str): The name of the schedule.\n    \"\"\"\n    self.schedule_name = schedule_name\n    super().__init__(f\"Failed to parse schedule {schedule_name}\")\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ScheduleTransferObject","title":"<code>ScheduleTransferObject</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schedule transfer object for help with de/serialization.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ScheduleTransferObject(BaseModel):\n    \"\"\"Schedule transfer object for help with de/serialization.\"\"\"\n\n    Name: str\n    Type: dict\n    Values: list[float]\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.StandardMaterializedMetadata","title":"<code>StandardMaterializedMetadata</code>","text":"<p>               Bases: <code>EmbodiedCarbonData</code>, <code>LifecycleData</code>, <code>ClimateStudioMetadata</code></p> <p>Standard metadata for a climate studio table.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class StandardMaterializedMetadata(\n    EmbodiedCarbonData, LifecycleData, ClimateStudioMetadata\n):\n    \"\"\"Standard metadata for a climate studio table.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandler","title":"<code>SurfaceHandler</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A handler for filtering and adding surfaces to a model.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class SurfaceHandler(BaseModel):\n    \"\"\"A handler for filtering and adding surfaces to a model.\"\"\"\n\n    boundary_condition: str | None\n    original_construction_name: str | None\n    original_surface_type: str | None\n    surface_group: Literal[\"glazing\", \"opaque\"]\n\n    def assign_srfs(\n        self, idf: IDF, lib: ClimateStudioLibraryV2, construction_name: str\n    ) -&gt; IDF:\n        \"\"\"Adds a construction (and its materials) to an IDF and assigns it to matching surfaces.\n\n        Args:\n            idf (IDF): The IDF model to add the construction to.\n            lib (ClimateStudioLibraryV2): The library of constructions.\n            construction_name (str): The name of the construction to add.\n        \"\"\"\n        srf_key = (\n            \"FENESTRATIONSURFACE:DETAILED\"\n            if self.surface_group == \"glazing\"\n            else \"BUILDINGSURFACE:DETAILED\"\n        )\n        if self.boundary_condition is not None and self.surface_group == \"glazing\":\n            raise NotImplementedClimateStudioParameter(\n                \"BoundaryCondition\", self.surface_group, \"Glazing\"\n            )\n\n        srfs = [srf for srf in idf.idfobjects[srf_key] if self.check_srf(srf)]\n        construction_lib = (\n            lib.OpaqueConstructions\n            if self.surface_group != \"glazing\"\n            else lib.GlazingConstructions\n        )\n        if construction_name not in construction_lib:\n            raise KeyError(\n                f\"MISSING_CONSTRUCTION:{construction_name}:TARGET={self.__repr__()}\"\n            )\n        construction = construction_lib[construction_name]\n        idf = (\n            construction.add_to_idf(idf)\n            if isinstance(construction, GlazingConstructionSimple)\n            else construction.add_to_idf(idf, lib.OpaqueMaterials)\n        )\n        for srf in srfs:\n            srf.Construction_Name = construction.Name\n        return idf\n\n    def check_srf(self, srf):\n        \"\"\"Check if the surface matches the filters.\n\n        Args:\n            srf (eppy.IDF.BLOCK): The surface to check.\n\n        Returns:\n            match (bool): True if the surface matches the filters.\n        \"\"\"\n        return (\n            self.check_construction_type(srf)\n            and self.check_boundary(srf)\n            and self.check_construction_name(srf)\n        )\n\n    def check_construction_type(self, srf):\n        \"\"\"Check if the surface matches the construction type.\n\n        Args:\n            srf (eppy.IDF.BLOCK): The surface to check.\n\n        Returns:\n            match (bool): True if the surface matches the construction type.\n        \"\"\"\n        if self.surface_group == \"glazing\":\n            # Ignore the construction type check for windows\n            return True\n        if self.original_surface_type is None:\n            # Ignore the construction type check when filter not provided\n            return True\n        # Check the construction type\n        return self.original_surface_type.lower() == srf.Surface_Type.lower()\n\n    def check_boundary(self, srf):\n        \"\"\"Check if the surface matches the boundary condition.\n\n        Args:\n            srf (eppy.IDF.BLOCK): The surface to check.\n\n        Returns:\n            match (bool): True if the surface matches the boundary condition.\n        \"\"\"\n        if self.surface_group == \"glazing\":\n            # Ignore the bc filter check for windows\n            return True\n        if self.boundary_condition is None:\n            # Ignore the bc filter when filter not provided\n            return True\n        # Check the boundary condition\n        return srf.Outside_Boundary_Condition.lower() == self.boundary_condition.lower()\n\n    def check_construction_name(self, srf):\n        \"\"\"Check if the surface matches the original construction name.\n\n        Args:\n            srf (eppy.IDF.BLOCK): The surface to check.\n\n        Returns:\n            match (bool): True if the surface matches the original construction name.\n        \"\"\"\n        if self.original_construction_name is None:\n            # Ignore the original construction name check when filter not provided\n            return True\n        # Check the original construction name\n        return srf.Construction_Name.lower() == self.original_construction_name.lower()\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandler.assign_srfs","title":"<code>assign_srfs(idf, lib, construction_name)</code>","text":"<p>Adds a construction (and its materials) to an IDF and assigns it to matching surfaces.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the construction to.</p> required <code>lib</code> <code>ClimateStudioLibraryV2</code> <p>The library of constructions.</p> required <code>construction_name</code> <code>str</code> <p>The name of the construction to add.</p> required Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def assign_srfs(\n    self, idf: IDF, lib: ClimateStudioLibraryV2, construction_name: str\n) -&gt; IDF:\n    \"\"\"Adds a construction (and its materials) to an IDF and assigns it to matching surfaces.\n\n    Args:\n        idf (IDF): The IDF model to add the construction to.\n        lib (ClimateStudioLibraryV2): The library of constructions.\n        construction_name (str): The name of the construction to add.\n    \"\"\"\n    srf_key = (\n        \"FENESTRATIONSURFACE:DETAILED\"\n        if self.surface_group == \"glazing\"\n        else \"BUILDINGSURFACE:DETAILED\"\n    )\n    if self.boundary_condition is not None and self.surface_group == \"glazing\":\n        raise NotImplementedClimateStudioParameter(\n            \"BoundaryCondition\", self.surface_group, \"Glazing\"\n        )\n\n    srfs = [srf for srf in idf.idfobjects[srf_key] if self.check_srf(srf)]\n    construction_lib = (\n        lib.OpaqueConstructions\n        if self.surface_group != \"glazing\"\n        else lib.GlazingConstructions\n    )\n    if construction_name not in construction_lib:\n        raise KeyError(\n            f\"MISSING_CONSTRUCTION:{construction_name}:TARGET={self.__repr__()}\"\n        )\n    construction = construction_lib[construction_name]\n    idf = (\n        construction.add_to_idf(idf)\n        if isinstance(construction, GlazingConstructionSimple)\n        else construction.add_to_idf(idf, lib.OpaqueMaterials)\n    )\n    for srf in srfs:\n        srf.Construction_Name = construction.Name\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandler.check_boundary","title":"<code>check_boundary(srf)</code>","text":"<p>Check if the surface matches the boundary condition.</p> <p>Parameters:</p> Name Type Description Default <code>srf</code> <code>BLOCK</code> <p>The surface to check.</p> required <p>Returns:</p> Name Type Description <code>match</code> <code>bool</code> <p>True if the surface matches the boundary condition.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def check_boundary(self, srf):\n    \"\"\"Check if the surface matches the boundary condition.\n\n    Args:\n        srf (eppy.IDF.BLOCK): The surface to check.\n\n    Returns:\n        match (bool): True if the surface matches the boundary condition.\n    \"\"\"\n    if self.surface_group == \"glazing\":\n        # Ignore the bc filter check for windows\n        return True\n    if self.boundary_condition is None:\n        # Ignore the bc filter when filter not provided\n        return True\n    # Check the boundary condition\n    return srf.Outside_Boundary_Condition.lower() == self.boundary_condition.lower()\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandler.check_construction_name","title":"<code>check_construction_name(srf)</code>","text":"<p>Check if the surface matches the original construction name.</p> <p>Parameters:</p> Name Type Description Default <code>srf</code> <code>BLOCK</code> <p>The surface to check.</p> required <p>Returns:</p> Name Type Description <code>match</code> <code>bool</code> <p>True if the surface matches the original construction name.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def check_construction_name(self, srf):\n    \"\"\"Check if the surface matches the original construction name.\n\n    Args:\n        srf (eppy.IDF.BLOCK): The surface to check.\n\n    Returns:\n        match (bool): True if the surface matches the original construction name.\n    \"\"\"\n    if self.original_construction_name is None:\n        # Ignore the original construction name check when filter not provided\n        return True\n    # Check the original construction name\n    return srf.Construction_Name.lower() == self.original_construction_name.lower()\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandler.check_construction_type","title":"<code>check_construction_type(srf)</code>","text":"<p>Check if the surface matches the construction type.</p> <p>Parameters:</p> Name Type Description Default <code>srf</code> <code>BLOCK</code> <p>The surface to check.</p> required <p>Returns:</p> Name Type Description <code>match</code> <code>bool</code> <p>True if the surface matches the construction type.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def check_construction_type(self, srf):\n    \"\"\"Check if the surface matches the construction type.\n\n    Args:\n        srf (eppy.IDF.BLOCK): The surface to check.\n\n    Returns:\n        match (bool): True if the surface matches the construction type.\n    \"\"\"\n    if self.surface_group == \"glazing\":\n        # Ignore the construction type check for windows\n        return True\n    if self.original_surface_type is None:\n        # Ignore the construction type check when filter not provided\n        return True\n    # Check the construction type\n    return self.original_surface_type.lower() == srf.Surface_Type.lower()\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandler.check_srf","title":"<code>check_srf(srf)</code>","text":"<p>Check if the surface matches the filters.</p> <p>Parameters:</p> Name Type Description Default <code>srf</code> <code>BLOCK</code> <p>The surface to check.</p> required <p>Returns:</p> Name Type Description <code>match</code> <code>bool</code> <p>True if the surface matches the filters.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def check_srf(self, srf):\n    \"\"\"Check if the surface matches the filters.\n\n    Args:\n        srf (eppy.IDF.BLOCK): The surface to check.\n\n    Returns:\n        match (bool): True if the surface matches the filters.\n    \"\"\"\n    return (\n        self.check_construction_type(srf)\n        and self.check_boundary(srf)\n        and self.check_construction_name(srf)\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandlers","title":"<code>SurfaceHandlers</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A collection of surface handlers for different surface types.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class SurfaceHandlers(BaseModel):\n    \"\"\"A collection of surface handlers for different surface types.\"\"\"\n\n    Roof: SurfaceHandler\n    Facade: SurfaceHandler\n    Slab: SurfaceHandler\n    Ceiling: SurfaceHandler\n    Partition: SurfaceHandler\n    GroundSlab: SurfaceHandler\n    GroundWall: SurfaceHandler\n    Window: SurfaceHandler\n\n    @classmethod\n    def Default(cls):\n        \"\"\"Get the default surface handlers.\"\"\"\n        roof_handler = SurfaceHandler(\n            boundary_condition=\"outdoors\",\n            original_construction_name=None,\n            original_surface_type=\"roof\",\n            surface_group=\"opaque\",\n        )\n        facade_handler = SurfaceHandler(\n            boundary_condition=\"outdoors\",\n            original_construction_name=None,\n            original_surface_type=\"wall\",\n            surface_group=\"opaque\",\n        )\n        partition_handler = SurfaceHandler(\n            boundary_condition=\"surface\",\n            original_construction_name=None,\n            original_surface_type=\"wall\",\n            surface_group=\"opaque\",\n        )\n        ground_wall_handler = SurfaceHandler(\n            boundary_condition=\"ground\",\n            original_construction_name=None,\n            original_surface_type=\"wall\",\n            surface_group=\"opaque\",\n        )\n        slab_handler = SurfaceHandler(\n            boundary_condition=\"surface\",\n            original_construction_name=None,\n            original_surface_type=\"floor\",\n            surface_group=\"opaque\",\n        )\n        ceiling_handler = SurfaceHandler(\n            boundary_condition=\"surface\",\n            original_construction_name=None,\n            original_surface_type=\"ceiling\",\n            surface_group=\"opaque\",\n        )\n        ground_slab_handler = SurfaceHandler(\n            boundary_condition=\"ground\",\n            original_construction_name=None,\n            original_surface_type=\"floor\",\n            surface_group=\"opaque\",\n        )\n        window_handler = SurfaceHandler(\n            boundary_condition=None,\n            original_construction_name=None,\n            original_surface_type=None,\n            surface_group=\"glazing\",\n        )\n\n        return cls(\n            Roof=roof_handler,\n            Facade=facade_handler,\n            Slab=slab_handler,\n            Ceiling=ceiling_handler,\n            Partition=partition_handler,\n            GroundSlab=ground_slab_handler,\n            GroundWall=ground_wall_handler,\n            Window=window_handler,\n        )\n\n    def handle_envelope(\n        self,\n        idf: IDF,\n        lib: ClimateStudioLibraryV2,\n        constructions: ZoneConstruction,\n        window: WindowDefinition | None,\n    ):\n        \"\"\"Assign the envelope to the IDF model.\n\n        Note that this will add a \"reversed\" construction for the floorsystem slab/ceiling\n\n        Args:\n            idf (IDF): The IDF model to add the envelope to.\n            lib (ClimateStudioLibraryV2): The library of constructions.\n            constructions (ZoneConstruction): The construction names for the envelope.\n            window (WindowDefinition | None): The window definition.\n\n        Returns:\n            idf (IDF): The updated IDF model.\n        \"\"\"\n\n        # outside walls are the ones with outdoor boundary condition and vertical orientation\n        def make_reversed(const: OpaqueConstruction):\n            new_const = const.model_copy(deep=True)\n            new_const.Layers = new_const.Layers[::-1]\n            new_const.Name = f\"{const.Name}_Reversed\"\n            return new_const\n\n        def reverse_construction(const_name: str, lib: ClimateStudioLibraryV2):\n            const = lib.OpaqueConstructions[const_name]\n            new_const = make_reversed(const)\n            return new_const\n\n        slab_reversed = reverse_construction(constructions.SlabConstruction, lib)\n        lib.OpaqueConstructions[slab_reversed.Name] = slab_reversed\n\n        idf = self.Roof.assign_srfs(\n            idf=idf, lib=lib, construction_name=constructions.RoofConstruction\n        )\n        idf = self.Facade.assign_srfs(\n            idf=idf, lib=lib, construction_name=constructions.FacadeConstruction\n        )\n        idf = self.Partition.assign_srfs(\n            idf=idf, lib=lib, construction_name=constructions.PartitionConstruction\n        )\n        idf = self.Slab.assign_srfs(\n            idf=idf, lib=lib, construction_name=slab_reversed.Name\n        )\n        idf = self.Ceiling.assign_srfs(\n            idf=idf, lib=lib, construction_name=constructions.SlabConstruction\n        )\n        idf = self.GroundSlab.assign_srfs(\n            idf=idf, lib=lib, construction_name=constructions.GroundSlabConstruction\n        )\n        idf = self.GroundWall.assign_srfs(\n            idf=idf, lib=lib, construction_name=constructions.GroundWallConstruction\n        )\n        if window:\n            idf = self.Window.assign_srfs(\n                idf=idf, lib=lib, construction_name=window.Construction\n            )\n        return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandlers.Default","title":"<code>Default()</code>  <code>classmethod</code>","text":"<p>Get the default surface handlers.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>@classmethod\ndef Default(cls):\n    \"\"\"Get the default surface handlers.\"\"\"\n    roof_handler = SurfaceHandler(\n        boundary_condition=\"outdoors\",\n        original_construction_name=None,\n        original_surface_type=\"roof\",\n        surface_group=\"opaque\",\n    )\n    facade_handler = SurfaceHandler(\n        boundary_condition=\"outdoors\",\n        original_construction_name=None,\n        original_surface_type=\"wall\",\n        surface_group=\"opaque\",\n    )\n    partition_handler = SurfaceHandler(\n        boundary_condition=\"surface\",\n        original_construction_name=None,\n        original_surface_type=\"wall\",\n        surface_group=\"opaque\",\n    )\n    ground_wall_handler = SurfaceHandler(\n        boundary_condition=\"ground\",\n        original_construction_name=None,\n        original_surface_type=\"wall\",\n        surface_group=\"opaque\",\n    )\n    slab_handler = SurfaceHandler(\n        boundary_condition=\"surface\",\n        original_construction_name=None,\n        original_surface_type=\"floor\",\n        surface_group=\"opaque\",\n    )\n    ceiling_handler = SurfaceHandler(\n        boundary_condition=\"surface\",\n        original_construction_name=None,\n        original_surface_type=\"ceiling\",\n        surface_group=\"opaque\",\n    )\n    ground_slab_handler = SurfaceHandler(\n        boundary_condition=\"ground\",\n        original_construction_name=None,\n        original_surface_type=\"floor\",\n        surface_group=\"opaque\",\n    )\n    window_handler = SurfaceHandler(\n        boundary_condition=None,\n        original_construction_name=None,\n        original_surface_type=None,\n        surface_group=\"glazing\",\n    )\n\n    return cls(\n        Roof=roof_handler,\n        Facade=facade_handler,\n        Slab=slab_handler,\n        Ceiling=ceiling_handler,\n        Partition=partition_handler,\n        GroundSlab=ground_slab_handler,\n        GroundWall=ground_wall_handler,\n        Window=window_handler,\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.SurfaceHandlers.handle_envelope","title":"<code>handle_envelope(idf, lib, constructions, window)</code>","text":"<p>Assign the envelope to the IDF model.</p> <p>Note that this will add a \"reversed\" construction for the floorsystem slab/ceiling</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the envelope to.</p> required <code>lib</code> <code>ClimateStudioLibraryV2</code> <p>The library of constructions.</p> required <code>constructions</code> <code>ZoneConstruction</code> <p>The construction names for the envelope.</p> required <code>window</code> <code>WindowDefinition | None</code> <p>The window definition.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF model.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def handle_envelope(\n    self,\n    idf: IDF,\n    lib: ClimateStudioLibraryV2,\n    constructions: ZoneConstruction,\n    window: WindowDefinition | None,\n):\n    \"\"\"Assign the envelope to the IDF model.\n\n    Note that this will add a \"reversed\" construction for the floorsystem slab/ceiling\n\n    Args:\n        idf (IDF): The IDF model to add the envelope to.\n        lib (ClimateStudioLibraryV2): The library of constructions.\n        constructions (ZoneConstruction): The construction names for the envelope.\n        window (WindowDefinition | None): The window definition.\n\n    Returns:\n        idf (IDF): The updated IDF model.\n    \"\"\"\n\n    # outside walls are the ones with outdoor boundary condition and vertical orientation\n    def make_reversed(const: OpaqueConstruction):\n        new_const = const.model_copy(deep=True)\n        new_const.Layers = new_const.Layers[::-1]\n        new_const.Name = f\"{const.Name}_Reversed\"\n        return new_const\n\n    def reverse_construction(const_name: str, lib: ClimateStudioLibraryV2):\n        const = lib.OpaqueConstructions[const_name]\n        new_const = make_reversed(const)\n        return new_const\n\n    slab_reversed = reverse_construction(constructions.SlabConstruction, lib)\n    lib.OpaqueConstructions[slab_reversed.Name] = slab_reversed\n\n    idf = self.Roof.assign_srfs(\n        idf=idf, lib=lib, construction_name=constructions.RoofConstruction\n    )\n    idf = self.Facade.assign_srfs(\n        idf=idf, lib=lib, construction_name=constructions.FacadeConstruction\n    )\n    idf = self.Partition.assign_srfs(\n        idf=idf, lib=lib, construction_name=constructions.PartitionConstruction\n    )\n    idf = self.Slab.assign_srfs(\n        idf=idf, lib=lib, construction_name=slab_reversed.Name\n    )\n    idf = self.Ceiling.assign_srfs(\n        idf=idf, lib=lib, construction_name=constructions.SlabConstruction\n    )\n    idf = self.GroundSlab.assign_srfs(\n        idf=idf, lib=lib, construction_name=constructions.GroundSlabConstruction\n    )\n    idf = self.GroundWall.assign_srfs(\n        idf=idf, lib=lib, construction_name=constructions.GroundWallConstruction\n    )\n    if window:\n        idf = self.Window.assign_srfs(\n            idf=idf, lib=lib, construction_name=window.Construction\n        )\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.WindowDefinition","title":"<code>WindowDefinition</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Window definition object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class WindowDefinition(NamedObject, ClimateStudioMetadata, extra=\"ignore\"):\n    \"\"\"Window definition object.\"\"\"\n\n    Construction: str = Field(..., title=\"Construction object name\")\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        return set()\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.WindowDefinition.schedule_names","title":"<code>schedule_names</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneConditioning","title":"<code>ZoneConditioning</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone conditioning object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ZoneConditioning(\n    NamedObject, ClimateStudioMetadata, extra=\"forbid\", populate_by_name=True\n):\n    \"\"\"Zone conditioning object.\"\"\"\n\n    HeatingSetpoint: float = Field(\n        ...,\n        title=\"Heating setpoint [\u00b0C]\",\n        validation_alias=\"HeatingSetpoint [\u00b0C]\",\n        ge=0,\n        le=100,\n    )\n    CoolingSetpoint: float = Field(\n        ...,\n        title=\"Cooling setpoint [\u00b0C]\",\n        validation_alias=\"CoolingSetpoint [\u00b0C]\",\n        ge=0,\n        le=100,\n    )\n    # TODO: should we validate heating &lt; cooling?\n    HeatingSetpointConstant: BoolStr = Field(..., title=\"Heating setpoint constant\")\n    CoolingSetpointConstant: BoolStr = Field(..., title=\"Cooling setpoint constant\")\n    HeatingSetpointSchedule: str = Field(..., title=\"Heating setpoint schedule\")\n    CoolingSetpointSchedule: str = Field(..., title=\"Cooling setpoint schedule\")\n    MinFreshAirPerson: float = Field(\n        ...,\n        title=\"Minimum fresh air per person [L/s/p]\",\n        validation_alias=\"MinFreshAirPerson [L/s/p]\",\n        ge=0,\n    )\n    MinFreshAirArea: float = Field(\n        ...,\n        title=\"Minimum fresh air per area [L/s/m\u00b2]\",\n        validation_alias=\"MinFreshAirArea [L/s/m\u00b2]\",\n        ge=0,\n    )\n    CoolingCOP: float = Field(\n        ...,\n        title=\"Cooling Coefficient of Performance\",\n        ge=0,\n    )\n    HeatingCOP: float = Field(\n        ...,\n        title=\"Heating Coefficient of Performance\",\n        ge=0,\n    )\n    HeatIsOn: BoolStr = Field(..., title=\"Heat is on\")\n    CoolIsOn: BoolStr = Field(..., title=\"Cool is on\")\n    MechVentIsOn: BoolStr = Field(..., title=\"Mechanical ventilation is on\")\n    HumidistatIsOn: BoolStr = Field(\n        ...,\n        title=\"Humidistat is on\",\n        validation_alias=\"HumidistatIsOn [Bool]\",\n    )\n    HeatingLimitType: IdealLoadsLimitType = Field(\n        ...,\n        title=\"Heating limit type\",\n        validation_alias=\"HeatingLimitType [enum]\",\n    )\n    CoolingLimitType: IdealLoadsLimitType = Field(\n        ...,\n        title=\"Cooling limit type\",\n        validation_alias=\"CoolingLimitType [enum]\",\n    )\n    MaxHeatingCapacity: float = Field(\n        ...,\n        title=\"Maximum heating capacity [W/m\u00b2]\",\n        validation_alias=\"MaxHeatingCapacity [W/m\u00b2]\",\n        ge=0,\n    )\n    MaxCoolingCapacity: float = Field(\n        ...,\n        title=\"Maximum cooling capacity [W/m\u00b2]\",\n        validation_alias=\"MaxCoolingCapacity [W/m\u00b2]\",\n        ge=0,\n    )\n    MaxHeatFlow: float = Field(\n        ...,\n        title=\"Maximum volumetric heat flow per flow area [m\u00b3/s/m\u00b2]\",\n        validation_alias=\"MaxHeatFlow [m\u00b3/s/m\u00b2]\",\n        ge=0,\n    )\n    MaxCoolFlow: float = Field(\n        ...,\n        title=\"Maximum volumetric cool flow per flow area [m\u00b3/s/m\u00b2]\",\n        validation_alias=\"MaxCoolFlow [m\u00b3/s/m\u00b2]\",\n        ge=0,\n    )\n    HeatingSchedule: str = Field(\n        ...,\n        title=\"Heating schedule\",\n        validation_alias=\"HeatingSchedule [Schedule name]\",\n    )\n    CoolingSchedule: str = Field(\n        ...,\n        title=\"Cooling schedule\",\n        validation_alias=\"CoolingSchedule [Schedule name]\",\n    )\n    MechVentSchedule: str = Field(\n        ...,\n        title=\"Mechanical ventilation schedule\",\n        validation_alias=\"MechVentSchedule [Schedule name]\",\n    )\n    EconomizerType: OutdoorAirEconomizerTypeType = Field(\n        ...,\n        title=\"Economizer type\",\n        validation_alias=\"EconomizerType [enum]\",\n    )\n    HeatRecoveryType: HeatRecoveryTypeType = Field(\n        ...,\n        title=\"Heat recovery type\",\n        validation_alias=\"HeatRecoveryType [enum]\",\n    )\n    HeatRecoveryEfficiencySensible: float = Field(\n        ...,\n        title=\"Heat recovery efficiency sensible\",\n        ge=0,\n        le=1,\n        validation_alias=\"HeatRecoveryEfficiencySensible [0-1]\",\n    )\n    HeatRecoveryEfficiencyLatent: float = Field(\n        ...,\n        title=\"Heat recovery efficiency latent\",\n        ge=0,\n        le=1,\n        validation_alias=\"HeatRecoveryEfficiencyLatent [0-1]\",\n    )\n    MinHumidity: float = Field(\n        ...,\n        title=\"Minimum humidity [%]\",\n        ge=0,\n        le=100,\n        validation_alias=\"MinHumidity [RH%]\",\n    )\n    MaxHumidity: float = Field(\n        ...,\n        title=\"Maximum humidity [%]\",\n        ge=0,\n        le=100,\n        validation_alias=\"MaxHumidity [RH%]\",\n    )\n    EMSFanEnergyIsOn: BoolStr = Field(..., title=\"EMS fan energy is on\")\n    FanPressureRise: float = Field(\n        ...,\n        title=\"Fan pressure rise [Pa]\",\n        ge=0,\n        validation_alias=\"FanPressureRise [Pa]\",\n    )\n    MaxHeatSupplyAirTemp: float = Field(\n        ...,\n        title=\"Maximum heat supply air temperature [\u00b0C]\",\n        ge=0,\n        validation_alias=\"MaxHeatSupplyAirTemp [\u00b0C]\",\n    )\n    MinCoolSupplyAirTemp: float = Field(\n        ...,\n        title=\"Minimum cool supply air temperature [\u00b0C]\",\n        ge=0,\n        validation_alias=\"MinCoolSupplyAirTemp [\u00b0C]\",\n    )\n    HeatingSizingFactor: float = Field(\n        ...,\n        title=\"Heating sizing factor\",\n        ge=0,\n        validation_alias=\"HeatingSizingFactor [Unitless]\",\n    )\n    CoolingSizingFactor: float = Field(\n        ...,\n        title=\"Cooling sizing factor\",\n        ge=0,\n        validation_alias=\"CoolingSizingFactor [Unitless]\",\n    )\n    Autosize: BoolStr = Field(\n        ...,\n        title=\"Autosize\",\n        validation_alias=\"Autosize [Bool]\",\n    )\n    HeatingFuelType: FuelType = Field(\n        ...,\n        title=\"Heating fuel type\",\n        validation_alias=\"HeatingFuelType [enum]\",\n    )\n    CoolingFuelType: FuelType = Field(\n        ...,\n        title=\"Cooling fuel type\",\n        validation_alias=\"CoolingFuelType [enum]\",\n    )\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        cond_scheds = set()\n\n        if self.HeatIsOn:\n            cond_scheds.add(self.HeatingSchedule)\n\n        if self.CoolIsOn:\n            cond_scheds.add(self.CoolingSchedule)\n        if not self.HeatingSetpointConstant and self.HeatIsOn:\n            cond_scheds.add(self.HeatingSetpointSchedule)\n\n        if not self.CoolingSetpointConstant and self.CoolIsOn:\n            cond_scheds.add(self.CoolingSetpointSchedule)\n\n        if self.MechVentIsOn:\n            cond_scheds.add(self.MechVentSchedule)\n\n        return cond_scheds\n\n    def add_conditioning_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n        \"\"\"Add conditioning to an IDF zone.\n\n        This constructs HVAC template objects which get assigned to the zone.\n\n        NB: currently, many of the climate studio parameters are ignored -\n        particularly the ones related to humidity control.\n\n        Args:\n            idf (IDF): The IDF object to add the conditioning to.\n            target_zone_name (str): The name of the zone to add the conditioning to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if self.HumidistatIsOn:\n            raise NotImplementedClimateStudioParameter(\n                \"HumidistatIsOn\",\n                self.Name,\n                \"Conditioning\",\n            )\n\n        if self.EMSFanEnergyIsOn:\n            raise NotImplementedClimateStudioParameter(\n                \"EMSFanEnergyIsOn\",\n                self.Name,\n                \"Conditioning\",\n            )\n\n        thermostat = HVACTemplateThermostat(\n            Name=f\"{self.Name}_{target_zone_name}_Thermostat\",\n            Heating_Setpoint_Schedule_Name=(\n                self.HeatingSetpointSchedule\n                if not self.HeatingSetpointConstant\n                else None\n            ),\n            Cooling_Setpoint_Schedule_Name=(\n                self.CoolingSetpointSchedule\n                if not self.CoolingSetpointConstant\n                else None\n            ),\n            Constant_Cooling_Setpoint=(\n                self.CoolingSetpoint if self.CoolingSetpointConstant else None\n            ),\n            Constant_Heating_Setpoint=(\n                self.HeatingSetpoint if self.HeatingSetpointConstant else None\n            ),\n        )\n\n        # TODO: better handling of alwayson/off schedule names\n        # TODO: better handling of mech vent schedule\n        logger.warning(\n            f\"Mechanical ventilation schedule is being ignored in zone {target_zone_name}.\"\n        )\n        hvac_template = HVACTemplateZoneIdealLoadsAirSystem(\n            Zone_Name=target_zone_name,\n            Template_Thermostat_Name=thermostat.Name,\n            System_Availability_Schedule_Name=\"AlwaysOn\",\n            Heating_Availability_Schedule_Name=(\n                self.HeatingSchedule if self.HeatIsOn else \"AlwaysOff\"\n            ),\n            Cooling_Availability_Schedule_Name=(\n                self.CoolingSchedule if self.CoolIsOn else None\n            ),\n            Maximum_Heating_Supply_Air_Temperature=self.MaxHeatSupplyAirTemp,\n            Maximum_Heating_Air_Flow_Rate=self.MaxHeatFlow\n            if not self.Autosize\n            else \"autosize\",\n            Maximum_Sensible_Heating_Capacity=self.MaxHeatingCapacity\n            if not self.Autosize\n            else \"autosize\",\n            Minimum_Cooling_Supply_Air_Temperature=self.MinCoolSupplyAirTemp,\n            Maximum_Cooling_Air_Flow_Rate=self.MaxCoolFlow\n            if not self.Autosize\n            else \"autosize\",\n            Maximum_Total_Cooling_Capacity=self.MaxCoolingCapacity\n            if not self.Autosize\n            else \"autosize\",\n            Heating_Limit=self.HeatingLimitType,\n            Cooling_Limit=self.CoolingLimitType,\n            Humidification_Control_Type=\"None\",\n            Outdoor_Air_Method=\"Sum\" if self.MechVentIsOn else \"None\",\n            Outdoor_Air_Flow_Rate_per_Person=self.MinFreshAirPerson\n            / 1000,  # convert to m3\n            Outdoor_Air_Flow_Rate_per_Zone_Floor_Area=self.MinFreshAirArea\n            / 1000,  # convert to m3\n            Outdoor_Air_Flow_Rate_per_Zone=0,\n            Demand_Controlled_Ventilation_Type=\"None\",\n            Outdoor_Air_Economizer_Type=self.EconomizerType,\n            Heat_Recovery_Type=self.HeatRecoveryType,\n            Sensible_Heat_Recovery_Effectiveness=self.HeatRecoveryEfficiencySensible,\n            Latent_Heat_Recovery_Effectiveness=self.HeatRecoveryEfficiencyLatent,\n        )\n\n        idf = thermostat.add(idf)\n        idf = hvac_template.add(idf)\n        if self.Autosize:\n            sizing = SizingParameters(\n                Heating_Sizing_Factor=self.HeatingSizingFactor,\n                Cooling_Sizing_Factor=self.CoolingSizingFactor,\n            )\n            idf = sizing.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneConditioning.schedule_names","title":"<code>schedule_names</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneConditioning.add_conditioning_to_idf_zone","title":"<code>add_conditioning_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Add conditioning to an IDF zone.</p> <p>This constructs HVAC template objects which get assigned to the zone.</p> <p>NB: currently, many of the climate studio parameters are ignored - particularly the ones related to humidity control.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the conditioning to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the conditioning to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def add_conditioning_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n    \"\"\"Add conditioning to an IDF zone.\n\n    This constructs HVAC template objects which get assigned to the zone.\n\n    NB: currently, many of the climate studio parameters are ignored -\n    particularly the ones related to humidity control.\n\n    Args:\n        idf (IDF): The IDF object to add the conditioning to.\n        target_zone_name (str): The name of the zone to add the conditioning to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if self.HumidistatIsOn:\n        raise NotImplementedClimateStudioParameter(\n            \"HumidistatIsOn\",\n            self.Name,\n            \"Conditioning\",\n        )\n\n    if self.EMSFanEnergyIsOn:\n        raise NotImplementedClimateStudioParameter(\n            \"EMSFanEnergyIsOn\",\n            self.Name,\n            \"Conditioning\",\n        )\n\n    thermostat = HVACTemplateThermostat(\n        Name=f\"{self.Name}_{target_zone_name}_Thermostat\",\n        Heating_Setpoint_Schedule_Name=(\n            self.HeatingSetpointSchedule\n            if not self.HeatingSetpointConstant\n            else None\n        ),\n        Cooling_Setpoint_Schedule_Name=(\n            self.CoolingSetpointSchedule\n            if not self.CoolingSetpointConstant\n            else None\n        ),\n        Constant_Cooling_Setpoint=(\n            self.CoolingSetpoint if self.CoolingSetpointConstant else None\n        ),\n        Constant_Heating_Setpoint=(\n            self.HeatingSetpoint if self.HeatingSetpointConstant else None\n        ),\n    )\n\n    # TODO: better handling of alwayson/off schedule names\n    # TODO: better handling of mech vent schedule\n    logger.warning(\n        f\"Mechanical ventilation schedule is being ignored in zone {target_zone_name}.\"\n    )\n    hvac_template = HVACTemplateZoneIdealLoadsAirSystem(\n        Zone_Name=target_zone_name,\n        Template_Thermostat_Name=thermostat.Name,\n        System_Availability_Schedule_Name=\"AlwaysOn\",\n        Heating_Availability_Schedule_Name=(\n            self.HeatingSchedule if self.HeatIsOn else \"AlwaysOff\"\n        ),\n        Cooling_Availability_Schedule_Name=(\n            self.CoolingSchedule if self.CoolIsOn else None\n        ),\n        Maximum_Heating_Supply_Air_Temperature=self.MaxHeatSupplyAirTemp,\n        Maximum_Heating_Air_Flow_Rate=self.MaxHeatFlow\n        if not self.Autosize\n        else \"autosize\",\n        Maximum_Sensible_Heating_Capacity=self.MaxHeatingCapacity\n        if not self.Autosize\n        else \"autosize\",\n        Minimum_Cooling_Supply_Air_Temperature=self.MinCoolSupplyAirTemp,\n        Maximum_Cooling_Air_Flow_Rate=self.MaxCoolFlow\n        if not self.Autosize\n        else \"autosize\",\n        Maximum_Total_Cooling_Capacity=self.MaxCoolingCapacity\n        if not self.Autosize\n        else \"autosize\",\n        Heating_Limit=self.HeatingLimitType,\n        Cooling_Limit=self.CoolingLimitType,\n        Humidification_Control_Type=\"None\",\n        Outdoor_Air_Method=\"Sum\" if self.MechVentIsOn else \"None\",\n        Outdoor_Air_Flow_Rate_per_Person=self.MinFreshAirPerson\n        / 1000,  # convert to m3\n        Outdoor_Air_Flow_Rate_per_Zone_Floor_Area=self.MinFreshAirArea\n        / 1000,  # convert to m3\n        Outdoor_Air_Flow_Rate_per_Zone=0,\n        Demand_Controlled_Ventilation_Type=\"None\",\n        Outdoor_Air_Economizer_Type=self.EconomizerType,\n        Heat_Recovery_Type=self.HeatRecoveryType,\n        Sensible_Heat_Recovery_Effectiveness=self.HeatRecoveryEfficiencySensible,\n        Latent_Heat_Recovery_Effectiveness=self.HeatRecoveryEfficiencyLatent,\n    )\n\n    idf = thermostat.add(idf)\n    idf = hvac_template.add(idf)\n    if self.Autosize:\n        sizing = SizingParameters(\n            Heating_Sizing_Factor=self.HeatingSizingFactor,\n            Cooling_Sizing_Factor=self.CoolingSizingFactor,\n        )\n        idf = sizing.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneConstruction","title":"<code>ZoneConstruction</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone construction object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ZoneConstruction(\n    NamedObject, ClimateStudioMetadata, extra=\"forbid\", populate_by_name=True\n):\n    \"\"\"Zone construction object.\"\"\"\n\n    RoofConstruction: str = Field(..., title=\"Roof construction object name\")\n    FacadeConstruction: str = Field(..., title=\"Facade construction object name\")\n    SlabConstruction: str = Field(..., title=\"Slab construction object name\")\n    PartitionConstruction: str = Field(..., title=\"Partition construction object name\")\n    ExternalFloorConstruction: str = Field(\n        ..., title=\"External floor construction object name\"\n    )\n    GroundSlabConstruction: str = Field(\n        ..., title=\"Ground slab construction object name\"\n    )\n    GroundWallConstruction: str = Field(\n        ..., title=\"Ground wall construction object name\"\n    )\n    InternalMassConstruction: str = Field(\n        ..., title=\"Internal mass construction object name\"\n    )\n    InternalMassIsOn: BoolStr = Field(..., title=\"Internal mass is on\")\n    InternalMassExposedAreaPerArea: float = Field(\n        ...,\n        title=\"Internal mass exposed area per area [m\u00b2/m\u00b2]\",\n        validation_alias=\"InternalMassExposedAreaPerArea [area / floor (m2/m2)]\",\n    )\n    GroundIsAdiabatic: BoolStr = Field(..., title=\"Ground is adiabatic\")\n    RoofIsAdiabatic: BoolStr = Field(..., title=\"Roof is adiabatic\")\n    FacadeIsAdiabatic: BoolStr = Field(..., title=\"Facade is adiabatic\")\n    SlabIsAdiabatic: BoolStr = Field(..., title=\"Slab is adiabatic\")\n    PartitionIsAdiabatic: BoolStr = Field(..., title=\"Partition is adiabatic\")\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneDefinition","title":"<code>ZoneDefinition</code>","text":"<p>               Bases: <code>NamedObject</code></p> <p>Zone definition object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ZoneDefinition(NamedObject, extra=\"forbid\"):\n    \"\"\"Zone definition object.\"\"\"\n\n    Loads: str = Field(..., title=\"Loads object name\")\n    Conditioning: str = Field(..., title=\"Conditioning object name\")\n    NaturalVentilation: str = Field(..., title=\"Natural ventilation object name\")\n    Constructions: str = Field(..., title=\"Construction object name\")\n    HotWater: str = Field(..., title=\"Hot water object name\")\n    Infiltration: str = Field(..., title=\"Infiltration object name\")\n    DataSource: NanStr = Field(\n        ..., title=\"Data source of the object\", validation_alias=\"Data Source\"\n    )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneEnvelope","title":"<code>ZoneEnvelope</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone envelope object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ZoneEnvelope(NamedObject, ClimateStudioMetadata, extra=\"forbid\"):\n    \"\"\"Zone envelope object.\"\"\"\n\n    Constructions: ZoneConstruction\n    Infiltration: ZoneInfiltration\n    WindowDefinition: WindowDefinition | None\n    WWR: float | None = Field(\n        default=0.1, description=\"Window to wall ratio\", ge=0, le=1\n    )\n    Foundation: Foundation | None\n    OtherSettings: OtherSettings | None\n    BuildingType: str | int = Field(..., title=\"Building type\")\n\n    # TODO: add envelope to idf zone\n    # (currently in builder)\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        win_sch = (\n            self.WindowDefinition.schedule_names if self.WindowDefinition else set()\n        )\n        return win_sch\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneEnvelope.schedule_names","title":"<code>schedule_names</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneHotWater","title":"<code>ZoneHotWater</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone Hot Water object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ZoneHotWater(\n    NamedObject, ClimateStudioMetadata, extra=\"ignore\", populate_by_name=True\n):\n    \"\"\"Zone Hot Water object.\"\"\"\n\n    DomHotWaterCOP: float = Field(\n        ...,\n        title=\"Domestic hot water coefficient of performance\",\n        ge=0,\n    )\n    WaterTemperatureInlet: float = Field(\n        ...,\n        title=\"Water temperature inlet [\u00b0C]\",\n        ge=0,\n        le=100,\n    )\n    WaterSupplyTemperature: float = Field(\n        ...,\n        title=\"Water supply temperature [\u00b0C]\",\n        ge=0,\n        le=100,\n    )\n    WaterSchedule: str = Field(..., title=\"Water schedule\")\n    FlowRatePerPerson: float = Field(\n        ..., title=\"Flow rate per person [m3/hr/p]\", ge=0, le=0.1\n    )\n    IsOn: BoolStr = Field(..., title=\"Is on\")\n    HotWaterFuelType: FuelType = Field(..., title=\"Hot water fuel type\")\n\n    @model_validator(mode=\"before\")\n    def validate_supply_greater_than_inlet(cls, values: dict[str, Any]):\n        \"\"\"Validate that the supply temperature is greater than the inlet temperature.\"\"\"\n        if values[\"WaterSupplyTemperature\"] &lt;= values[\"WaterTemperatureInlet\"]:\n            msg = \"Water supply temperature must be greater than the inlet temperature.\"\n            raise ValueError(msg)\n        return values\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        return {self.WaterSchedule} if self.IsOn else set()\n\n    def add_water_to_idf_zone(\n        self, idf: IDF, target_zone_name: str, total_ppl: float\n    ) -&gt; IDF:\n        \"\"\"Add the hot water to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the hot water to.\n            target_zone_name (str): The name of the zone to add the hot water to.\n            total_ppl (float): The total number of people in the zone.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if not self.IsOn:\n            return idf\n\n        total_flow_rate = self.FlowRatePerPerson * total_ppl  # m3/hr\n        total_flow_rate_per_s = total_flow_rate / 3600  # m3/s\n\n        lim = \"Temperature\"\n        if not idf.getobject(\"SCHEDULETYPELIMITS\", lim):\n            lim = ScheduleTypeLimits(\n                Name=\"Temperature\",\n                LowerLimit=-60,\n                UpperLimit=200,\n            )\n            lim.to_epbunch(idf)\n\n        target_temperature_schedule = Schedule.constant_schedule(\n            value=self.WaterSupplyTemperature,  # pyright: ignore [reportArgumentType]\n            Name=f\"{target_zone_name}_{self.Name}_TargetWaterTemperatureSch\",\n            Type=\"Temperature\",\n        )\n        inlet_temperature_schedule = Schedule.constant_schedule(\n            value=self.WaterTemperatureInlet,  # pyright: ignore [reportArgumentType]\n            Name=f\"{target_zone_name}_{self.Name}_InletWaterTemperatureSch\",\n            Type=\"Temperature\",\n        )\n\n        target_temperature_yr_schedule, *_ = (\n            target_temperature_schedule.to_year_week_day()\n        )\n        inlet_temperature_yr_schedule, *_ = (\n            inlet_temperature_schedule.to_year_week_day()\n        )\n\n        target_temperature_yr_schedule.to_epbunch(idf)\n        inlet_temperature_yr_schedule.to_epbunch(idf)\n\n        hot_water = WaterUseEquipment(\n            Name=f\"{target_zone_name}_{self.Name}_HotWater\",\n            EndUse_Subcategory=\"Domestic Hot Water\",\n            Peak_Flow_Rate=total_flow_rate_per_s,\n            Flow_Rate_Fraction_Schedule_Name=self.WaterSchedule,\n            Zone_Name=target_zone_name,\n            Target_Temperature_Schedule_Name=target_temperature_yr_schedule.Name,\n            Hot_Water_Supply_Temperature_Schedule_Name=target_temperature_schedule.Name,\n            Cold_Water_Supply_Temperature_Schedule_Name=inlet_temperature_schedule.Name,\n            Sensible_Fraction_Schedule_Name=None,\n            Latent_Fraction_Schedule_Name=None,\n        )\n        idf = hot_water.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneHotWater.schedule_names","title":"<code>schedule_names</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneHotWater.add_water_to_idf_zone","title":"<code>add_water_to_idf_zone(idf, target_zone_name, total_ppl)</code>","text":"<p>Add the hot water to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the hot water to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the hot water to.</p> required <code>total_ppl</code> <code>float</code> <p>The total number of people in the zone.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def add_water_to_idf_zone(\n    self, idf: IDF, target_zone_name: str, total_ppl: float\n) -&gt; IDF:\n    \"\"\"Add the hot water to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the hot water to.\n        target_zone_name (str): The name of the zone to add the hot water to.\n        total_ppl (float): The total number of people in the zone.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if not self.IsOn:\n        return idf\n\n    total_flow_rate = self.FlowRatePerPerson * total_ppl  # m3/hr\n    total_flow_rate_per_s = total_flow_rate / 3600  # m3/s\n\n    lim = \"Temperature\"\n    if not idf.getobject(\"SCHEDULETYPELIMITS\", lim):\n        lim = ScheduleTypeLimits(\n            Name=\"Temperature\",\n            LowerLimit=-60,\n            UpperLimit=200,\n        )\n        lim.to_epbunch(idf)\n\n    target_temperature_schedule = Schedule.constant_schedule(\n        value=self.WaterSupplyTemperature,  # pyright: ignore [reportArgumentType]\n        Name=f\"{target_zone_name}_{self.Name}_TargetWaterTemperatureSch\",\n        Type=\"Temperature\",\n    )\n    inlet_temperature_schedule = Schedule.constant_schedule(\n        value=self.WaterTemperatureInlet,  # pyright: ignore [reportArgumentType]\n        Name=f\"{target_zone_name}_{self.Name}_InletWaterTemperatureSch\",\n        Type=\"Temperature\",\n    )\n\n    target_temperature_yr_schedule, *_ = (\n        target_temperature_schedule.to_year_week_day()\n    )\n    inlet_temperature_yr_schedule, *_ = (\n        inlet_temperature_schedule.to_year_week_day()\n    )\n\n    target_temperature_yr_schedule.to_epbunch(idf)\n    inlet_temperature_yr_schedule.to_epbunch(idf)\n\n    hot_water = WaterUseEquipment(\n        Name=f\"{target_zone_name}_{self.Name}_HotWater\",\n        EndUse_Subcategory=\"Domestic Hot Water\",\n        Peak_Flow_Rate=total_flow_rate_per_s,\n        Flow_Rate_Fraction_Schedule_Name=self.WaterSchedule,\n        Zone_Name=target_zone_name,\n        Target_Temperature_Schedule_Name=target_temperature_yr_schedule.Name,\n        Hot_Water_Supply_Temperature_Schedule_Name=target_temperature_schedule.Name,\n        Cold_Water_Supply_Temperature_Schedule_Name=inlet_temperature_schedule.Name,\n        Sensible_Fraction_Schedule_Name=None,\n        Latent_Fraction_Schedule_Name=None,\n    )\n    idf = hot_water.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneHotWater.validate_supply_greater_than_inlet","title":"<code>validate_supply_greater_than_inlet(values)</code>","text":"<p>Validate that the supply temperature is greater than the inlet temperature.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>@model_validator(mode=\"before\")\ndef validate_supply_greater_than_inlet(cls, values: dict[str, Any]):\n    \"\"\"Validate that the supply temperature is greater than the inlet temperature.\"\"\"\n    if values[\"WaterSupplyTemperature\"] &lt;= values[\"WaterTemperatureInlet\"]:\n        msg = \"Water supply temperature must be greater than the inlet temperature.\"\n        raise ValueError(msg)\n    return values\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneInfiltration","title":"<code>ZoneInfiltration</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone infiltration object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ZoneInfiltration(\n    NamedObject, ClimateStudioMetadata, extra=\"forbid\", populate_by_name=True\n):\n    \"\"\"Zone infiltration object.\"\"\"\n\n    InfiltrationIsOn: BoolStr = Field(..., title=\"Infiltration is on\")\n    InfiltrationConstantCoefficient: float = Field(\n        ...,\n        title=\"Infiltration constant coefficient\",\n    )\n    InfiltrationTemperatureCoefficient: float = Field(\n        ...,\n        title=\"Infiltration temperature coefficient\",\n    )\n    InfiltrationWindVelocityCoefficient: float = Field(\n        ...,\n        title=\"Infiltration wind velocity coefficient\",\n    )\n    InfiltrationWindVelocitySquaredCoefficient: float = Field(\n        ...,\n        title=\"Infiltration wind velocity squared coefficient\",\n    )\n    AFN_AirMassFlowCoefficient_Crack: float = Field(\n        ...,\n        title=\"AFN air mass flow coefficient crack\",\n    )\n\n    InfiltrationAch: float = Field(\n        ...,\n        title=\"Infiltration air changes per hour\",\n        ge=0,\n        validation_alias=\"InfiltrationAch [ACH]\",\n    )\n    InfiltrationFlowPerExteriorSurfaceArea: float = Field(\n        ...,\n        title=\"Infiltration flow per exterior surface area\",\n        ge=0,\n        validation_alias=\"InfiltrationFlowPerExteriorSurfaceArea [m3/s/m2]\",\n    )\n    CalculationMethod: InfDesignFlowRateCalculationMethodType = Field(\n        ...,\n        title=\"Calculation method\",\n    )\n\n    def add_infiltration_to_idf_zone(\n        self, idf: IDF, target_zone_or_zone_list_name: str\n    ):\n        \"\"\"Add infiltration to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the infiltration to.\n            target_zone_or_zone_list_name (str): The name of the zone or zone list to add the infiltration to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        if not self.InfiltrationIsOn:\n            return idf\n\n        infiltration_schedule_name = (\n            f\"{target_zone_or_zone_list_name}_{self.Name}_Infiltration_Schedule\"\n        )\n        schedule = Schedule.constant_schedule(\n            value=1, Name=infiltration_schedule_name, Type=\"Fraction\"\n        )\n        inf_schedule, *_ = schedule.to_year_week_day()\n        inf_schedule.to_epbunch(idf)\n        inf = ZoneInfiltrationDesignFlowRate(\n            Name=f\"{target_zone_or_zone_list_name}_{self.Name}_Infiltration\",\n            Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n            Schedule_Name=inf_schedule.Name,\n            Design_Flow_Rate_Calculation_Method=self.CalculationMethod,\n            Flow_Rate_per_Exterior_Surface_Area=self.InfiltrationFlowPerExteriorSurfaceArea,\n            Air_Changes_per_Hour=self.InfiltrationAch,\n            Flow_Rate_per_Floor_Area=None,\n            Design_Flow_Rate=None,\n            Constant_Term_Coefficient=self.InfiltrationConstantCoefficient,\n            Temperature_Term_Coefficient=self.InfiltrationTemperatureCoefficient,\n            Velocity_Term_Coefficient=self.InfiltrationWindVelocityCoefficient,\n            Velocity_Squared_Term_Coefficient=self.InfiltrationWindVelocitySquaredCoefficient,\n        )\n        idf = inf.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneInfiltration.add_infiltration_to_idf_zone","title":"<code>add_infiltration_to_idf_zone(idf, target_zone_or_zone_list_name)</code>","text":"<p>Add infiltration to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the infiltration to.</p> required <code>target_zone_or_zone_list_name</code> <code>str</code> <p>The name of the zone or zone list to add the infiltration to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def add_infiltration_to_idf_zone(\n    self, idf: IDF, target_zone_or_zone_list_name: str\n):\n    \"\"\"Add infiltration to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the infiltration to.\n        target_zone_or_zone_list_name (str): The name of the zone or zone list to add the infiltration to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    if not self.InfiltrationIsOn:\n        return idf\n\n    infiltration_schedule_name = (\n        f\"{target_zone_or_zone_list_name}_{self.Name}_Infiltration_Schedule\"\n    )\n    schedule = Schedule.constant_schedule(\n        value=1, Name=infiltration_schedule_name, Type=\"Fraction\"\n    )\n    inf_schedule, *_ = schedule.to_year_week_day()\n    inf_schedule.to_epbunch(idf)\n    inf = ZoneInfiltrationDesignFlowRate(\n        Name=f\"{target_zone_or_zone_list_name}_{self.Name}_Infiltration\",\n        Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n        Schedule_Name=inf_schedule.Name,\n        Design_Flow_Rate_Calculation_Method=self.CalculationMethod,\n        Flow_Rate_per_Exterior_Surface_Area=self.InfiltrationFlowPerExteriorSurfaceArea,\n        Air_Changes_per_Hour=self.InfiltrationAch,\n        Flow_Rate_per_Floor_Area=None,\n        Design_Flow_Rate=None,\n        Constant_Term_Coefficient=self.InfiltrationConstantCoefficient,\n        Temperature_Term_Coefficient=self.InfiltrationTemperatureCoefficient,\n        Velocity_Term_Coefficient=self.InfiltrationWindVelocityCoefficient,\n        Velocity_Squared_Term_Coefficient=self.InfiltrationWindVelocitySquaredCoefficient,\n    )\n    idf = inf.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneLoad","title":"<code>ZoneLoad</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone load object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ZoneLoad(\n    NamedObject, ClimateStudioMetadata, extra=\"forbid\", populate_by_name=True\n):\n    \"\"\"Zone load object.\"\"\"\n\n    BuildingType: str | int = Field(..., title=\"Building type\")\n    PeopleDensity: float = Field(\n        ...,\n        title=\"People density [people/m\u00b2]\",\n        ge=0,\n        validation_alias=\"PeopleDensity [P/m\u00b2]\",\n    )\n    MetabolicRate: float = Field(\n        ...,\n        title=\"Metabolic rate [met]\",\n        ge=0,\n        validation_alias=\"MetabolicRate [met]\",\n    )\n    AirspeedSchedule: str = Field(\n        ..., title=\"Airspeed schedule\", validation_alias=\"AirspeedSchedule [m/s]\"\n    )\n    EquipmentPowerDensity: float = Field(\n        ...,\n        title=\"Equipment power density [W/m\u00b2]\",\n        ge=0,\n        validation_alias=\"EquipmentPowerDensity [W/m\u00b2]\",\n    )\n    LightingPowerDensity: float = Field(\n        ...,\n        title=\"Lighting power density [W/m\u00b2]\",\n        ge=0,\n        validation_alias=\"LightingPowerDensity [W/m\u00b2]\",\n    )\n    IlluminanceTarget: float = Field(\n        ...,\n        title=\"Illuminance target [lux]\",\n        ge=0,\n        validation_alias=\"IlluminanceTarget [Lux]\",\n    )\n    OccupancySchedule: str = Field(..., title=\"Occupancy schedule\")\n    EquipmentAvailabilitySchedule: str = Field(\n        ...,\n        title=\"Equipment availability schedule\",\n        validation_alias=\"EquipmentAvailibilitySchedule\",  # known typo in cs\n    )\n    LightsAvailabilitySchedule: str = Field(\n        ...,\n        title=\"Lighting availability schedule\",\n        validation_alias=\"LightsAvailibilitySchedule\",  # known typo in cs\n    )\n    DimmingType: DimmingTypeType = Field(\n        ...,\n        title=\"Dimming type\",\n    )\n    PeopleIsOn: BoolStr = Field(..., title=\"People are on\")\n    EquipmentIsOn: BoolStr = Field(..., title=\"Equipment is on\")\n    LightsIsOn: BoolStr = Field(..., title=\"Lights are on\")\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        return {\n            # self.AirspeedSchedule,\n            self.OccupancySchedule,\n            self.EquipmentAvailabilitySchedule,\n            self.LightsAvailabilitySchedule,\n        }\n\n    @property\n    def MetabolicRate_W(self):\n        \"\"\"Get the metabolic rate in Watts.\"\"\"\n        avg_human_weight_kg = 80\n        conversion_factor = 1.162  # W/kg\n        return self.MetabolicRate * avg_human_weight_kg * conversion_factor\n\n    def add_lights_to_idf_zone(\n        self, idf: IDF, target_zone_or_zone_list_name: str\n    ) -&gt; IDF:\n        \"\"\"Add lights to an IDF zone.\n\n        Note that this makes some assumptions about the fraction visible/radiant/replaceable.\n\n        Args:\n            idf (IDF): The IDF object to add the lights to.\n            target_zone_or_zone_list_name (str): The name of the zone or zone list to add the lights to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if not self.LightsIsOn:\n            return idf\n\n        if self.DimmingType != \"Off\":\n            raise NotImplementedClimateStudioParameter(\n                \"DimmingType:On\", self.Name, \"Lights\"\n            )\n\n        logger.warning(\n            f\"Adding lights to zone with schedule {self.LightsAvailabilitySchedule}.  Make sure this schedule exists.\"\n        )\n\n        logger.warning(\n            f\"Ignoring IlluminanceTarget for zone(s) {target_zone_or_zone_list_name}.\"\n        )\n        lights = Lights(\n            Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_Lights\",\n            Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n            Schedule_Name=self.LightsAvailabilitySchedule,\n            Design_Level_Calculation_Method=\"Watts/Area\",\n            Watts_per_Zone_Floor_Area=self.LightingPowerDensity,\n            Watts_per_Person=None,\n            Lighting_Level=None,\n            Return_Air_Fraction=0,\n            Fraction_Radiant=0.42,\n            Fraction_Visible=0.18,\n            Fraction_Replaceable=1,\n            EndUse_Subcategory=None,\n        )\n        idf = lights.add(idf)\n        return idf\n\n    def add_people_to_idf_zone(\n        self, idf: IDF, target_zone_or_zone_list_name: str\n    ) -&gt; IDF:\n        \"\"\"Add people to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the people to.\n            target_zone_or_zone_list_name (str): The name of the zone or zone list to add the people to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if not self.PeopleIsOn:\n            return idf\n\n        activity_sch_name = (\n            f\"{target_zone_or_zone_list_name}_{self.Name}_Activity_Schedule\"\n        )\n        lim = \"AnyNumber\"\n        if not idf.getobject(\"SCHEDULETYPELIMITS\", lim):\n            lim = ScheduleTypeLimits(\n                Name=\"AnyNumber\",\n                LowerLimit=None,\n                UpperLimit=None,\n            )\n            lim.to_epbunch(idf)\n        activity_sch = Schedule.from_values(\n            Values=[self.MetabolicRate_W] * 8760,\n            Name=activity_sch_name,\n            Type=lim,  # pyright: ignore [reportArgumentType]\n        )\n        activity_sch_year, *_ = activity_sch.to_year_week_day()\n        activity_sch_year.to_epbunch(idf)\n\n        logger.warning(\n            f\"Adding people to zone with schedule {self.OccupancySchedule}.  Make sure this schedule exists.\"\n        )\n        logger.warning(\n            f\"Ignoring AirspeedSchedule for zone(s) {target_zone_or_zone_list_name}.\"\n        )\n        people = People(\n            Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_People\",\n            Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n            Number_of_People_Schedule_Name=self.OccupancySchedule,\n            Number_of_People_Calculation_Method=\"People/Area\",\n            Number_of_People=None,\n            Floor_Area_per_Person=None,\n            People_per_Floor_Area=self.PeopleDensity,\n            Fraction_Radiant=0.3,\n            Sensible_Heat_Fraction=\"autocalculate\",\n            Activity_Level_Schedule_Name=activity_sch_year.Name,\n        )\n\n        idf = people.add(idf)\n        return idf\n\n    def add_equipment_to_idf_zone(\n        self, idf: IDF, target_zone_or_zone_list_name: str\n    ) -&gt; IDF:\n        \"\"\"Add equipment to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the equipment to.\n            target_zone_or_zone_list_name (str): The name of the zone or zone list to add the equipment to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if not self.EquipmentIsOn:\n            return idf\n\n        logger.warning(\n            f\"Adding equipment to zone with schedule {self.EquipmentAvailabilitySchedule}.  Make sure this schedule exists.\"\n        )\n\n        equipment = ElectricEquipment(\n            Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_Equipment\",\n            Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n            Schedule_Name=self.EquipmentAvailabilitySchedule,\n            Design_Level_Calculation_Method=\"Watts/Area\",\n            Watts_per_Zone_Floor_Area=self.EquipmentPowerDensity,\n            Watts_per_Person=None,\n            Fraction_Latent=0,\n            Fraction_Radiant=0.2,\n            Fraction_Lost=0,\n            EndUse_Subcategory=None,\n        )\n        idf = equipment.add(idf)\n        return idf\n\n    def add_loads_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n        \"\"\"Add the loads to an IDF zone.\n\n        This will add the people, equipment, and lights to the zone.\n\n        nb: remember to add the schedules.\n\n        Args:\n            idf (IDF): The IDF object to add the loads to.\n            target_zone_name (str): The name of the zone to add the loads to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        idf = self.add_lights_to_idf_zone(idf, target_zone_name)\n        idf = self.add_people_to_idf_zone(idf, target_zone_name)\n        idf = self.add_equipment_to_idf_zone(idf, target_zone_name)\n        return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneLoad.MetabolicRate_W","title":"<code>MetabolicRate_W</code>  <code>property</code>","text":"<p>Get the metabolic rate in Watts.</p>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneLoad.schedule_names","title":"<code>schedule_names</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneLoad.add_equipment_to_idf_zone","title":"<code>add_equipment_to_idf_zone(idf, target_zone_or_zone_list_name)</code>","text":"<p>Add equipment to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the equipment to.</p> required <code>target_zone_or_zone_list_name</code> <code>str</code> <p>The name of the zone or zone list to add the equipment to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def add_equipment_to_idf_zone(\n    self, idf: IDF, target_zone_or_zone_list_name: str\n) -&gt; IDF:\n    \"\"\"Add equipment to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the equipment to.\n        target_zone_or_zone_list_name (str): The name of the zone or zone list to add the equipment to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if not self.EquipmentIsOn:\n        return idf\n\n    logger.warning(\n        f\"Adding equipment to zone with schedule {self.EquipmentAvailabilitySchedule}.  Make sure this schedule exists.\"\n    )\n\n    equipment = ElectricEquipment(\n        Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_Equipment\",\n        Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n        Schedule_Name=self.EquipmentAvailabilitySchedule,\n        Design_Level_Calculation_Method=\"Watts/Area\",\n        Watts_per_Zone_Floor_Area=self.EquipmentPowerDensity,\n        Watts_per_Person=None,\n        Fraction_Latent=0,\n        Fraction_Radiant=0.2,\n        Fraction_Lost=0,\n        EndUse_Subcategory=None,\n    )\n    idf = equipment.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneLoad.add_lights_to_idf_zone","title":"<code>add_lights_to_idf_zone(idf, target_zone_or_zone_list_name)</code>","text":"<p>Add lights to an IDF zone.</p> <p>Note that this makes some assumptions about the fraction visible/radiant/replaceable.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the lights to.</p> required <code>target_zone_or_zone_list_name</code> <code>str</code> <p>The name of the zone or zone list to add the lights to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def add_lights_to_idf_zone(\n    self, idf: IDF, target_zone_or_zone_list_name: str\n) -&gt; IDF:\n    \"\"\"Add lights to an IDF zone.\n\n    Note that this makes some assumptions about the fraction visible/radiant/replaceable.\n\n    Args:\n        idf (IDF): The IDF object to add the lights to.\n        target_zone_or_zone_list_name (str): The name of the zone or zone list to add the lights to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if not self.LightsIsOn:\n        return idf\n\n    if self.DimmingType != \"Off\":\n        raise NotImplementedClimateStudioParameter(\n            \"DimmingType:On\", self.Name, \"Lights\"\n        )\n\n    logger.warning(\n        f\"Adding lights to zone with schedule {self.LightsAvailabilitySchedule}.  Make sure this schedule exists.\"\n    )\n\n    logger.warning(\n        f\"Ignoring IlluminanceTarget for zone(s) {target_zone_or_zone_list_name}.\"\n    )\n    lights = Lights(\n        Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_Lights\",\n        Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n        Schedule_Name=self.LightsAvailabilitySchedule,\n        Design_Level_Calculation_Method=\"Watts/Area\",\n        Watts_per_Zone_Floor_Area=self.LightingPowerDensity,\n        Watts_per_Person=None,\n        Lighting_Level=None,\n        Return_Air_Fraction=0,\n        Fraction_Radiant=0.42,\n        Fraction_Visible=0.18,\n        Fraction_Replaceable=1,\n        EndUse_Subcategory=None,\n    )\n    idf = lights.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneLoad.add_loads_to_idf_zone","title":"<code>add_loads_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Add the loads to an IDF zone.</p> <p>This will add the people, equipment, and lights to the zone.</p> <p>nb: remember to add the schedules.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the loads to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the loads to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def add_loads_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n    \"\"\"Add the loads to an IDF zone.\n\n    This will add the people, equipment, and lights to the zone.\n\n    nb: remember to add the schedules.\n\n    Args:\n        idf (IDF): The IDF object to add the loads to.\n        target_zone_name (str): The name of the zone to add the loads to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    idf = self.add_lights_to_idf_zone(idf, target_zone_name)\n    idf = self.add_people_to_idf_zone(idf, target_zone_name)\n    idf = self.add_equipment_to_idf_zone(idf, target_zone_name)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneLoad.add_people_to_idf_zone","title":"<code>add_people_to_idf_zone(idf, target_zone_or_zone_list_name)</code>","text":"<p>Add people to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the people to.</p> required <code>target_zone_or_zone_list_name</code> <code>str</code> <p>The name of the zone or zone list to add the people to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def add_people_to_idf_zone(\n    self, idf: IDF, target_zone_or_zone_list_name: str\n) -&gt; IDF:\n    \"\"\"Add people to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the people to.\n        target_zone_or_zone_list_name (str): The name of the zone or zone list to add the people to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if not self.PeopleIsOn:\n        return idf\n\n    activity_sch_name = (\n        f\"{target_zone_or_zone_list_name}_{self.Name}_Activity_Schedule\"\n    )\n    lim = \"AnyNumber\"\n    if not idf.getobject(\"SCHEDULETYPELIMITS\", lim):\n        lim = ScheduleTypeLimits(\n            Name=\"AnyNumber\",\n            LowerLimit=None,\n            UpperLimit=None,\n        )\n        lim.to_epbunch(idf)\n    activity_sch = Schedule.from_values(\n        Values=[self.MetabolicRate_W] * 8760,\n        Name=activity_sch_name,\n        Type=lim,  # pyright: ignore [reportArgumentType]\n    )\n    activity_sch_year, *_ = activity_sch.to_year_week_day()\n    activity_sch_year.to_epbunch(idf)\n\n    logger.warning(\n        f\"Adding people to zone with schedule {self.OccupancySchedule}.  Make sure this schedule exists.\"\n    )\n    logger.warning(\n        f\"Ignoring AirspeedSchedule for zone(s) {target_zone_or_zone_list_name}.\"\n    )\n    people = People(\n        Name=f\"{target_zone_or_zone_list_name}_{self.Name.join('_')}_People\",\n        Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n        Number_of_People_Schedule_Name=self.OccupancySchedule,\n        Number_of_People_Calculation_Method=\"People/Area\",\n        Number_of_People=None,\n        Floor_Area_per_Person=None,\n        People_per_Floor_Area=self.PeopleDensity,\n        Fraction_Radiant=0.3,\n        Sensible_Heat_Fraction=\"autocalculate\",\n        Activity_Level_Schedule_Name=activity_sch_year.Name,\n    )\n\n    idf = people.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneUse","title":"<code>ZoneUse</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>ClimateStudioMetadata</code></p> <p>Zone use object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>class ZoneUse(\n    NamedObject, ClimateStudioMetadata, extra=\"forbid\", populate_by_name=True\n):\n    \"\"\"Zone use object.\"\"\"\n\n    Conditioning: ZoneConditioning\n    Loads: ZoneLoad\n    HotWater: ZoneHotWater\n\n    def add_loads_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n        \"\"\"Add the loads to an IDF zone.\n\n        This will add the people, equipment, and lights to the zone.\n\n        nb: remember to add the schedules.\n\n        Args:\n            idf (IDF): The IDF object to add the loads to.\n            target_zone_name (str): The name of the zone to add the loads to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        idf = self.Loads.add_loads_to_idf_zone(idf, target_zone_name)\n        return idf\n\n    def add_conditioning_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n        \"\"\"Add the conditioning to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the conditioning to.\n            target_zone_name (str): The name of the zone to add the conditioning to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        idf = self.Conditioning.add_conditioning_to_idf_zone(idf, target_zone_name)\n        return idf\n\n    def add_hot_water_to_idf_zone(\n        self, idf: IDF, target_zone_name: str, zone_area: float\n    ) -&gt; IDF:\n        \"\"\"Add the hot water to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the hot water to.\n            target_zone_name (str): The name of the zone to add the hot water to.\n            zone_area (float): The area of the zone.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n\n        \"\"\"\n        total_people = self.Loads.PeopleDensity * zone_area\n        idf = self.HotWater.add_water_to_idf_zone(\n            idf, target_zone_name, total_ppl=total_people\n        )\n        return idf\n\n    def add_space_use_to_idf_zone(self, idf: IDF, target_zone: str | ZoneList) -&gt; IDF:\n        \"\"\"Add the use to an IDF zone.\n\n        This will add the loads and conditioning to the zone.\n\n        Args:\n            idf (IDF): The IDF object to add the use to.\n            target_zone (str | ZoneList): The name of the zone to add the use to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        loads_target = target_zone if isinstance(target_zone, str) else target_zone.Name\n        idf = self.add_loads_to_idf_zone(idf, loads_target)\n        if isinstance(target_zone, str):\n            idf = self.add_conditioning_to_idf_zone(idf, target_zone)\n        else:\n            for zone in target_zone.Names:\n                idf = self.add_conditioning_to_idf_zone(idf, zone)\n        return idf\n\n    @property\n    def schedule_names(self) -&gt; set[str]:\n        \"\"\"Get the schedule names used in the object.\n\n        Returns:\n            set[str]: The schedule names.\n        \"\"\"\n        return (\n            self.Loads.schedule_names\n            | self.Conditioning.schedule_names\n            | self.HotWater.schedule_names\n        )\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneUse.schedule_names","title":"<code>schedule_names</code>  <code>property</code>","text":"<p>Get the schedule names used in the object.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The schedule names.</p>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneUse.add_conditioning_to_idf_zone","title":"<code>add_conditioning_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Add the conditioning to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the conditioning to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the conditioning to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def add_conditioning_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n    \"\"\"Add the conditioning to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the conditioning to.\n        target_zone_name (str): The name of the zone to add the conditioning to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    idf = self.Conditioning.add_conditioning_to_idf_zone(idf, target_zone_name)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneUse.add_hot_water_to_idf_zone","title":"<code>add_hot_water_to_idf_zone(idf, target_zone_name, zone_area)</code>","text":"<p>Add the hot water to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the hot water to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the hot water to.</p> required <code>zone_area</code> <code>float</code> <p>The area of the zone.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def add_hot_water_to_idf_zone(\n    self, idf: IDF, target_zone_name: str, zone_area: float\n) -&gt; IDF:\n    \"\"\"Add the hot water to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the hot water to.\n        target_zone_name (str): The name of the zone to add the hot water to.\n        zone_area (float): The area of the zone.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n\n    \"\"\"\n    total_people = self.Loads.PeopleDensity * zone_area\n    idf = self.HotWater.add_water_to_idf_zone(\n        idf, target_zone_name, total_ppl=total_people\n    )\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneUse.add_loads_to_idf_zone","title":"<code>add_loads_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Add the loads to an IDF zone.</p> <p>This will add the people, equipment, and lights to the zone.</p> <p>nb: remember to add the schedules.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the loads to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the loads to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def add_loads_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n    \"\"\"Add the loads to an IDF zone.\n\n    This will add the people, equipment, and lights to the zone.\n\n    nb: remember to add the schedules.\n\n    Args:\n        idf (IDF): The IDF object to add the loads to.\n        target_zone_name (str): The name of the zone to add the loads to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    idf = self.Loads.add_loads_to_idf_zone(idf, target_zone_name)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.ZoneUse.add_space_use_to_idf_zone","title":"<code>add_space_use_to_idf_zone(idf, target_zone)</code>","text":"<p>Add the use to an IDF zone.</p> <p>This will add the loads and conditioning to the zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the use to.</p> required <code>target_zone</code> <code>str | ZoneList</code> <p>The name of the zone to add the use to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def add_space_use_to_idf_zone(self, idf: IDF, target_zone: str | ZoneList) -&gt; IDF:\n    \"\"\"Add the use to an IDF zone.\n\n    This will add the loads and conditioning to the zone.\n\n    Args:\n        idf (IDF): The IDF object to add the use to.\n        target_zone (str | ZoneList): The name of the zone to add the use to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    loads_target = target_zone if isinstance(target_zone, str) else target_zone.Name\n    idf = self.add_loads_to_idf_zone(idf, loads_target)\n    if isinstance(target_zone, str):\n        idf = self.add_conditioning_to_idf_zone(idf, target_zone)\n    else:\n        for zone in target_zone.Names:\n            idf = self.add_conditioning_to_idf_zone(idf, zone)\n    return idf\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.extract_sch","title":"<code>extract_sch(year_schedules, schedule_name)</code>","text":"<p>Extract a schedule from a climate studio schedule dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>year_schedules</code> <code>DataFrame</code> <p>Dataframe of year schedules</p> required <code>schedule_name</code> <code>str</code> <p>Name of the schedule</p> required <p>Returns:</p> Name Type Description <code>Schedule</code> <code>Schedule</code> <p>Extracted schedule</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def extract_sch(year_schedules: pd.DataFrame, schedule_name: str) -&gt; Schedule:\n    \"\"\"Extract a schedule from a climate studio schedule dataframe.\n\n    Args:\n        year_schedules (pd.DataFrame): Dataframe of year schedules\n        schedule_name (str): Name of the schedule\n\n    Returns:\n        Schedule: Extracted schedule\n    \"\"\"\n    sched_meta = year_schedules.head(5)\n    sched_meta.index = pd.Index([\n        \"Type\",\n        \"Periodicity\",\n        \"Category\",\n        \"Data Source\",\n        \"Comment\",\n    ])\n    meta = sched_meta[schedule_name]\n    sched_type = cast(str, meta[\"Type\"])\n    last_ix = (\n        8760\n        if meta[\"Periodicity\"] == \"FullYear\"\n        else (\n            24 * 7\n            if meta[\"Periodicity\"] == \"RepeatingWeek\"\n            else (24 if meta[\"Periodicity\"] == \"RepeatingDay\" else 1)\n        )\n    )\n    sched = year_schedules[schedule_name]\n    sched_vals = sched.iloc[5:]\n    sched_vals = np.array(sched_vals[:last_ix].astype(float).values)\n    if len(sched_vals) not in [1, 24, 24 * 7, 8760]:\n        raise ScheduleParseError(schedule_name)\n    if sched_type.lower() not in [\n        \"fraction\",\n        \"temperature\",\n        \"any number\",\n        \"anynumber\",\n        \"on/off\",\n    ]:\n        raise ScheduleParseError(f\"{schedule_name}:{meta['Type']}\")\n    if sched_type.lower() in [\"any number\", \"anynumber\"]:\n        meta[\"Type\"] = ScheduleTypeLimits(\n            Name=meta[\"Type\"], LowerLimit=None, UpperLimit=None\n        )\n    n_repeats_needed = 8760 // len(sched_vals) + 1\n    repeated_schedule = np.tile(sched_vals, n_repeats_needed)[:8760]\n    sched = Schedule.from_values(\n        Name=schedule_name,\n        Values=repeated_schedule.tolist(),\n        Type=meta[\"Type\"],  # pyright: ignore [reportArgumentType]\n    )\n    return sched\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.nan_to_none_or_str","title":"<code>nan_to_none_or_str(v)</code>","text":"<p>Converts NaN to None and leaves strings as is.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Any</code> <p>Value to convert</p> required <p>Returns:</p> Name Type Description <code>v</code> <code>None | str | Any</code> <p>Converted value</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def nan_to_none_or_str(v: Any) -&gt; str | None | Any:\n    \"\"\"Converts NaN to None and leaves strings as is.\n\n    Args:\n        v (Any): Value to convert\n\n    Returns:\n        v (None | str | Any): Converted value\n    \"\"\"\n    if isinstance(v, str):\n        return v\n    if v is None:\n        return None\n    if np.isnan(v):\n        return None\n    return v\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.str_to_bool","title":"<code>str_to_bool(v)</code>","text":"<p>Converts a string to a boolean if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str | bool</code> <p>Value to convert</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Converted value</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def str_to_bool(v: str | bool) -&gt; bool:\n    \"\"\"Converts a string to a boolean if necessary.\n\n    Args:\n        v (str | bool): Value to convert\n\n    Returns:\n        bool: Converted value\n    \"\"\"\n    if isinstance(v, bool):\n        return v\n    elif v.lower() == \"true\":\n        return True\n    elif v.lower() == \"false\":\n        return False\n    else:\n        return False\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.str_to_float_list","title":"<code>str_to_float_list(v)</code>","text":"<p>Converts a string to a list of floats.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>String to convert</p> required <p>Returns:</p> Name Type Description <code>vals</code> <code>list[float]</code> <p>List of floats</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def str_to_float_list(v: str | list):\n    \"\"\"Converts a string to a list of floats.\n\n    Args:\n        v (str): String to convert\n\n    Returns:\n        vals (list[float]): List of floats\n    \"\"\"\n    if v == \"[]\":\n        return []\n    if isinstance(v, str):\n        # re should be used to parse the string -\n        # check that it starts with \"[\"  and ends with \"]\"\n        # and the elements are separated by \", \"\n        # and the elements are all ints or floats\n\n        if not re.match(r\"^\\[.*\\]$\", v):\n            raise ValueError(f\"STRING:NOT_LIST:{v}\")\n        v = v[1:-1]\n        if not re.match(r\"^[\\-0-9\\., ]*$\", v):\n            raise ValueError(f\"STRING:NOT_LIST:{v}\")\n        v = v.replace(\" \", \"\").split(\",\")\n    return [float(x) for x in v]\n</code></pre>"},{"location":"modules/climate-studio/#epinterface.climate_studio.interface.str_to_opaque_layer_list","title":"<code>str_to_opaque_layer_list(v)</code>","text":"<p>Converts a string to a list of opaque construction layers.</p> Source code in <code>epinterface/climate_studio/interface.py</code> <pre><code>def str_to_opaque_layer_list(v: str | list):\n    \"\"\"Converts a string to a list of opaque construction layers.\"\"\"\n    if isinstance(v, list):\n        return v\n    if v == \"[]\":\n        return []\n    list_content = v[1:-1].split(\", \")\n    names = list_content[::2]\n    thicknesses = list(map(float, list_content[1::2]))\n    return [\n        OpaqueConstructionLayer(Name=name, Thickness=thickness)\n        for name, thickness in zip(names, thicknesses, strict=False)\n    ]\n</code></pre>"},{"location":"modules/geometry/","title":"Geometry","text":"<p>This contains some utilities for adding geometry to an IDF.</p> <p>Geometry utilities for the UBEM construction.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry","title":"<code>ShoeboxGeometry</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A simple shoebox constructor for the IDF model.</p> <p>Can create gables, basements, and various zoning strategies.</p> Source code in <code>epinterface/geometry.py</code> <pre><code>class ShoeboxGeometry(BaseModel):\n    \"\"\"A simple shoebox constructor for the IDF model.\n\n    Can create gables, basements, and various zoning strategies.\n    \"\"\"\n\n    x: float\n    y: float\n    w: float\n    d: float\n    h: float\n    num_stories: int = Field(\n        ...,\n        title=\"Number of stories\",\n        ge=1,\n        description=\"The number of stories in the building.\",\n    )\n    zoning: ZoningType = Field(\n        ...,\n        title=\"Zoning type\",\n        description=\"Whether to use core/perim or full-floor zones.\",\n    )\n    perim_depth: float = Field(\n        default=3,\n        title=\"Perimeter depth\",\n        description=\"Sets the perimeter depth when using core/perim zoning.  Ignored otherwise.\",\n    )\n    roof_height: float | None = Field(\n        default=None,\n        title=\"Roof gable height\",\n        description=\"The height of the roof gable.  If None, a flat roof is assumed.\",\n    )\n    basement: bool = Field(\n        default=False,\n        title=\"Basement\",\n        description=\"Whether or not to use a basement with same f2f height as building.\",\n    )\n    exposed_basement_frac: float = Field(\n        default=0.0,\n        title=\"Exposed basement fraction\",\n        description=\"The fraction of the basement that is exposed.\",\n        ge=0,\n        lt=1,\n    )\n    wwr: float = Field(\n        default=0.15,\n        title=\"Window-to-wall ratio\",\n        description=\"The window-to-wall ratio of the building.\",\n        ge=0,\n        le=1,\n    )\n\n    @property\n    def basement_storey_count(self) -&gt; int:\n        \"\"\"Return the number of basement stories.\"\"\"\n        return 1 if self.basement else 0\n\n    @property\n    def attic_storey_count(self) -&gt; int:\n        \"\"\"Return the number of attic stories.\"\"\"\n        return 1 if self.roof_height else 0\n\n    @property\n    def zones_height(self) -&gt; float:\n        \"\"\"Return the total height of the zones, excluding any gabling.\"\"\"\n        return self.h * (self.num_stories)\n\n    @property\n    def total_height_with_gabling(self) -&gt; float:\n        \"\"\"Return the total height of the building, including any gabling.\"\"\"\n        return self.zones_height + (self.roof_height or 0)\n\n    @property\n    def footprint_area(self) -&gt; float:\n        \"\"\"Return the total floor area of the building.\"\"\"\n        return self.w * self.d\n\n    @property\n    def total_living_area(self) -&gt; float:\n        \"\"\"Return the total living area of the building (does not include attic/basement).\"\"\"\n        return self.footprint_area * self.num_stories\n\n    @property\n    def total_area(self) -&gt; float:\n        \"\"\"Return the total area of the building.\"\"\"\n        return (\n            self.total_living_area\n            + self.footprint_area * self.basement_storey_count\n            + self.footprint_area * (1 if self.roof_height else 0)\n        )\n\n    @property\n    def basement_suffix(self) -&gt; str:\n        \"\"\"Return the basement suffix for the building.\"\"\"\n        if not self.basement:\n            msg = \"Building has no basement.\"\n            raise ValueError(msg)\n        return \"Storey 0\" if self.zoning == \"core/perim\" else \"Storey -1\"\n\n    @property\n    def zones_per_storey(self) -&gt; int:\n        \"\"\"Return the number of zones per storey.\"\"\"\n        if self.zoning == \"core/perim\":\n            return 5\n        else:\n            return 1\n\n    def add(self, idf: IDF) -&gt; IDF:  # noqa: C901\n        \"\"\"Constructs a simple shoebox geometry in the IDF model.\n\n        Takes advantage of the geomeppy methods to do so.\n\n        Can create gables, basements, and various zoning strategies.\n\n        Args:\n            idf: The IDF model to add the geometry to.\n\n        Returns:\n            The IDF model with the added geometry.\n        \"\"\"\n        lower_left_corner = (self.x, self.y)\n        lower_right_corner = (self.x + self.w, self.y)\n        upper_right_corner = (self.x + self.w, self.y + self.d)\n        upper_left_corner = (self.x, self.y + self.d)\n        bottom_plane = [\n            lower_left_corner,\n            lower_right_corner,\n            upper_right_corner,\n            upper_left_corner,\n        ]\n        idf.add_block(\n            name=\"shoebox\",\n            coordinates=bottom_plane,\n            height=self.zones_height\n            + (self.h if self.basement and self.zoning == \"core/perim\" else 0),\n            num_stories=self.num_stories + self.basement_storey_count,\n            zoning=self.zoning,\n            perim_depth=self.perim_depth,\n            below_ground_stories=self.basement_storey_count,\n            below_ground_storey_height=self.h,\n        )\n        if self.basement and self.zoning == \"core/perim\":\n            idf.translate((0, 0, -self.h))\n\n        if self.roof_height:\n            # we need to convert the old roof surfaces to ceilings;\n            # additionally, we will track them so that we can create the\n            # corresponding floor surfaces for the attic in a manner\n            # that avoids having to subdivide surfaces with intersect/match\n            old_roof_srfs = []\n            for srf in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]:\n                if srf.Surface_Type.lower() == \"roof\":\n                    srf.Surface_Type = \"ceiling\"\n                    old_roof_srfs.append(srf)\n            if len(old_roof_srfs) not in [1, 5]:\n                msg = \"Too many roof surfaces were found; expected 1 (by_storey) or 5 \"\n                f\" (core/perim), but found {len(old_roof_srfs)}.\"\n                raise ValueError(msg)\n\n            # create the zone\n            idf.newidfobject(\"ZONE\", Name=\"Attic\")\n\n            # we always want the centerline of a gable to be paralle to the longer\n            # edge\n            centerline_parallel_to = \"w\" if self.w &gt; self.d else \"d\"\n\n            # the centerline is the midpoint of the shorter edge\n            # since it is parallel to the longer edge\n            roof_centerline = (\n                (self.x + self.w / 2)\n                if centerline_parallel_to == \"d\"\n                else (self.y + self.d / 2)\n            )\n\n            if centerline_parallel_to == \"d\":\n                # this gable goes from the left edge of the building to\n                # the midpoint on the x-axis\n                # it starts in the \"upper left\" corner in plan\n                # and goes counter clockwise to the \"lower left\" corner\n                # then to the roof centerline (and up in the z-axis)\n                vert_0 = (self.x, self.y + self.d, self.zones_height)\n                vert_1 = (self.x, self.y, self.zones_height)\n                vert_2 = (roof_centerline, self.y, self.total_height_with_gabling)\n                vert_3 = (\n                    roof_centerline,\n                    self.y + self.d,\n                    self.total_height_with_gabling,\n                )\n            else:\n                # this gable goes from the middle of the left edge at the top of the\n                # gable and goes counter clockwise down to the lower left corner\n                # then the lower right corner, and then back up.\n                vert_0 = (self.x, roof_centerline, self.total_height_with_gabling)\n                vert_1 = (self.x, self.y, self.zones_height)\n                vert_2 = (self.x + self.w, self.y, self.zones_height)\n                vert_3 = (\n                    self.x + self.w,\n                    roof_centerline,\n                    self.total_height_with_gabling,\n                )\n\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"Gable1\",\n                Surface_Type=\"Roof\",\n                Number_of_Vertices=4,\n                View_Factor_to_Ground=0,\n                Vertex_1_Xcoordinate=vert_0[0],\n                Vertex_1_Ycoordinate=vert_0[1],\n                Vertex_1_Zcoordinate=vert_0[2],\n                Vertex_2_Xcoordinate=vert_1[0],\n                Vertex_2_Ycoordinate=vert_1[1],\n                Vertex_2_Zcoordinate=vert_1[2],\n                Vertex_3_Xcoordinate=vert_2[0],\n                Vertex_3_Ycoordinate=vert_2[1],\n                Vertex_3_Zcoordinate=vert_2[2],\n                Vertex_4_Xcoordinate=vert_3[0],\n                Vertex_4_Ycoordinate=vert_3[1],\n                Vertex_4_Zcoordinate=vert_3[2],\n                Zone_Name=\"Attic\",\n            )\n\n            if centerline_parallel_to == \"d\":\n                vert_0 = (self.x + self.w, self.y, self.zones_height)\n                vert_1 = (self.x + self.w, self.y + self.d, self.zones_height)\n                vert_2 = (\n                    roof_centerline,\n                    self.y + self.d,\n                    self.total_height_with_gabling,\n                )\n                vert_3 = (\n                    roof_centerline,\n                    self.y,\n                    self.total_height_with_gabling,\n                )\n            else:\n                vert_0 = (self.x, roof_centerline, self.total_height_with_gabling)\n                vert_1 = (\n                    self.x + self.w,\n                    roof_centerline,\n                    self.total_height_with_gabling,\n                )\n                vert_2 = (\n                    self.x + self.w,\n                    self.y + self.d,\n                    self.zones_height,\n                )\n                vert_3 = (\n                    self.x,\n                    self.y + self.d,\n                    self.zones_height,\n                )\n\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"Gable2\",\n                Surface_Type=\"Roof\",\n                Number_of_Vertices=4,\n                View_Factor_to_Ground=0,\n                Vertex_1_Xcoordinate=vert_0[0],\n                Vertex_1_Ycoordinate=vert_0[1],\n                Vertex_1_Zcoordinate=vert_0[2],\n                Vertex_2_Xcoordinate=vert_1[0],\n                Vertex_2_Ycoordinate=vert_1[1],\n                Vertex_2_Zcoordinate=vert_1[2],\n                Vertex_3_Xcoordinate=vert_2[0],\n                Vertex_3_Ycoordinate=vert_2[1],\n                Vertex_3_Zcoordinate=vert_2[2],\n                Vertex_4_Xcoordinate=vert_3[0],\n                Vertex_4_Ycoordinate=vert_3[1],\n                Vertex_4_Zcoordinate=vert_3[2],\n                Zone_Name=\"Attic\",\n            )\n\n            # make triangular endcaps\n            if centerline_parallel_to == \"d\":\n                vert_0 = (self.x, self.y, self.zones_height)\n                vert_1 = (self.x + self.w, self.y, self.zones_height)\n                vert_2 = (roof_centerline, self.y, self.total_height_with_gabling)\n            else:\n                vert_0 = (self.x, self.y, self.zones_height)\n                vert_1 = (self.x, roof_centerline, self.total_height_with_gabling)\n                vert_2 = (self.x, self.y + self.d, self.zones_height)\n\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"Endcap1\",\n                Surface_Type=\"Wall\",\n                Number_of_Vertices=3,\n                Vertex_1_Xcoordinate=vert_0[0],\n                Vertex_1_Ycoordinate=vert_0[1],\n                Vertex_1_Zcoordinate=vert_0[2],\n                Vertex_2_Xcoordinate=vert_1[0],\n                Vertex_2_Ycoordinate=vert_1[1],\n                Vertex_2_Zcoordinate=vert_1[2],\n                Vertex_3_Xcoordinate=vert_2[0],\n                Vertex_3_Ycoordinate=vert_2[1],\n                Vertex_3_Zcoordinate=vert_2[2],\n                Zone_Name=\"Attic\",\n            )\n\n            if centerline_parallel_to == \"d\":\n                vert_0 = (self.x + self.w, self.y + self.d, self.zones_height)\n                vert_1 = (self.x, self.y + self.d, self.zones_height)\n                vert_2 = (\n                    roof_centerline,\n                    self.y + self.d,\n                    self.total_height_with_gabling,\n                )\n            else:\n                vert_0 = (self.x + self.w, self.y, self.zones_height)\n                vert_1 = (self.x + self.w, self.y + self.d, self.zones_height)\n                vert_2 = (\n                    self.x + self.w,\n                    roof_centerline,\n                    self.total_height_with_gabling,\n                )\n\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=\"Endcap2\",\n                Surface_Type=\"Wall\",\n                Number_of_Vertices=3,\n                Vertex_1_Xcoordinate=vert_0[0],\n                Vertex_1_Ycoordinate=vert_0[1],\n                Vertex_1_Zcoordinate=vert_0[2],\n                Vertex_2_Xcoordinate=vert_1[0],\n                Vertex_2_Ycoordinate=vert_1[1],\n                Vertex_2_Zcoordinate=vert_1[2],\n                Vertex_3_Xcoordinate=vert_2[0],\n                Vertex_3_Ycoordinate=vert_2[1],\n                Vertex_3_Zcoordinate=vert_2[2],\n                Zone_Name=\"Attic\",\n            )\n\n            # We will create identical floor surfaces for the attic to match\n            # the zone below.  While we could just add a single plane and let\n            # the `intersect_match` handle it, this is more robust; the geomeppy\n            # method occasionally results in numerical floating point errors where\n            # very small overhang area is created with an outside boundary\n            # condition.\n            # we use a vertex order of 1, 4, 3, 2 to match the orientation of the\n            # roof surfaces below it, i.e. CCW vs CW.\n            for i, srf in enumerate(old_roof_srfs):\n                idf.newidfobject(\n                    \"BUILDINGSURFACE:DETAILED\",\n                    Name=f\"attic_bottom_plane_{i}\",\n                    Surface_Type=\"Floor\",\n                    Number_of_Vertices=4,\n                    Vertex_1_Xcoordinate=srf.Vertex_1_Xcoordinate,\n                    Vertex_1_Ycoordinate=srf.Vertex_1_Ycoordinate,\n                    Vertex_1_Zcoordinate=srf.Vertex_1_Zcoordinate,\n                    Vertex_2_Xcoordinate=srf.Vertex_4_Xcoordinate,\n                    Vertex_2_Ycoordinate=srf.Vertex_4_Ycoordinate,\n                    Vertex_2_Zcoordinate=srf.Vertex_4_Zcoordinate,\n                    Vertex_3_Xcoordinate=srf.Vertex_3_Xcoordinate,\n                    Vertex_3_Ycoordinate=srf.Vertex_3_Ycoordinate,\n                    Vertex_3_Zcoordinate=srf.Vertex_3_Zcoordinate,\n                    Vertex_4_Xcoordinate=srf.Vertex_2_Xcoordinate,\n                    Vertex_4_Ycoordinate=srf.Vertex_2_Ycoordinate,\n                    Vertex_4_Zcoordinate=srf.Vertex_2_Zcoordinate,\n                    Zone_Name=\"Attic\",\n                )\n\n        idf.intersect_match()\n\n        idf.set_default_constructions()\n\n        # Handle Windows\n        window_walls = [\n            w\n            for w in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]\n            if w.Outside_Boundary_Condition.lower() == \"outdoors\"\n            and \"attic\" not in w.Zone_Name.lower()\n            and (\n                not w.Zone_Name.lower().endswith(self.basement_suffix.lower())\n                if self.basement\n                else True\n            )\n            and w.Surface_Type.lower() == \"wall\"\n        ]\n        idf.set_wwr(\n            wwr=self.wwr,\n            construction=\"Project External Window\",\n            force=True,\n            surfaces=window_walls,\n        )\n        return idf\n</code></pre>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.attic_storey_count","title":"<code>attic_storey_count</code>  <code>property</code>","text":"<p>Return the number of attic stories.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.basement_storey_count","title":"<code>basement_storey_count</code>  <code>property</code>","text":"<p>Return the number of basement stories.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.basement_suffix","title":"<code>basement_suffix</code>  <code>property</code>","text":"<p>Return the basement suffix for the building.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.footprint_area","title":"<code>footprint_area</code>  <code>property</code>","text":"<p>Return the total floor area of the building.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.total_area","title":"<code>total_area</code>  <code>property</code>","text":"<p>Return the total area of the building.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.total_height_with_gabling","title":"<code>total_height_with_gabling</code>  <code>property</code>","text":"<p>Return the total height of the building, including any gabling.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.total_living_area","title":"<code>total_living_area</code>  <code>property</code>","text":"<p>Return the total living area of the building (does not include attic/basement).</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.zones_height","title":"<code>zones_height</code>  <code>property</code>","text":"<p>Return the total height of the zones, excluding any gabling.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.zones_per_storey","title":"<code>zones_per_storey</code>  <code>property</code>","text":"<p>Return the number of zones per storey.</p>"},{"location":"modules/geometry/#epinterface.geometry.ShoeboxGeometry.add","title":"<code>add(idf)</code>","text":"<p>Constructs a simple shoebox geometry in the IDF model.</p> <p>Takes advantage of the geomeppy methods to do so.</p> <p>Can create gables, basements, and various zoning strategies.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the geometry to.</p> required <p>Returns:</p> Type Description <code>IDF</code> <p>The IDF model with the added geometry.</p> Source code in <code>epinterface/geometry.py</code> <pre><code>def add(self, idf: IDF) -&gt; IDF:  # noqa: C901\n    \"\"\"Constructs a simple shoebox geometry in the IDF model.\n\n    Takes advantage of the geomeppy methods to do so.\n\n    Can create gables, basements, and various zoning strategies.\n\n    Args:\n        idf: The IDF model to add the geometry to.\n\n    Returns:\n        The IDF model with the added geometry.\n    \"\"\"\n    lower_left_corner = (self.x, self.y)\n    lower_right_corner = (self.x + self.w, self.y)\n    upper_right_corner = (self.x + self.w, self.y + self.d)\n    upper_left_corner = (self.x, self.y + self.d)\n    bottom_plane = [\n        lower_left_corner,\n        lower_right_corner,\n        upper_right_corner,\n        upper_left_corner,\n    ]\n    idf.add_block(\n        name=\"shoebox\",\n        coordinates=bottom_plane,\n        height=self.zones_height\n        + (self.h if self.basement and self.zoning == \"core/perim\" else 0),\n        num_stories=self.num_stories + self.basement_storey_count,\n        zoning=self.zoning,\n        perim_depth=self.perim_depth,\n        below_ground_stories=self.basement_storey_count,\n        below_ground_storey_height=self.h,\n    )\n    if self.basement and self.zoning == \"core/perim\":\n        idf.translate((0, 0, -self.h))\n\n    if self.roof_height:\n        # we need to convert the old roof surfaces to ceilings;\n        # additionally, we will track them so that we can create the\n        # corresponding floor surfaces for the attic in a manner\n        # that avoids having to subdivide surfaces with intersect/match\n        old_roof_srfs = []\n        for srf in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]:\n            if srf.Surface_Type.lower() == \"roof\":\n                srf.Surface_Type = \"ceiling\"\n                old_roof_srfs.append(srf)\n        if len(old_roof_srfs) not in [1, 5]:\n            msg = \"Too many roof surfaces were found; expected 1 (by_storey) or 5 \"\n            f\" (core/perim), but found {len(old_roof_srfs)}.\"\n            raise ValueError(msg)\n\n        # create the zone\n        idf.newidfobject(\"ZONE\", Name=\"Attic\")\n\n        # we always want the centerline of a gable to be paralle to the longer\n        # edge\n        centerline_parallel_to = \"w\" if self.w &gt; self.d else \"d\"\n\n        # the centerline is the midpoint of the shorter edge\n        # since it is parallel to the longer edge\n        roof_centerline = (\n            (self.x + self.w / 2)\n            if centerline_parallel_to == \"d\"\n            else (self.y + self.d / 2)\n        )\n\n        if centerline_parallel_to == \"d\":\n            # this gable goes from the left edge of the building to\n            # the midpoint on the x-axis\n            # it starts in the \"upper left\" corner in plan\n            # and goes counter clockwise to the \"lower left\" corner\n            # then to the roof centerline (and up in the z-axis)\n            vert_0 = (self.x, self.y + self.d, self.zones_height)\n            vert_1 = (self.x, self.y, self.zones_height)\n            vert_2 = (roof_centerline, self.y, self.total_height_with_gabling)\n            vert_3 = (\n                roof_centerline,\n                self.y + self.d,\n                self.total_height_with_gabling,\n            )\n        else:\n            # this gable goes from the middle of the left edge at the top of the\n            # gable and goes counter clockwise down to the lower left corner\n            # then the lower right corner, and then back up.\n            vert_0 = (self.x, roof_centerline, self.total_height_with_gabling)\n            vert_1 = (self.x, self.y, self.zones_height)\n            vert_2 = (self.x + self.w, self.y, self.zones_height)\n            vert_3 = (\n                self.x + self.w,\n                roof_centerline,\n                self.total_height_with_gabling,\n            )\n\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"Gable1\",\n            Surface_Type=\"Roof\",\n            Number_of_Vertices=4,\n            View_Factor_to_Ground=0,\n            Vertex_1_Xcoordinate=vert_0[0],\n            Vertex_1_Ycoordinate=vert_0[1],\n            Vertex_1_Zcoordinate=vert_0[2],\n            Vertex_2_Xcoordinate=vert_1[0],\n            Vertex_2_Ycoordinate=vert_1[1],\n            Vertex_2_Zcoordinate=vert_1[2],\n            Vertex_3_Xcoordinate=vert_2[0],\n            Vertex_3_Ycoordinate=vert_2[1],\n            Vertex_3_Zcoordinate=vert_2[2],\n            Vertex_4_Xcoordinate=vert_3[0],\n            Vertex_4_Ycoordinate=vert_3[1],\n            Vertex_4_Zcoordinate=vert_3[2],\n            Zone_Name=\"Attic\",\n        )\n\n        if centerline_parallel_to == \"d\":\n            vert_0 = (self.x + self.w, self.y, self.zones_height)\n            vert_1 = (self.x + self.w, self.y + self.d, self.zones_height)\n            vert_2 = (\n                roof_centerline,\n                self.y + self.d,\n                self.total_height_with_gabling,\n            )\n            vert_3 = (\n                roof_centerline,\n                self.y,\n                self.total_height_with_gabling,\n            )\n        else:\n            vert_0 = (self.x, roof_centerline, self.total_height_with_gabling)\n            vert_1 = (\n                self.x + self.w,\n                roof_centerline,\n                self.total_height_with_gabling,\n            )\n            vert_2 = (\n                self.x + self.w,\n                self.y + self.d,\n                self.zones_height,\n            )\n            vert_3 = (\n                self.x,\n                self.y + self.d,\n                self.zones_height,\n            )\n\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"Gable2\",\n            Surface_Type=\"Roof\",\n            Number_of_Vertices=4,\n            View_Factor_to_Ground=0,\n            Vertex_1_Xcoordinate=vert_0[0],\n            Vertex_1_Ycoordinate=vert_0[1],\n            Vertex_1_Zcoordinate=vert_0[2],\n            Vertex_2_Xcoordinate=vert_1[0],\n            Vertex_2_Ycoordinate=vert_1[1],\n            Vertex_2_Zcoordinate=vert_1[2],\n            Vertex_3_Xcoordinate=vert_2[0],\n            Vertex_3_Ycoordinate=vert_2[1],\n            Vertex_3_Zcoordinate=vert_2[2],\n            Vertex_4_Xcoordinate=vert_3[0],\n            Vertex_4_Ycoordinate=vert_3[1],\n            Vertex_4_Zcoordinate=vert_3[2],\n            Zone_Name=\"Attic\",\n        )\n\n        # make triangular endcaps\n        if centerline_parallel_to == \"d\":\n            vert_0 = (self.x, self.y, self.zones_height)\n            vert_1 = (self.x + self.w, self.y, self.zones_height)\n            vert_2 = (roof_centerline, self.y, self.total_height_with_gabling)\n        else:\n            vert_0 = (self.x, self.y, self.zones_height)\n            vert_1 = (self.x, roof_centerline, self.total_height_with_gabling)\n            vert_2 = (self.x, self.y + self.d, self.zones_height)\n\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"Endcap1\",\n            Surface_Type=\"Wall\",\n            Number_of_Vertices=3,\n            Vertex_1_Xcoordinate=vert_0[0],\n            Vertex_1_Ycoordinate=vert_0[1],\n            Vertex_1_Zcoordinate=vert_0[2],\n            Vertex_2_Xcoordinate=vert_1[0],\n            Vertex_2_Ycoordinate=vert_1[1],\n            Vertex_2_Zcoordinate=vert_1[2],\n            Vertex_3_Xcoordinate=vert_2[0],\n            Vertex_3_Ycoordinate=vert_2[1],\n            Vertex_3_Zcoordinate=vert_2[2],\n            Zone_Name=\"Attic\",\n        )\n\n        if centerline_parallel_to == \"d\":\n            vert_0 = (self.x + self.w, self.y + self.d, self.zones_height)\n            vert_1 = (self.x, self.y + self.d, self.zones_height)\n            vert_2 = (\n                roof_centerline,\n                self.y + self.d,\n                self.total_height_with_gabling,\n            )\n        else:\n            vert_0 = (self.x + self.w, self.y, self.zones_height)\n            vert_1 = (self.x + self.w, self.y + self.d, self.zones_height)\n            vert_2 = (\n                self.x + self.w,\n                roof_centerline,\n                self.total_height_with_gabling,\n            )\n\n        idf.newidfobject(\n            \"BUILDINGSURFACE:DETAILED\",\n            Name=\"Endcap2\",\n            Surface_Type=\"Wall\",\n            Number_of_Vertices=3,\n            Vertex_1_Xcoordinate=vert_0[0],\n            Vertex_1_Ycoordinate=vert_0[1],\n            Vertex_1_Zcoordinate=vert_0[2],\n            Vertex_2_Xcoordinate=vert_1[0],\n            Vertex_2_Ycoordinate=vert_1[1],\n            Vertex_2_Zcoordinate=vert_1[2],\n            Vertex_3_Xcoordinate=vert_2[0],\n            Vertex_3_Ycoordinate=vert_2[1],\n            Vertex_3_Zcoordinate=vert_2[2],\n            Zone_Name=\"Attic\",\n        )\n\n        # We will create identical floor surfaces for the attic to match\n        # the zone below.  While we could just add a single plane and let\n        # the `intersect_match` handle it, this is more robust; the geomeppy\n        # method occasionally results in numerical floating point errors where\n        # very small overhang area is created with an outside boundary\n        # condition.\n        # we use a vertex order of 1, 4, 3, 2 to match the orientation of the\n        # roof surfaces below it, i.e. CCW vs CW.\n        for i, srf in enumerate(old_roof_srfs):\n            idf.newidfobject(\n                \"BUILDINGSURFACE:DETAILED\",\n                Name=f\"attic_bottom_plane_{i}\",\n                Surface_Type=\"Floor\",\n                Number_of_Vertices=4,\n                Vertex_1_Xcoordinate=srf.Vertex_1_Xcoordinate,\n                Vertex_1_Ycoordinate=srf.Vertex_1_Ycoordinate,\n                Vertex_1_Zcoordinate=srf.Vertex_1_Zcoordinate,\n                Vertex_2_Xcoordinate=srf.Vertex_4_Xcoordinate,\n                Vertex_2_Ycoordinate=srf.Vertex_4_Ycoordinate,\n                Vertex_2_Zcoordinate=srf.Vertex_4_Zcoordinate,\n                Vertex_3_Xcoordinate=srf.Vertex_3_Xcoordinate,\n                Vertex_3_Ycoordinate=srf.Vertex_3_Ycoordinate,\n                Vertex_3_Zcoordinate=srf.Vertex_3_Zcoordinate,\n                Vertex_4_Xcoordinate=srf.Vertex_2_Xcoordinate,\n                Vertex_4_Ycoordinate=srf.Vertex_2_Ycoordinate,\n                Vertex_4_Zcoordinate=srf.Vertex_2_Zcoordinate,\n                Zone_Name=\"Attic\",\n            )\n\n    idf.intersect_match()\n\n    idf.set_default_constructions()\n\n    # Handle Windows\n    window_walls = [\n        w\n        for w in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]\n        if w.Outside_Boundary_Condition.lower() == \"outdoors\"\n        and \"attic\" not in w.Zone_Name.lower()\n        and (\n            not w.Zone_Name.lower().endswith(self.basement_suffix.lower())\n            if self.basement\n            else True\n        )\n        and w.Surface_Type.lower() == \"wall\"\n    ]\n    idf.set_wwr(\n        wwr=self.wwr,\n        construction=\"Project External Window\",\n        force=True,\n        surfaces=window_walls,\n    )\n    return idf\n</code></pre>"},{"location":"modules/geometry/#epinterface.geometry.compute_shading_mask","title":"<code>compute_shading_mask(building, neighbors, neighbor_heights, azimuthal_angle)</code>","text":"<p>Compute the shading mask for the building.</p> <p>This will emit a ray from the center of the building in every direction according to the azimuthal angle division of a circle.</p> <p>It will compute the intersection of each ray with all the neighbor edges, and then determine the height of the each edge that intersects the ray.</p> <p>That height is then used to determine an elevation angle; the max of the elevation angles for each ray is then the shading mask value for that direction.</p> <p>Note that this checks all edges, so its crucial that the neighbors have already been culled to the relevant building to avoid unnecessary computation.</p> <p>Parameters:</p> Name Type Description Default <code>building</code> <code>Polygon | str</code> <p>The building to compute the shading mask for.</p> required <code>neighbors</code> <code>list[Polygon | str | None]</code> <p>The neighbors to compute the shading mask for.</p> required <code>neighbor_heights</code> <code>list[float | int | None]</code> <p>The heights of the neighbors.</p> required <code>azimuthal_angle</code> <code>float</code> <p>The azimuthal angle to compute the shading mask for.</p> required <p>Returns:</p> Name Type Description <code>shading_mask</code> <code>ndarray</code> <p>The shading mask for the building.</p> Source code in <code>epinterface/geometry.py</code> <pre><code>def compute_shading_mask(\n    building: Polygon | str,\n    neighbors: Sequence[Polygon | str | None],\n    neighbor_heights: Sequence[float | int | None],\n    azimuthal_angle: float,\n) -&gt; np.ndarray:\n    \"\"\"Compute the shading mask for the building.\n\n    This will emit a ray from the center of the building in\n    every direction according to the azimuthal angle division\n    of a circle.\n\n    It will compute the intersection of each ray with all the neighbor edges,\n    and then determine the height of the each edge that intersects the ray.\n\n    That height is then used to determine an elevation angle; the max of the elevation\n    angles for each ray is then the shading mask value for that direction.\n\n    Note that this checks all edges, so its crucial that the neighbors have\n    already been culled to the relevant building to avoid unnecessary computation.\n\n    Args:\n        building (Polygon | str): The building to compute the shading mask for.\n        neighbors (list[Polygon | str | None]): The neighbors to compute the shading mask for.\n        neighbor_heights (list[float | int | None]): The heights of the neighbors.\n        azimuthal_angle (float): The azimuthal angle to compute the shading mask for.\n\n    Returns:\n        shading_mask (np.ndarray): The shading mask for the building.\n    \"\"\"\n    building_geom = building if isinstance(building, Polygon) else from_wkt(building)\n\n    neighbor_geo_and_height = [\n        (cast(Polygon, from_wkt(n)), float(h)) if isinstance(n, str) else (n, float(h))\n        for n, h in zip(neighbors, neighbor_heights, strict=True)\n        if n is not None and h is not None\n    ]\n    safe_neighbor_geoms = [geom for geom, _ in neighbor_geo_and_height]\n    safe_neighbor_heights = [height for _, height in neighbor_geo_and_height]\n\n    # first we compute the number of rays we need to cast\n    # along with the angles at which to cast them\n    n_rays = int(2 * np.pi / azimuthal_angle)\n    ray_angles = np.linspace(0, 2 * np.pi - azimuthal_angle, n_rays)\n    ray_distance = 9999  # an arbitrarily large distance\n\n    # extract the relevant geometry data\n    centroid = building_geom.centroid\n\n    shading_mask = np.zeros(n_rays)\n\n    for ray_angle_idx, ray_angle in enumerate(ray_angles):\n        # create the ray as a line segment\n        # using basic trig\n        x_off, y_off = (\n            ray_distance * np.cos(ray_angle),\n            ray_distance * np.sin(ray_angle),\n        )\n        centroid_moved = translate(centroid, x_off, y_off)\n        ray = LineString([centroid, centroid_moved])\n\n        # track the max elevation angle for this ray so far\n        max_elevation_angle = 0\n\n        for geom, height in zip(\n            safe_neighbor_geoms, safe_neighbor_heights, strict=True\n        ):\n            # create the line segments of the boundary\n            x_coords = np.array(geom.boundary.xy[0])\n            y_coords = np.array(geom.boundary.xy[1])\n\n            for x0, y0, x1, y1 in zip(\n                x_coords[:-1],\n                y_coords[:-1],\n                x_coords[1:],\n                y_coords[1:],\n                strict=True,\n            ):\n                line = LineString([(x0, y0), (x1, y1)])\n\n                # compute the intersection and continue\n                # if there is no intersection\n                intersection = ray.intersection(line)\n                if intersection.is_empty:\n                    continue\n\n                # compute the elevation angle and store it if it\n                # is greater than the current max\n                distance = intersection.distance(centroid)\n                elevation_angle = np.arctan2(height, distance)\n                max_elevation_angle = max(max_elevation_angle, elevation_angle)\n\n        shading_mask[ray_angle_idx] = max_elevation_angle\n    return shading_mask\n</code></pre>"},{"location":"modules/geometry/#epinterface.geometry.get_zone_floor_area","title":"<code>get_zone_floor_area(idf, zone_name)</code>","text":"<p>Get the floor area of a zone by iterating over building surfaces that are of type 'floor'.</p> <p>If more than one floor is found, for now we will return an error; it could be possible in an attic where the floor below has perim/core zoning...</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to get the floor area from.</p> required <code>zone_name</code> <code>str</code> <p>The name of the zone to get the floor area from.</p> required <p>Returns:</p> Name Type Description <code>area</code> <code>float</code> <p>The floor area of the zone [m2].</p> Source code in <code>epinterface/geometry.py</code> <pre><code>def get_zone_floor_area(idf: IDF, zone_name: str) -&gt; float:\n    \"\"\"Get the floor area of a zone by iterating over building surfaces that are of type 'floor'.\n\n    If more than one floor is found, for now we will return an error; it could be possible in an\n    attic where the floor below has perim/core zoning...\n\n    Args:\n        idf (IDF): The IDF model to get the floor area from.\n        zone_name (str): The name of the zone to get the floor area from.\n\n    Returns:\n        area (float): The floor area of the zone [m2].\n    \"\"\"\n    area = 0\n    area_ct = 0\n    for srf in idf.idfobjects[\"BUILDINGSURFACE:DETAILED\"]:\n        # TODO: ensure that this still works for basements and attics.\n        if srf.Zone_Name == zone_name and srf.Surface_Type.lower() == \"floor\":\n            poly = Polygon3D(srf.coords)\n            if poly.area == 0:\n                raise ValueError(f\"INVALID_FLOOR:{zone_name}:{srf.Name}\")\n            area += float(poly.area)\n            area_ct += 1\n    if area_ct not in [1, 5]:\n        raise ValueError(f\"TOO_MANY_FLOORS:{zone_name}:{area_ct}\")\n    if area == 0 or area_ct == 0:\n        raise ValueError(f\"NO_AREA:{zone_name}\")\n\n    return area\n</code></pre>"},{"location":"modules/geometry/#epinterface.geometry.get_zone_glazed_area","title":"<code>get_zone_glazed_area(idf, zone_name)</code>","text":"<p>Calculate the total area of windows for a specific zone in the IDF model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model.</p> required <code>zone_name</code> <code>str</code> <p>The name of the zone to calculate the window area for.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The total area of windows in the specified zone.</p> Source code in <code>epinterface/geometry.py</code> <pre><code>def get_zone_glazed_area(idf: IDF, zone_name: str) -&gt; float:\n    \"\"\"Calculate the total area of windows for a specific zone in the IDF model.\n\n    Args:\n        idf (IDF): The IDF model.\n        zone_name (str): The name of the zone to calculate the window area for.\n\n    Returns:\n        float: The total area of windows in the specified zone.\n    \"\"\"\n    total_window_area = 0.0\n    total_windows = 0\n\n    for window in idf.idfobjects[\"FENESTRATIONSURFACE:DETAILED\"]:\n        parent_srf = idf.getobject(\n            \"BUILDINGSURFACE:DETAILED\", window.Building_Surface_Name\n        )\n        if parent_srf is None:\n            msg = f\"BUILDINGSURFACE:DETAILED:{window.Building_Surface_Name} not found\"\n            raise ValueError(msg)\n        if (\n            parent_srf.Zone_Name.lower() == zone_name.lower()\n            and window.Surface_Type.lower() == \"window\"\n        ):\n            poly = Polygon3D(window.coords)\n            total_window_area += float(poly.area)\n            total_windows += 1\n\n    if total_windows not in [0, 1, 4]:\n        msg = f\"TOO_MANY_WINDOWS:{zone_name}:{total_windows}\"\n        raise ValueError(msg)\n\n    return total_window_area\n</code></pre>"},{"location":"modules/geometry/#epinterface.geometry.get_zone_glazed_area_alt","title":"<code>get_zone_glazed_area_alt(idf, zone_name)</code>","text":"<p>Calculate the total area of windows for a specific zone in the IDF model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model.</p> required <code>zone_name</code> <code>str</code> <p>The name of the zone to calculate the window area for.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The total area of windows in the specified zone.</p> Source code in <code>epinterface/geometry.py</code> <pre><code>def get_zone_glazed_area_alt(idf: IDF, zone_name: str) -&gt; float:\n    \"\"\"Calculate the total area of windows for a specific zone in the IDF model.\n\n    Args:\n        idf (IDF): The IDF model.\n        zone_name (str): The name of the zone to calculate the window area for.\n\n    Returns:\n        float: The total area of windows in the specified zone.\n    \"\"\"\n    total_window_area = 0.0\n    total_windows = 0\n\n    for window in idf.idfobjects[\"FENESTRATIONSURFACE:DETAILED\"]:\n        parent_srf = idf.getobject(\n            \"BUILDINGSURFACE:DETAILED\", window.Building_Surface_Name\n        )\n        if parent_srf is None:\n            msg = f\"BUILDINGSURFACE:DETAILED:{window.Building_Surface_Name} not found\"\n            raise ValueError(msg)\n        if (\n            parent_srf.Zone_Name.lower() == zone_name.lower()\n            and window.Surface_Type.lower() == \"window\"\n        ):\n            vertices = [\n                (\n                    window.Vertex_1_Xcoordinate,\n                    window.Vertex_1_Ycoordinate,\n                    window.Vertex_1_Zcoordinate,\n                ),\n                (\n                    window.Vertex_2_Xcoordinate,\n                    window.Vertex_2_Ycoordinate,\n                    window.Vertex_2_Zcoordinate,\n                ),\n                (\n                    window.Vertex_3_Xcoordinate,\n                    window.Vertex_3_Ycoordinate,\n                    window.Vertex_3_Zcoordinate,\n                ),\n                (\n                    window.Vertex_4_Xcoordinate,\n                    window.Vertex_4_Ycoordinate,\n                    window.Vertex_4_Zcoordinate,\n                ),\n            ]\n            # Assuming the window is a quadrilateral, calculate its area\n            # This is a simplified calculation assuming the window is a rectangle\n            width = (\n                (vertices[1][0] - vertices[0][0]) ** 2\n                + (vertices[1][1] - vertices[0][1]) ** 2\n                + (vertices[1][2] - vertices[0][2]) ** 2\n            ) ** 0.5\n            height = (\n                (vertices[2][0] - vertices[1][0]) ** 2\n                + (vertices[2][1] - vertices[1][1]) ** 2\n                + (vertices[2][2] - vertices[1][2]) ** 2\n            ) ** 0.5\n            area = width * height\n            total_window_area += area\n            total_windows += 1\n\n    if total_windows not in [0, 1, 4]:\n        msg = f\"TOO_MANY_WINDOWS:{zone_name}:{total_windows}\"\n        raise ValueError(msg)\n\n    alt_window_area = get_zone_glazed_area_alt(idf, zone_name)\n    if not np.allclose(total_window_area, alt_window_area):\n        msg = f\"GLAZED_AREA_MISMATCH:{zone_name}:{total_window_area}:{alt_window_area}\"\n        raise ValueError(msg)\n    return total_window_area\n</code></pre>"},{"location":"modules/geometry/#epinterface.geometry.match_idf_to_building_and_neighbors","title":"<code>match_idf_to_building_and_neighbors(idf, building, neighbor_polys, neighbor_floors, neighbor_f2f_height, target_short_length, target_long_length, rotation_angle)</code>","text":"<p>Match an IDF model to a building and neighbors by scaling and rotating the IDF model and adding shading blocks for neighbors.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to match.</p> required <code>building</code> <code>Polygon | str</code> <p>The building to match.</p> required <code>neighbor_polys</code> <code>list[Polygon | str | None]</code> <p>The neighbors to inject as shading.</p> required <code>neighbor_floors</code> <code>list[float | int | None]</code> <p>The counts of the neighbors.</p> required <code>neighbor_f2f_height</code> <code>float | None</code> <p>The height of the building to match</p> required <code>target_short_length</code> <code>float</code> <p>The target short length of the building.</p> required <code>target_long_length</code> <code>float</code> <p>The target long length of the building.</p> required <code>rotation_angle</code> <code>float</code> <p>The rotation angle of the building (radians).</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The matched IDF model.</p> Source code in <code>epinterface/geometry.py</code> <pre><code>def match_idf_to_building_and_neighbors(\n    idf: IDF,\n    building: Polygon | str,\n    neighbor_polys: list[Polygon | str | None],\n    neighbor_floors: list[float | int | None],\n    neighbor_f2f_height: float,\n    target_short_length: float,\n    target_long_length: float,\n    rotation_angle: float,\n) -&gt; IDF:\n    \"\"\"Match an IDF model to a building and neighbors by scaling and rotating the IDF model and adding shading blocks for neighbors.\n\n    Args:\n        idf (IDF): The IDF model to match.\n        building (Polygon | str): The building to match.\n        neighbor_polys (list[Polygon | str | None]): The neighbors to inject as shading.\n        neighbor_floors (list[float | int | None]): The counts of the neighbors.\n        neighbor_f2f_height (float | None): The height of the building to match\n        target_short_length (float): The target short length of the building.\n        target_long_length (float): The target long length of the building.\n        rotation_angle (float): The rotation angle of the building (radians).\n\n    Returns:\n        idf (IDF): The matched IDF model.\n    \"\"\"\n    building_geo = (\n        cast(Polygon, from_wkt(building)) if isinstance(building, str) else building\n    )\n    neighbor_geos = [\n        (cast(Polygon, from_wkt(n)), h * neighbor_f2f_height)\n        if isinstance(n, str)\n        else (n, h * neighbor_f2f_height)\n        for n, h in zip(neighbor_polys, neighbor_floors, strict=True)\n        if n is not None and h is not None\n    ]\n    centroid = building_geo.centroid\n    translated_neighbors = [\n        (translate(n, xoff=-centroid.x, yoff=-centroid.y), h) for n, h in neighbor_geos\n    ]\n    idf_lengths = {(e.p1 - e.p2).length for e in idf.bounding_box().edges}\n    idf_x_coords = [e.p1.x for e in idf.bounding_box().edges]\n    x_span = max(idf_x_coords) - min(idf_x_coords)\n    idf_y_coords = [e.p1.y for e in idf.bounding_box().edges]\n    y_span = max(idf_y_coords) - min(idf_y_coords)\n    # TODO: better handling for boxes that aren't [(0,0),...]\n    if x_span &lt; y_span:\n        raise NotImplementedError(\n            \"This function assumes that the long edge is the x-axis, which is not the case.\"\n        )\n    x_min = min(idf_x_coords)\n    y_min = min(idf_y_coords)\n    if abs(x_min) &gt; 1e-3 or abs(y_min) &gt; 1e-3:\n        raise NotImplementedError(\n            \"This function assumes that the building has the lowerleft corner at the origin, which is not the case.\"\n        )\n    if len(idf_lengths) &gt; 2:\n        raise NotImplementedError(\n            \"The IDF model is not a rectangle, which is not yet supported.\"\n        )\n\n    long_length = max(idf_lengths)\n    short_length = min(idf_lengths)\n\n    idf.scale(target_long_length / long_length, anchor=Vector2D(0, 0), axes=\"x\")\n    idf.scale(target_short_length / short_length, anchor=Vector2D(0, 0), axes=\"y\")\n    idf.translate((\n        -target_long_length / 2,\n        -target_short_length / 2,\n        0,\n    ))  # This translation makes an assumption that the source building is at [(0,0),(0,w),...]\n    idf.rotate(rotation_angle * 180 / np.pi)\n    for i, (geom, height) in enumerate(translated_neighbors):\n        if not height:\n            height = 3.5 * 2\n        if np.isnan(height):\n            height = 3.5 * 2\n        idf.add_shading_block(\n            name=f\"shading_{i}\",\n            coordinates=[Vector2D(*coord) for coord in geom.exterior.coords[:-1]],\n            height=height,\n        )\n    return idf\n</code></pre>"},{"location":"modules/geometry/#epinterface.geometry.prepare_neighbor_shading_for_idf","title":"<code>prepare_neighbor_shading_for_idf(building, neighbors, neighbor_heights, *, azimuthal_angle=2 * np.pi / 48, fence_radius=100, outward_offset=2, f2f_height)</code>","text":"<p>Prepare neighbor polygons and floor counts for match_idf_to_building_and_neighbors.</p> <p>Computes a shading mask from the building and neighbors, converts it to shading fence quadrilaterals, and returns polygons plus floor counts suitable for IDF shading blocks.</p> <p>Parameters:</p> Name Type Description Default <code>building</code> <code>Polygon | str</code> <p>The building polygon (or WKT string).</p> required <code>neighbors</code> <code>Sequence[Polygon | str | None]</code> <p>Neighbor polygons (or WKT strings).</p> required <code>neighbor_heights</code> <code>Sequence[float | int | None]</code> <p>Heights of each neighbor [m].</p> required <code>azimuthal_angle</code> <code>float</code> <p>Angular spacing for shading rays (default 2\u03c0/48).</p> <code>2 * pi / 48</code> <code>fence_radius</code> <code>float</code> <p>Radius for shading fence tangency points.</p> <code>100</code> <code>outward_offset</code> <code>float</code> <p>Distance to extend fence quadrilaterals outward.</p> <code>2</code> <code>f2f_height</code> <code>float</code> <p>Floor-to-floor height for converting heights to floor counts.</p> required <p>Returns:</p> Name Type Description <code>mask_polys</code> <code>list[Polygon]</code> <p>List of Shapely Polygons (quadrilaterals) for each shading fence.</p> <code>neighbor_floors</code> <code>list[int]</code> <p>List of floor counts (int) for each fence.</p> Source code in <code>epinterface/geometry.py</code> <pre><code>def prepare_neighbor_shading_for_idf(\n    building: Polygon | str,\n    neighbors: Sequence[Polygon | str | None],\n    neighbor_heights: Sequence[float | int | None],\n    *,\n    azimuthal_angle: float = 2 * np.pi / 48,\n    fence_radius: float = 100,\n    outward_offset: float = 2,\n    f2f_height: float,\n) -&gt; tuple[list[Polygon], list[int]]:\n    \"\"\"Prepare neighbor polygons and floor counts for match_idf_to_building_and_neighbors.\n\n    Computes a shading mask from the building and neighbors, converts it to shading fence\n    quadrilaterals, and returns polygons plus floor counts suitable for IDF shading blocks.\n\n    Args:\n        building: The building polygon (or WKT string).\n        neighbors: Neighbor polygons (or WKT strings).\n        neighbor_heights: Heights of each neighbor [m].\n        azimuthal_angle: Angular spacing for shading rays (default 2\u03c0/48).\n        fence_radius: Radius for shading fence tangency points.\n        outward_offset: Distance to extend fence quadrilaterals outward.\n        f2f_height: Floor-to-floor height for converting heights to floor counts.\n\n    Returns:\n        mask_polys: List of Shapely Polygons (quadrilaterals) for each shading fence.\n        neighbor_floors: List of floor counts (int) for each fence.\n    \"\"\"\n    shading_mask = compute_shading_mask(\n        building, neighbors, neighbor_heights, azimuthal_angle\n    )\n    az, p0, p1, h, _w = shading_fence_closed_ring(\n        elevations=shading_mask, d=fence_radius\n    )\n\n    building_geom = building if isinstance(building, Polygon) else from_wkt(building)\n    centroid = building_geom.centroid\n    cx, cy = centroid.x, centroid.y\n\n    angles = 2 * np.pi * np.arange(len(az)) / len(az)\n    outward = np.stack([np.cos(angles), np.sin(angles)], axis=-1)\n    p2 = p1 + outward_offset * outward\n    p3 = p0 + outward_offset * outward\n\n    mask_polys = [\n        Polygon([\n            (p0[i, 0] + cx, p0[i, 1] + cy),\n            (p1[i, 0] + cx, p1[i, 1] + cy),\n            (p2[i, 0] + cx, p2[i, 1] + cy),\n            (p3[i, 0] + cx, p3[i, 1] + cy),\n            (p0[i, 0] + cx, p0[i, 1] + cy),\n        ])\n        for i in range(len(az))\n    ]\n    neighbor_floors = [int(h[i] // f2f_height) for i in range(len(h))]\n\n    return mask_polys, neighbor_floors\n</code></pre>"},{"location":"modules/geometry/#epinterface.geometry.shading_fence_closed_ring","title":"<code>shading_fence_closed_ring(elevations, d)</code>","text":"<p>Construct N vertical 'shading fence' rectangles whose bases are tangent segments forming a closed regular polygon around a circle of radius d.</p> Inputs <p>elevations: (N,) elevation angles theta_k [radians] d: radius to tangency points (base midpoints)</p> Outputs <p>azimuths: (N,) inferred azimuths alpha_k = 2\u03c0k/N p0:       (N, 2) base endpoint A (x,y) p1:       (N, 2) base endpoint B (x,y) h:        (N,) heights h_k = d * tan(theta_k) w:        scalar side length / segment width = 2 d tan(\u03c0/N)</p> Notes <ul> <li>With this construction, the segments intersect/meet: p1[k] == p0[k+1] (cyclic),   up to floating point tolerance.</li> <li>N must be &gt;= 3 for a closed polygon.</li> </ul> Source code in <code>epinterface/geometry.py</code> <pre><code>def shading_fence_closed_ring(\n    elevations: ArrayLike,\n    d: float,\n) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, float]:\n    \"\"\"Construct N vertical 'shading fence' rectangles whose bases are tangent segments forming a closed regular polygon around a circle of radius d.\n\n    Inputs:\n      elevations: (N,) elevation angles theta_k [radians]\n      d: radius to tangency points (base midpoints)\n\n    Outputs:\n      azimuths: (N,) inferred azimuths alpha_k = 2\u03c0k/N\n      p0:       (N, 2) base endpoint A (x,y)\n      p1:       (N, 2) base endpoint B (x,y)\n      h:        (N,) heights h_k = d * tan(theta_k)\n      w:        scalar side length / segment width = 2 d tan(\u03c0/N)\n\n    Notes:\n      - With this construction, the segments intersect/meet: p1[k] == p0[k+1] (cyclic),\n        up to floating point tolerance.\n      - N must be &gt;= 3 for a closed polygon.\n    \"\"\"\n    theta = np.asarray(elevations, dtype=np.float64)\n    if theta.ndim != 1:\n        msg = f\"elevations must be 1D, got shape {theta.shape}\"\n        raise ValueError(msg)\n\n    N = theta.shape[0]\n    if N &lt; 3:\n        msg = \"Need at least 3 elevations (N &gt;= 3) to form a closed ring.\"\n        raise ValueError(msg)\n\n    # Inferred equally spaced azimuths\n    k = np.arange(N, dtype=np.float64)\n    azimuths = 2.0 * np.pi * k / N\n\n    ca, sa = np.cos(azimuths), np.sin(azimuths)\n\n    # Tangency points (base midpoints) on circle radius d\n    px = d * ca\n    py = d * sa\n\n    # Unit tangent direction (perpendicular to radius)\n    tx = -sa\n    ty = ca\n\n    # Choose width so adjacent tangent segments meet (circumscribed regular N-gon)\n    half_w = d * np.tan(np.pi / N)\n    w = 2.0 * half_w\n\n    # Endpoints in xy: p \u00b1 half_w * t\n    p0 = np.stack([px - half_w * tx, py - half_w * ty], axis=-1)\n    p1 = np.stack([px + half_w * tx, py + half_w * ty], axis=-1)\n\n    # Heights from elevation angles\n    h = d * np.tan(theta)\n\n    return azimuths, p0, p1, h, w\n</code></pre>"},{"location":"modules/interface/","title":"EnergyPlus Interface","text":"<p>This is a thin wrapper around Eppy for some opinionated control.</p> <p>Interface for EnergyPlus IDF objects.</p>"},{"location":"modules/interface/#epinterface.interface.AirGapMaterial","title":"<code>AirGapMaterial</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>AirGapMaterial object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class AirGapMaterial(BaseObj, extra=\"ignore\"):\n    \"\"\"AirGapMaterial object.\"\"\"\n\n    key: ClassVar[str] = \"MATERIAL:AIRGAP\"\n    Name: str\n    Thermal_Resistance: float\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.BaseMaterial","title":"<code>BaseMaterial</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A base material object for storing material definitions.</p> <p>Note that this is not an EnergyPlus object, but a base class for creating new material objects which can be turned into EP objects once assigned thicknesses.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class BaseMaterial(BaseModel, extra=\"ignore\", populate_by_name=True):\n    \"\"\"A base material object for storing material definitions.\n\n    Note that this is not an EnergyPlus object, but a base class for creating new\n    material objects which can be turned into EP objects once assigned thicknesses.\n    \"\"\"\n\n    Name: str\n    Roughness: str\n    Conductivity: float = Field(..., ge=0, validation_alias=\"Conductivity [W/m.K]\")\n    Density: float = Field(..., ge=0, validation_alias=\"Density [kg/m3]\")\n    Specific_Heat: float = Field(..., ge=0, validation_alias=\"SpecificHeat [J/kg.K]\")\n    Thermal_Absorptance: float | None = Field(\n        default=None, validation_alias=\"ThermalAbsorptance [0-1]\", ge=0, le=1\n    )\n    Solar_Absorptance: float | None = Field(\n        default=None, validation_alias=\"SolarAbsorptance [0-1]\", ge=0, le=1\n    )\n    Visible_Absorptance: float | None = Field(\n        default=None, validation_alias=\"VisibleAbsorptance [0-1]\", ge=0, le=1\n    )\n\n    def as_layer(self, thickness: float):\n        \"\"\"Create a new material object with a given thickness.\n\n        Args:\n            thickness (float): The thickness of the material.\n\n        Returns:\n            mat (Material): The new material object with the given thickness.\n        \"\"\"\n        name = f\"{self.Name}_{thickness}m\"\n        return Material(\n            Name=name, Thickness=thickness, **self.model_dump(exclude={\"Name\"})\n        )\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.BaseMaterial.as_layer","title":"<code>as_layer(thickness)</code>","text":"<p>Create a new material object with a given thickness.</p> <p>Parameters:</p> Name Type Description Default <code>thickness</code> <code>float</code> <p>The thickness of the material.</p> required <p>Returns:</p> Name Type Description <code>mat</code> <code>Material</code> <p>The new material object with the given thickness.</p> Source code in <code>epinterface/interface.py</code> <pre><code>def as_layer(self, thickness: float):\n    \"\"\"Create a new material object with a given thickness.\n\n    Args:\n        thickness (float): The thickness of the material.\n\n    Returns:\n        mat (Material): The new material object with the given thickness.\n    \"\"\"\n    name = f\"{self.Name}_{thickness}m\"\n    return Material(\n        Name=name, Thickness=thickness, **self.model_dump(exclude={\"Name\"})\n    )\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.BaseObj","title":"<code>BaseObj</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for EnergyPlus IDF objects.</p> <p>The class should be inherited by all EnergyPlus IDF objects. It provides methods to add and extract objects from an IDF object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class BaseObj(BaseModel):\n    \"\"\"Base class for EnergyPlus IDF objects.\n\n    The class should be inherited by all EnergyPlus IDF objects. It provides\n    methods to add and extract objects from an IDF object.\n    \"\"\"\n\n    key: ClassVar[str]\n\n    def add(self, idf: IDF):\n        \"\"\"Add the object to the IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the object to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        idf.newidfobject(self.key, **self.model_dump())\n        return idf\n\n    @classmethod\n    def extract(cls, idf: IDF) -&gt; Sequence[Self]:\n        \"\"\"Extract objects from an IDF object.\n\n        Args:\n            idf (IDF): The IDF object to extract objects from.\n\n        Returns:\n            objs (list[BaseObj]): A list of objects extracted from the IDF object.\n        \"\"\"\n        objs = idf.idfobjects[cls.key]\n        try:\n            return [cls(**obj) for obj in objs]\n        except ValidationError:\n            return [cls(**obj.to_dict()) for obj in objs]\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.BaseObj.add","title":"<code>add(idf)</code>","text":"<p>Add the object to the IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the object to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>def add(self, idf: IDF):\n    \"\"\"Add the object to the IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the object to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    idf.newidfobject(self.key, **self.model_dump())\n    return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.BaseObj.extract","title":"<code>extract(idf)</code>  <code>classmethod</code>","text":"<p>Extract objects from an IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to extract objects from.</p> required <p>Returns:</p> Name Type Description <code>objs</code> <code>list[BaseObj]</code> <p>A list of objects extracted from the IDF object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>@classmethod\ndef extract(cls, idf: IDF) -&gt; Sequence[Self]:\n    \"\"\"Extract objects from an IDF object.\n\n    Args:\n        idf (IDF): The IDF object to extract objects from.\n\n    Returns:\n        objs (list[BaseObj]): A list of objects extracted from the IDF object.\n    \"\"\"\n    objs = idf.idfobjects[cls.key]\n    try:\n        return [cls(**obj) for obj in objs]\n    except ValidationError:\n        return [cls(**obj.to_dict()) for obj in objs]\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.Construction","title":"<code>Construction</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>Construction object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class Construction(BaseObj, extra=\"ignore\"):\n    \"\"\"Construction object.\"\"\"\n\n    key: ClassVar[str] = \"CONSTRUCTION\"\n    name: str\n    layers: Sequence[Material | AirGapMaterial | SimpleGlazingMaterial | NoMassMaterial]\n\n    @property\n    def r_value(self):\n        \"\"\"Return the R-value of the construction.\n\n        Computed using the formula: R = sum(thickness_i / conductivity_i)\n\n        Returns:\n            r (float): The R-value of the construction (units: m^2.K/W).\n        \"\"\"\n        return (\n            sum([layer.r for layer in self.layers if isinstance(layer, Material)])\n            + sum([\n                layer.Thermal_Resistance\n                for layer in self.layers\n                if isinstance(layer, AirGapMaterial)\n            ])\n            + sum([\n                layer.Thermal_Resistance\n                for layer in self.layers\n                if isinstance(layer, NoMassMaterial)\n            ])\n            + sum([\n                1 / layer.UFactor\n                for layer in self.layers\n                if isinstance(layer, SimpleGlazingMaterial)\n            ])\n        )\n\n    @classmethod\n    def extract(cls, idf: IDF):\n        \"\"\"Extract objects from an IDF object.\n\n        Args:\n            idf (IDF): The IDF object to extract objects from.\n\n        Returns:\n            constructions (list[Construction]): A list of objects extracted from the IDF object.\n        \"\"\"\n        constructions = idf.idfobjects[\"CONSTRUCTION\"]\n        res: list[Construction] = []\n        for construction in constructions:\n            const_dict = construction.to_dict()\n            layer_names = [\n                const_dict[key]\n                for key in [\n                    \"Outside_Layer\",\n                    \"Layer_2\",\n                    \"Layer_3\",\n                    \"Layer_4\",\n                    \"Layer_5\",\n                    \"Layer_6\",\n                    \"Layer_7\",\n                    \"Layer_8\",\n                    \"Layer_9\",\n                    \"Layer_10\",\n                ]\n                if key in const_dict\n            ]\n\n            layer_names = [n for n in layer_names if n != \"\" and n]\n            material_defs = [\n                idf.getobject(\"MATERIAL\", name) for name in layer_names\n            ]  # TODO: handle air layers\n            airgap_material_defs = [\n                idf.getobject(\"MATERIAL:AIRGAP\", name) for name in layer_names\n            ]\n            simple_glazing_material_defs = [\n                idf.getobject(\"WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM\", name)\n                for name in layer_names\n            ]\n            no_mass_material_defs = [\n                idf.getobject(\"MATERIAL:NOMASS\", name) for name in layer_names\n            ]\n            materials = [Material(**m.to_dict()) if m else None for m in material_defs]\n            airgap_materials = [\n                AirGapMaterial(**m.to_dict()) if m else None\n                for m in airgap_material_defs\n            ]\n            simple_glazing_materials = [\n                SimpleGlazingMaterial(**m.to_dict()) if m else None\n                for m in simple_glazing_material_defs\n            ]\n            nomass_materials = [\n                NoMassMaterial(**m.to_dict()) if m else None\n                for m in no_mass_material_defs\n            ]\n\n            layers = [\n                m if m else (n if n else (o if o else p))\n                for m, n, o, p in zip(\n                    materials,\n                    airgap_materials,\n                    simple_glazing_materials,\n                    nomass_materials,\n                    strict=False,\n                )\n            ]\n\n            valid_layers = [layer for layer in layers if layer is not None]\n            if len(valid_layers) != len(layers):\n                logger.warning(\n                    f\"Construction {construction.Name} has missing layers. \"\n                    f\"Expected {len(layers)} layers, got {len(valid_layers)}.\"\n                    f\"Skipping construction extraction.\"\n                )\n                continue\n            construction = cls(name=construction.Name, layers=valid_layers)\n            res.append(construction)\n        return res\n\n    def add(self, idf: IDF):\n        \"\"\"Add the object to the IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the object to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        for layer in self.layers:\n            idf = layer.add(idf)\n        idf.newidfobject(\n            self.key,\n            Name=self.name,\n            **{\n                (f\"Layer_{i + 1}\" if i != 0 else \"Outside_Layer\"): layer.Name\n                for i, layer in enumerate(self.layers)\n            },\n        )\n        return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.Construction.r_value","title":"<code>r_value</code>  <code>property</code>","text":"<p>Return the R-value of the construction.</p> <p>Computed using the formula: R = sum(thickness_i / conductivity_i)</p> <p>Returns:</p> Name Type Description <code>r</code> <code>float</code> <p>The R-value of the construction (units: m^2.K/W).</p>"},{"location":"modules/interface/#epinterface.interface.Construction.add","title":"<code>add(idf)</code>","text":"<p>Add the object to the IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the object to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>def add(self, idf: IDF):\n    \"\"\"Add the object to the IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the object to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    for layer in self.layers:\n        idf = layer.add(idf)\n    idf.newidfobject(\n        self.key,\n        Name=self.name,\n        **{\n            (f\"Layer_{i + 1}\" if i != 0 else \"Outside_Layer\"): layer.Name\n            for i, layer in enumerate(self.layers)\n        },\n    )\n    return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.Construction.extract","title":"<code>extract(idf)</code>  <code>classmethod</code>","text":"<p>Extract objects from an IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to extract objects from.</p> required <p>Returns:</p> Name Type Description <code>constructions</code> <code>list[Construction]</code> <p>A list of objects extracted from the IDF object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>@classmethod\ndef extract(cls, idf: IDF):\n    \"\"\"Extract objects from an IDF object.\n\n    Args:\n        idf (IDF): The IDF object to extract objects from.\n\n    Returns:\n        constructions (list[Construction]): A list of objects extracted from the IDF object.\n    \"\"\"\n    constructions = idf.idfobjects[\"CONSTRUCTION\"]\n    res: list[Construction] = []\n    for construction in constructions:\n        const_dict = construction.to_dict()\n        layer_names = [\n            const_dict[key]\n            for key in [\n                \"Outside_Layer\",\n                \"Layer_2\",\n                \"Layer_3\",\n                \"Layer_4\",\n                \"Layer_5\",\n                \"Layer_6\",\n                \"Layer_7\",\n                \"Layer_8\",\n                \"Layer_9\",\n                \"Layer_10\",\n            ]\n            if key in const_dict\n        ]\n\n        layer_names = [n for n in layer_names if n != \"\" and n]\n        material_defs = [\n            idf.getobject(\"MATERIAL\", name) for name in layer_names\n        ]  # TODO: handle air layers\n        airgap_material_defs = [\n            idf.getobject(\"MATERIAL:AIRGAP\", name) for name in layer_names\n        ]\n        simple_glazing_material_defs = [\n            idf.getobject(\"WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM\", name)\n            for name in layer_names\n        ]\n        no_mass_material_defs = [\n            idf.getobject(\"MATERIAL:NOMASS\", name) for name in layer_names\n        ]\n        materials = [Material(**m.to_dict()) if m else None for m in material_defs]\n        airgap_materials = [\n            AirGapMaterial(**m.to_dict()) if m else None\n            for m in airgap_material_defs\n        ]\n        simple_glazing_materials = [\n            SimpleGlazingMaterial(**m.to_dict()) if m else None\n            for m in simple_glazing_material_defs\n        ]\n        nomass_materials = [\n            NoMassMaterial(**m.to_dict()) if m else None\n            for m in no_mass_material_defs\n        ]\n\n        layers = [\n            m if m else (n if n else (o if o else p))\n            for m, n, o, p in zip(\n                materials,\n                airgap_materials,\n                simple_glazing_materials,\n                nomass_materials,\n                strict=False,\n            )\n        ]\n\n        valid_layers = [layer for layer in layers if layer is not None]\n        if len(valid_layers) != len(layers):\n            logger.warning(\n                f\"Construction {construction.Name} has missing layers. \"\n                f\"Expected {len(layers)} layers, got {len(valid_layers)}.\"\n                f\"Skipping construction extraction.\"\n            )\n            continue\n        construction = cls(name=construction.Name, layers=valid_layers)\n        res.append(construction)\n    return res\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.DefaultMaterialLibrary","title":"<code>DefaultMaterialLibrary</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Default material library for storing some common material defs.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class DefaultMaterialLibrary(BaseModel):\n    \"\"\"Default material library for storing some common material defs.\"\"\"\n\n    wood: BaseMaterial = wood\n    gypsum: BaseMaterial = gypsum\n    drywall: BaseMaterial = drywall\n    osb: BaseMaterial = osb\n    concrete: BaseMaterial = concrete\n    insulation: BaseMaterial = insulation\n    stucco: BaseMaterial = stucco\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.ElectricEquipment","title":"<code>ElectricEquipment</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>ElectricEquipment object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class ElectricEquipment(BaseObj, extra=\"ignore\"):\n    \"\"\"ElectricEquipment object.\"\"\"\n\n    key: ClassVar[str] = \"ELECTRICEQUIPMENT\"\n    Name: str\n    Zone_or_ZoneList_Name: str\n    Schedule_Name: str\n    Design_Level_Calculation_Method: DesignLevelCalculationMethodType = \"Watts/Area\"\n    Design_Level: float | None = None\n    Watts_per_Zone_Floor_Area: float | None = None\n    Watts_per_Person: float | None = None\n    Fraction_Latent: float = 0.00\n    Fraction_Radiant: float = 0.2\n    Fraction_Lost: float = 0\n    EndUse_Subcategory: str | None = None\n\n    def model_dump(self, **kwargs: Any) -&gt; dict[str, Any]:\n        \"\"\"Dump model to dict; use Watts_per_Floor_Area alias when EnergyPlus &gt;= 24.0.\"\"\"\n        data = super().model_dump(**kwargs)\n        if _energyplus_version_gte(24.0) and \"Watts_per_Zone_Floor_Area\" in data:\n            data[\"Watts_per_Floor_Area\"] = data.pop(\"Watts_per_Zone_Floor_Area\")\n        return data\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.ElectricEquipment.model_dump","title":"<code>model_dump(**kwargs)</code>","text":"<p>Dump model to dict; use Watts_per_Floor_Area alias when EnergyPlus &gt;= 24.0.</p> Source code in <code>epinterface/interface.py</code> <pre><code>def model_dump(self, **kwargs: Any) -&gt; dict[str, Any]:\n    \"\"\"Dump model to dict; use Watts_per_Floor_Area alias when EnergyPlus &gt;= 24.0.\"\"\"\n    data = super().model_dump(**kwargs)\n    if _energyplus_version_gte(24.0) and \"Watts_per_Zone_Floor_Area\" in data:\n        data[\"Watts_per_Floor_Area\"] = data.pop(\"Watts_per_Zone_Floor_Area\")\n    return data\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.HVACTemplateThermostat","title":"<code>HVACTemplateThermostat</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>HVACTemplateThermostat object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class HVACTemplateThermostat(BaseModel):\n    \"\"\"HVACTemplateThermostat object.\"\"\"\n\n    Name: str\n    Heating_Setpoint_Schedule_Name: str | None = None\n    Constant_Heating_Setpoint: float | None = 21\n    Cooling_Setpoint_Schedule_Name: str | None = None\n    Constant_Cooling_Setpoint: float | None = 24\n\n    def add(self, idf: IDF):\n        \"\"\"Add the object to the IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the object to.\n\n        Returns:\n            idf (IDF): The updated IDF object\n        \"\"\"\n        idf.newidfobject(\"HVACTEMPLATE:THERMOSTAT\", **self.model_dump())\n        return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.HVACTemplateThermostat.add","title":"<code>add(idf)</code>","text":"<p>Add the object to the IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the object to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object</p> Source code in <code>epinterface/interface.py</code> <pre><code>def add(self, idf: IDF):\n    \"\"\"Add the object to the IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the object to.\n\n    Returns:\n        idf (IDF): The updated IDF object\n    \"\"\"\n    idf.newidfobject(\"HVACTEMPLATE:THERMOSTAT\", **self.model_dump())\n    return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.HVACTemplateZoneIdealLoadsAirSystem","title":"<code>HVACTemplateZoneIdealLoadsAirSystem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>HVACTemplateZoneIdealLoadsAirSystem object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class HVACTemplateZoneIdealLoadsAirSystem(BaseModel):\n    \"\"\"HVACTemplateZoneIdealLoadsAirSystem object.\"\"\"\n\n    Zone_Name: str\n    Template_Thermostat_Name: str\n    System_Availability_Schedule_Name: str | None = None\n    Heating_Availability_Schedule_Name: str | None = None\n    Cooling_Availability_Schedule_Name: str | None = None\n    Maximum_Heating_Supply_Air_Temperature: float = 30\n    Minimum_Cooling_Supply_Air_Temperature: float = 18\n    Maximum_Heating_Supply_Air_Humidity_Ratio: float = 0.0156\n    Minimum_Cooling_Supply_Air_Humidity_Ratio: float = 0.0077\n    Heating_Limit: IdealLoadsLimitType = \"NoLimit\"\n    Maximum_Heating_Air_Flow_Rate: float | None | Literal[\"autosize\"] = None\n    Maximum_Sensible_Heating_Capacity: float | None | Literal[\"autosize\"] = None\n    Cooling_Limit: IdealLoadsLimitType = \"NoLimit\"\n    Maximum_Cooling_Air_Flow_Rate: float | None | Literal[\"autosize\"] = None\n    Maximum_Total_Cooling_Capacity: float | None | Literal[\"autosize\"] = None\n    Dehumidification_Control_Type: DehumidificationControlTypeType = \"None\"\n    Cooling_Sensible_Heat_Ratio: float = 0.7\n    Dehumidification_Setpoint: float = 60\n    Humidification_Control_Type: HumidificationControlTypeType = \"None\"\n    Humidification_Setpoint: float = 30\n    Outdoor_Air_Method: OutdoorAirMethodType = \"None\"\n    Outdoor_Air_Flow_Rate_per_Person: float = 0.00944\n    Outdoor_Air_Flow_Rate_per_Zone_Floor_Area: float = 0.00025\n    Outdoor_Air_Flow_Rate_per_Zone: float = 0.0\n    # Design_Specification_Outdoor_Air_Object_Name: Optional[str] = None\n    Demand_Controlled_Ventilation_Type: DemandControlledVentilationTypeType = \"None\"\n    Outdoor_Air_Economizer_Type: OutdoorAirEconomizerTypeType = \"NoEconomizer\"\n    Heat_Recovery_Type: HeatRecoveryTypeType = \"None\"\n    Sensible_Heat_Recovery_Effectiveness: float = 0.7\n    Latent_Heat_Recovery_Effectiveness: float = 0.65\n\n    def add(self, idf: IDF):\n        \"\"\"Add the object to the IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the object to.\n\n        Returns:\n            idf (IDF): The updated IDF object\n        \"\"\"\n        idf.newidfobject(\"HVACTEMPLATE:ZONE:IDEALLOADSAIRSYSTEM\", **self.model_dump())\n        return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.HVACTemplateZoneIdealLoadsAirSystem.add","title":"<code>add(idf)</code>","text":"<p>Add the object to the IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the object to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object</p> Source code in <code>epinterface/interface.py</code> <pre><code>def add(self, idf: IDF):\n    \"\"\"Add the object to the IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the object to.\n\n    Returns:\n        idf (IDF): The updated IDF object\n    \"\"\"\n    idf.newidfobject(\"HVACTEMPLATE:ZONE:IDEALLOADSAIRSYSTEM\", **self.model_dump())\n    return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.InternalMass","title":"<code>InternalMass</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>InternalMass object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class InternalMass(BaseObj, extra=\"ignore\"):\n    \"\"\"InternalMass object.\"\"\"\n\n    key: ClassVar[str] = \"INTERNALMASS\"\n    Name: str\n    Zone_or_ZoneList_Name: str\n    Construction_Name: str\n    Surface_Area: float\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.Lights","title":"<code>Lights</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>Lights object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class Lights(BaseObj, extra=\"ignore\"):\n    \"\"\"Lights object.\"\"\"\n\n    key: ClassVar[str] = \"LIGHTS\"\n    Name: str\n    Zone_or_ZoneList_Name: str\n    Schedule_Name: str\n    Design_Level_Calculation_Method: DesignLevelCalculationMethodType = \"Watts/Area\"\n    Lighting_Level: float | None = None\n    Watts_per_Zone_Floor_Area: float | None = None\n    Watts_per_Person: float | None = None\n    Return_Air_Fraction: float = 0\n    Fraction_Radiant: float = 0.42\n    Fraction_Visible: float = 0.18\n    Fraction_Replaceable: float | None = 1\n    EndUse_Subcategory: str | None = None\n\n    def model_dump(self, **kwargs: Any) -&gt; dict[str, Any]:\n        \"\"\"Dump model to dict; use Watts_per_Floor_Area alias when EnergyPlus &gt;= 24.0.\"\"\"\n        data = super().model_dump(**kwargs)\n        if _energyplus_version_gte(24.0) and \"Watts_per_Zone_Floor_Area\" in data:\n            data[\"Watts_per_Floor_Area\"] = data.pop(\"Watts_per_Zone_Floor_Area\")\n        return data\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.Lights.model_dump","title":"<code>model_dump(**kwargs)</code>","text":"<p>Dump model to dict; use Watts_per_Floor_Area alias when EnergyPlus &gt;= 24.0.</p> Source code in <code>epinterface/interface.py</code> <pre><code>def model_dump(self, **kwargs: Any) -&gt; dict[str, Any]:\n    \"\"\"Dump model to dict; use Watts_per_Floor_Area alias when EnergyPlus &gt;= 24.0.\"\"\"\n    data = super().model_dump(**kwargs)\n    if _energyplus_version_gte(24.0) and \"Watts_per_Zone_Floor_Area\" in data:\n        data[\"Watts_per_Floor_Area\"] = data.pop(\"Watts_per_Zone_Floor_Area\")\n    return data\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.Material","title":"<code>Material</code>","text":"<p>               Bases: <code>BaseObj</code>, <code>BaseMaterial</code></p> <p>Material object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class Material(BaseObj, BaseMaterial, extra=\"ignore\"):\n    \"\"\"Material object.\"\"\"\n\n    key: ClassVar[str] = \"MATERIAL\"\n    Name: str\n    Thickness: float\n\n    @field_validator(\"Thermal_Absorptance\", mode=\"before\")\n    def str_cast(cls, v):\n        \"\"\"Cast the value to a float if it is a string or empty.\n\n        Args:\n            v (Any): The value to cast.\n\n        Returns:\n            v (float): The casted value.\n        \"\"\"\n        if v == \"\" or v is None:\n            return None\n        return float(v)\n\n    @property\n    def r(self):\n        \"\"\"Return the R of the material.\"\"\"\n        return self.Thickness / self.Conductivity\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.Material.r","title":"<code>r</code>  <code>property</code>","text":"<p>Return the R of the material.</p>"},{"location":"modules/interface/#epinterface.interface.Material.str_cast","title":"<code>str_cast(v)</code>","text":"<p>Cast the value to a float if it is a string or empty.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Any</code> <p>The value to cast.</p> required <p>Returns:</p> Name Type Description <code>v</code> <code>float</code> <p>The casted value.</p> Source code in <code>epinterface/interface.py</code> <pre><code>@field_validator(\"Thermal_Absorptance\", mode=\"before\")\ndef str_cast(cls, v):\n    \"\"\"Cast the value to a float if it is a string or empty.\n\n    Args:\n        v (Any): The value to cast.\n\n    Returns:\n        v (float): The casted value.\n    \"\"\"\n    if v == \"\" or v is None:\n        return None\n    return float(v)\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.NoMassMaterial","title":"<code>NoMassMaterial</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>NoMassMaterial object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class NoMassMaterial(BaseObj, extra=\"ignore\"):\n    \"\"\"NoMassMaterial object.\"\"\"\n\n    key: ClassVar[str] = \"MATERIAL:NOMASS\"\n    Name: str\n    Roughness: str\n    Thermal_Resistance: float\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.People","title":"<code>People</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>People object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class People(BaseObj, extra=\"ignore\"):\n    \"\"\"People object.\"\"\"\n\n    key: ClassVar[str] = \"PEOPLE\"\n    Name: str\n    Zone_or_ZoneList_Name: str\n    Number_of_People_Schedule_Name: str\n    Number_of_People_Calculation_Method: NumberOfPeopleCalculationMethodType\n    Number_of_People: float | None = None\n    People_per_Floor_Area: float | None = None\n    Floor_Area_per_Person: float | None = None\n    Fraction_Radiant: float = 0.3\n    Sensible_Heat_Fraction: float | Literal[\"autocalculate\"] = \"autocalculate\"\n    Activity_Level_Schedule_Name: str\n    # Carbon_Dioxide_Generation_Rate: Optional[float] = None\n    Enable_ASHRAE_55_Comfort_Warnings: Literal[\"Yes\", \"No\"] = \"No\"\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.RunPeriod","title":"<code>RunPeriod</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>RunPeriod object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class RunPeriod(BaseObj, extra=\"ignore\"):\n    \"\"\"RunPeriod object.\"\"\"\n\n    key: ClassVar[str] = \"RUNPERIOD\"\n    Name: str\n    Begin_Month: int\n    Begin_Day_of_Month: int\n    Begin_Year: int | None = None\n    End_Month: int\n    End_Day_of_Month: int\n    End_Year: int | None = None\n    Day_of_Week_for_Start_Day: Literal[\n        \"Sunday\",\n        \"Monday\",\n        \"Tuesday\",\n        \"Wednesday\",\n        \"Thursday\",\n        \"Friday\",\n        \"Saturday\",\n    ] = \"Sunday\"\n    Use_Weather_File_Daylight_Saving_Period: Literal[\"Yes\", \"No\"] = \"No\"\n    Use_Weather_File_Holidays_and_Special_Days: Literal[\"Yes\", \"No\"] = \"No\"\n    Apply_Weekend_Holiday_Rule: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Use_Weather_File_Rain_Indicators: Literal[\"Yes\", \"No\"] = \"No\"\n    Use_Weather_File_Snow_Indicators: Literal[\"Yes\", \"No\"] = \"No\"\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.ScheduleDayHourly","title":"<code>ScheduleDayHourly</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>ScheduleDayHourly object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class ScheduleDayHourly(BaseObj, extra=\"ignore\"):\n    \"\"\"ScheduleDayHourly object.\"\"\"\n\n    key: ClassVar[str] = \"SCHEDULE:DAY:HOURLY\"\n    Name: str\n    Schedule_Type_Limits_Name: str\n    Hour_1: float\n    Hour_2: float\n    Hour_3: float\n    Hour_4: float\n    Hour_5: float\n    Hour_6: float\n    Hour_7: float\n    Hour_8: float\n    Hour_9: float\n    Hour_10: float\n    Hour_11: float\n    Hour_12: float\n    Hour_13: float\n    Hour_14: float\n    Hour_15: float\n    Hour_16: float\n    Hour_17: float\n    Hour_18: float\n    Hour_19: float\n    Hour_20: float\n    Hour_21: float\n    Hour_22: float\n    Hour_23: float\n    Hour_24: float\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.ScheduleTypeLimits","title":"<code>ScheduleTypeLimits</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>ScheduleTypeLimits object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class ScheduleTypeLimits(BaseObj, extra=\"ignore\"):\n    \"\"\"ScheduleTypeLimits object.\"\"\"\n\n    key: ClassVar[str] = \"SCHEDULETYPELIMITS\"\n    Name: str\n    Lower_Limit_Value: float | None = None\n    Upper_Limit_Value: float | None = None\n    Numeric_Type: Literal[\"Continuous\", \"Discrete\"] | None = None\n    Unit_Type: (\n        Literal[\n            \"Dimensionless\",\n            \"Temperature\",\n            \"DeltaTemperature\",\n            \"PrecipitationRate\",\n            \"Angle\",\n            \"ConvectionCoefficient\",\n            \"ActivityLevel\",\n            \"Velocity\",\n            \"Capacity\",\n            \"Power\",\n            \"Availability\",\n            \"Percent\",\n            \"Control\",\n            \"Mode\",\n        ]\n        | None\n    ) = None\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.ScheduleWeekDaily","title":"<code>ScheduleWeekDaily</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>ScheduleWeekDaily object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class ScheduleWeekDaily(BaseObj, extra=\"ignore\"):\n    \"\"\"ScheduleWeekDaily object.\"\"\"\n\n    key: ClassVar[str] = \"SCHEDULE:WEEK:DAILY\"\n    Name: str\n    Monday_ScheduleDay_Name: str\n    Tuesday_ScheduleDay_Name: str\n    Wednesday_ScheduleDay_Name: str\n    Thursday_ScheduleDay_Name: str\n    Friday_ScheduleDay_Name: str\n    Saturday_ScheduleDay_Name: str\n    Sunday_ScheduleDay_Name: str\n    SummerDesignDay_ScheduleDay_Name: str | None = None\n    WinterDesignDay_ScheduleDay_Name: str | None = None\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _validate_design_day_schedules(cls, data):\n        if data.get(\"SummerDesignDay_ScheduleDay_Name\") is None:\n            data[\"SummerDesignDay_ScheduleDay_Name\"] = data[\"Monday_ScheduleDay_Name\"]\n        if data.get(\"WinterDesignDay_ScheduleDay_Name\") is None:\n            data[\"WinterDesignDay_ScheduleDay_Name\"] = data[\"Monday_ScheduleDay_Name\"]\n        return data\n\n    @computed_field\n    @property\n    def CustomDay1_ScheduleDay_Name(self) -&gt; str:\n        \"\"\"Automatically set additional day schedules.\"\"\"\n        return self.Monday_ScheduleDay_Name\n\n    @computed_field\n    @property\n    def CustomDay2_ScheduleDay_Name(self) -&gt; str:\n        \"\"\"Automatically set additional day schedules.\"\"\"\n        return self.Monday_ScheduleDay_Name\n\n    @computed_field\n    @property\n    def Holiday_ScheduleDay_Name(self) -&gt; str:\n        \"\"\"Automatically set additional day schedules.\"\"\"\n        return self.Sunday_ScheduleDay_Name\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.ScheduleWeekDaily.CustomDay1_ScheduleDay_Name","title":"<code>CustomDay1_ScheduleDay_Name</code>  <code>property</code>","text":"<p>Automatically set additional day schedules.</p>"},{"location":"modules/interface/#epinterface.interface.ScheduleWeekDaily.CustomDay2_ScheduleDay_Name","title":"<code>CustomDay2_ScheduleDay_Name</code>  <code>property</code>","text":"<p>Automatically set additional day schedules.</p>"},{"location":"modules/interface/#epinterface.interface.ScheduleWeekDaily.Holiday_ScheduleDay_Name","title":"<code>Holiday_ScheduleDay_Name</code>  <code>property</code>","text":"<p>Automatically set additional day schedules.</p>"},{"location":"modules/interface/#epinterface.interface.ScheduleYear","title":"<code>ScheduleYear</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>ScheduleYear object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class ScheduleYear(BaseObj, extra=\"ignore\"):\n    \"\"\"ScheduleYear object.\"\"\"\n\n    key: ClassVar[str] = \"SCHEDULE:YEAR\"\n    Name: str\n    Schedule_Type_Limits_Name: str\n\n    ScheduleWeek_Name_1: str\n    Start_Month_1: int\n    Start_Day_1: int\n    End_Month_1: int\n    End_Day_1: int\n\n    ScheduleWeek_Name_2: str | None = None\n    Start_Month_2: int | None = None\n    Start_Day_2: int | None = None\n    End_Month_2: int | None = None\n    End_Day_2: int | None = None\n\n    ScheduleWeek_Name_3: str | None = None\n    Start_Month_3: int | None = None\n    Start_Day_3: int | None = None\n    End_Month_3: int | None = None\n    End_Day_3: int | None = None\n\n    ScheduleWeek_Name_4: str | None = None\n    Start_Month_4: int | None = None\n    Start_Day_4: int | None = None\n    End_Month_4: int | None = None\n    End_Day_4: int | None = None\n\n    ScheduleWeek_Name_5: str | None = None\n    Start_Month_5: int | None = None\n    Start_Day_5: int | None = None\n    End_Month_5: int | None = None\n    End_Day_5: int | None = None\n\n    ScheduleWeek_Name_6: str | None = None\n    Start_Month_6: int | None = None\n    Start_Day_6: int | None = None\n    End_Month_6: int | None = None\n    End_Day_6: int | None = None\n\n    ScheduleWeek_Name_7: str | None = None\n    Start_Month_7: int | None = None\n    Start_Day_7: int | None = None\n    End_Month_7: int | None = None\n    End_Day_7: int | None = None\n\n    ScheduleWeek_Name_8: str | None = None\n    Start_Month_8: int | None = None\n    Start_Day_8: int | None = None\n    End_Month_8: int | None = None\n    End_Day_8: int | None = None\n\n    ScheduleWeek_Name_9: str | None = None\n    Start_Month_9: int | None = None\n    Start_Day_9: int | None = None\n    End_Month_9: int | None = None\n    End_Day_9: int | None = None\n\n    ScheduleWeek_Name_10: str | None = None\n    Start_Month_10: int | None = None\n    Start_Day_10: int | None = None\n    End_Month_10: int | None = None\n    End_Day_10: int | None = None\n\n    ScheduleWeek_Name_11: str | None = None\n    Start_Month_11: int | None = None\n    Start_Day_11: int | None = None\n    End_Month_11: int | None = None\n    End_Day_11: int | None = None\n\n    ScheduleWeek_Name_12: str | None = None\n    Start_Month_12: int | None = None\n    Start_Day_12: int | None = None\n    End_Month_12: int | None = None\n    End_Day_12: int | None = None\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.SimpleGlazingMaterial","title":"<code>SimpleGlazingMaterial</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>SimpleGlazingMaterial object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class SimpleGlazingMaterial(BaseObj, extra=\"ignore\"):\n    \"\"\"SimpleGlazingMaterial object.\"\"\"\n\n    key: ClassVar[str] = \"WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM\"\n    Name: str\n    UFactor: float\n    Solar_Heat_Gain_Coefficient: float\n    Visible_Transmittance: float\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.SimulationControl","title":"<code>SimulationControl</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>SimulationControl object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class SimulationControl(BaseObj, extra=\"ignore\"):\n    \"\"\"SimulationControl object.\"\"\"\n\n    key: ClassVar[str] = \"SIMULATIONCONTROL\"\n    Do_Zone_Sizing_Calculation: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Do_System_Sizing_Calculation: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Do_Plant_Sizing_Calculation: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Run_Simulation_for_Sizing_Periods: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Run_Simulation_for_Weather_File_Run_Periods: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Do_HVAC_Sizing_Simulation_for_Sizing_Periods: Literal[\"Yes\", \"No\"] = \"Yes\"\n    Maximum_Number_of_HVAC_Sizing_Simulation_Passes: int = 1\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.SiteGroundTemperature","title":"<code>SiteGroundTemperature</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>GroundTemperature object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class SiteGroundTemperature(BaseObj, extra=\"ignore\"):\n    \"\"\"GroundTemperature object.\"\"\"\n\n    key: ClassVar[str] = \"SITE:GROUNDTEMPERATURE:BUILDINGSURFACE\"\n    January_Ground_Temperature: float\n    February_Ground_Temperature: float\n    March_Ground_Temperature: float\n    April_Ground_Temperature: float\n    May_Ground_Temperature: float\n    June_Ground_Temperature: float\n    July_Ground_Temperature: float\n    August_Ground_Temperature: float\n    September_Ground_Temperature: float\n    October_Ground_Temperature: float\n    November_Ground_Temperature: float\n    December_Ground_Temperature: float\n\n    @classmethod\n    def FromValues(cls, values: list[float]):\n        \"\"\"Create a new SiteGroundTemperature object from a list of 12 monthly values.\n\n        Args:\n            values (list[float]): A list of 12 monthly values.\n\n        Returns:\n            ground_temp (SiteGroundTemperature): The new SiteGroundTemperature object.\n        \"\"\"\n        if len(values) != 12:\n            raise ValueError(f\"GROUNDTEMP:EXPECTED_12:RECEIVED_{len(values)}\")\n        return cls(\n            January_Ground_Temperature=values[0],\n            February_Ground_Temperature=values[1],\n            March_Ground_Temperature=values[2],\n            April_Ground_Temperature=values[3],\n            May_Ground_Temperature=values[4],\n            June_Ground_Temperature=values[5],\n            July_Ground_Temperature=values[6],\n            August_Ground_Temperature=values[7],\n            September_Ground_Temperature=values[8],\n            October_Ground_Temperature=values[9],\n            November_Ground_Temperature=values[10],\n            December_Ground_Temperature=values[11],\n        )\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.SiteGroundTemperature.FromValues","title":"<code>FromValues(values)</code>  <code>classmethod</code>","text":"<p>Create a new SiteGroundTemperature object from a list of 12 monthly values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list[float]</code> <p>A list of 12 monthly values.</p> required <p>Returns:</p> Name Type Description <code>ground_temp</code> <code>SiteGroundTemperature</code> <p>The new SiteGroundTemperature object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>@classmethod\ndef FromValues(cls, values: list[float]):\n    \"\"\"Create a new SiteGroundTemperature object from a list of 12 monthly values.\n\n    Args:\n        values (list[float]): A list of 12 monthly values.\n\n    Returns:\n        ground_temp (SiteGroundTemperature): The new SiteGroundTemperature object.\n    \"\"\"\n    if len(values) != 12:\n        raise ValueError(f\"GROUNDTEMP:EXPECTED_12:RECEIVED_{len(values)}\")\n    return cls(\n        January_Ground_Temperature=values[0],\n        February_Ground_Temperature=values[1],\n        March_Ground_Temperature=values[2],\n        April_Ground_Temperature=values[3],\n        May_Ground_Temperature=values[4],\n        June_Ground_Temperature=values[5],\n        July_Ground_Temperature=values[6],\n        August_Ground_Temperature=values[7],\n        September_Ground_Temperature=values[8],\n        October_Ground_Temperature=values[9],\n        November_Ground_Temperature=values[10],\n        December_Ground_Temperature=values[11],\n    )\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.SizingParameters","title":"<code>SizingParameters</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>SizingParameters object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class SizingParameters(BaseObj, extra=\"ignore\"):\n    \"\"\"SizingParameters object.\"\"\"\n\n    key: ClassVar[str] = \"SIZING:PARAMETERS\"\n    Heating_Sizing_Factor: float\n    Cooling_Sizing_Factor: float\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.Timestep","title":"<code>Timestep</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>Timestep object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class Timestep(BaseObj, extra=\"ignore\"):\n    \"\"\"Timestep object.\"\"\"\n\n    key: ClassVar[str] = \"TIMESTEP\"\n    Number_of_Timesteps_per_Hour: int = 6\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.WaterUseEquipment","title":"<code>WaterUseEquipment</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>WaterUseEquipment object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class WaterUseEquipment(BaseObj, extra=\"ignore\"):\n    \"\"\"WaterUseEquipment object.\"\"\"\n\n    key: ClassVar[str] = \"WATERUSE:EQUIPMENT\"\n    Name: str\n    EndUse_Subcategory: str | None = None\n    Peak_Flow_Rate: float\n    Flow_Rate_Fraction_Schedule_Name: str | None = None\n    Target_Temperature_Schedule_Name: str | None = None\n    Hot_Water_Supply_Temperature_Schedule_Name: str | None = None\n    Cold_Water_Supply_Temperature_Schedule_Name: str | None = None\n    Zone_Name: str | None = None\n    Sensible_Fraction_Schedule_Name: str | None = None\n    Latent_Fraction_Schedule_Name: str | None = None\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.ZoneInfiltrationDesignFlowRate","title":"<code>ZoneInfiltrationDesignFlowRate</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>ZoneInfiltrationDesignFlowRate object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class ZoneInfiltrationDesignFlowRate(BaseObj, extra=\"ignore\"):\n    \"\"\"ZoneInfiltrationDesignFlowRate object.\"\"\"\n\n    key: ClassVar[str] = \"ZONEINFILTRATION:DESIGNFLOWRATE\"\n    Name: str\n    Zone_or_ZoneList_Name: str\n    Schedule_Name: str\n    Design_Flow_Rate_Calculation_Method: InfDesignFlowRateCalculationMethodType\n    Design_Flow_Rate: float | None = None\n    Flow_Rate_per_Floor_Area: float | None = None\n    Flow_Rate_per_Exterior_Surface_Area: float | None = None\n    Air_Changes_per_Hour: float | None = None\n    # Constant_Term_Coefficient: float = 0.606\n    # Temperature_Term_Coefficient: float = 3.6359996e-2\n    # Velocity_Term_Coefficient: float = 0.117765\n    Constant_Term_Coefficient: float = 1  # updated to assume that we have the actual infiltration values - the more detailed coefficient methodology would likely overestimate the infiltration rate, as there are many days where the tmperature deltas exceeds 10 degrees.\n    Temperature_Term_Coefficient: float = 0\n    Velocity_Term_Coefficient: float = 0\n    Velocity_Squared_Term_Coefficient: float = (\n        0  # updated as we don't make assumptions about the wind velocity\n    )\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.ZoneList","title":"<code>ZoneList</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>ZoneList object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class ZoneList(BaseModel, extra=\"ignore\"):\n    \"\"\"ZoneList object.\"\"\"\n\n    Name: str\n    Names: list[str]\n\n    def add(self, idf: IDF):\n        \"\"\"Add the object to the IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the object to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        names = {\n            f\"Zone_{i + 1}_Name\": zone for i, zone in enumerate(self.Names) if zone\n        }\n        idf.newidfobject(\"ZONELIST\", Name=self.Name, **names)\n        return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.ZoneList.add","title":"<code>add(idf)</code>","text":"<p>Add the object to the IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the object to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>def add(self, idf: IDF):\n    \"\"\"Add the object to the IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the object to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    names = {\n        f\"Zone_{i + 1}_Name\": zone for i, zone in enumerate(self.Names) if zone\n    }\n    idf.newidfobject(\"ZONELIST\", Name=self.Name, **names)\n    return idf\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.ZoneVentilationWindAndStackOpenArea","title":"<code>ZoneVentilationWindAndStackOpenArea</code>","text":"<p>               Bases: <code>BaseObj</code></p> <p>ZoneVentilationWindAndStackOpenArea object.</p> Source code in <code>epinterface/interface.py</code> <pre><code>class ZoneVentilationWindAndStackOpenArea(BaseObj, extra=\"ignore\"):\n    \"\"\"ZoneVentilationWindAndStackOpenArea object.\"\"\"\n\n    key: ClassVar[str] = \"ZONEVENTILATION:WINDANDSTACKOPENAREA\"\n    Name: str\n    Zone_or_Space_Name: str\n    Opening_Area: float\n    Opening_Area_Fraction_Schedule_Name: str\n    Opening_Effectiveness: str = \"AutoCalculate\"\n    Effective_Angle: float = 0\n    Height_Difference: float\n    Discharge_Coefficient_for_Opening: str = \"AutoCalculate\"\n    Minimum_Indoor_Temperature: float | None = None\n    Minimum_Indoor_Temperature_Schedule_Name: str | None = None\n    Maximum_Indoor_Temperature: float | None = None\n    Maximum_Indoor_Temperature_Schedule_Name: str | None = None\n    Delta_Temperature: float | None = None\n    Delta_Temperature_Schedule_Name: str | None = None\n    Minimum_Outdoor_Temperature: float | None = None\n    Minimum_Outdoor_Temperature_Schedule_Name: str | None = None\n    Maximum_Outdoor_Temperature: float | None = None\n    Maximum_Outdoor_Temperature_Schedule_Name: str | None = None\n    Maximum_Wind_Speed: float = 40\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.add_default_schedules","title":"<code>add_default_schedules(idf)</code>","text":"<p>Helper to add default schedules to the IDF model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the schedules to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The IDF model with the added schedules.</p> <code>scheds</code> <code>dict[str, Schedule]</code> <p>A dictionary of the added schedules.</p> Source code in <code>epinterface/interface.py</code> <pre><code>def add_default_schedules(idf: IDF) -&gt; tuple[IDF, dict[str, Schedule]]:\n    \"\"\"Helper to add default schedules to the IDF model.\n\n    Args:\n        idf (IDF): The IDF model to add the schedules to.\n\n    Returns:\n        idf (IDF): The IDF model with the added schedules.\n        scheds (dict[str, Schedule]): A dictionary of the added schedules.\n    \"\"\"\n    # create constant scheds\n    all_scheds: dict[str, Schedule] = {}\n    always_on_schedule = Schedule.constant_schedule(Name=\"Always_On\", value=1)\n    always_off_schedule = Schedule.constant_schedule(Name=\"Always_Off\", value=0)\n    all_scheds[\"Always_On\"] = always_on_schedule\n    all_scheds[\"Always_Off\"] = always_off_schedule\n    year, *_ = always_on_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n    year, *_ = always_off_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n\n    always_on_schedule = Schedule.constant_schedule(Name=\"Always On\", value=1)\n    always_off_schedule = Schedule.constant_schedule(Name=\"Always Off\", value=0)\n    all_scheds[\"Always On\"] = always_on_schedule\n    all_scheds[\"Always Off\"] = always_off_schedule\n    year, *_ = always_on_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n    year, *_ = always_off_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n\n    always_on_schedule = Schedule.constant_schedule(Name=\"On\", value=1)\n    always_off_schedule = Schedule.constant_schedule(Name=\"Off\", value=0)\n    all_scheds[\"On\"] = always_on_schedule\n    all_scheds[\"Off\"] = always_off_schedule\n    year, *_ = always_on_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n    year, *_ = always_off_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n\n    always_on_schedule = Schedule.constant_schedule(Name=\"AllOn\", value=1)\n    always_off_schedule = Schedule.constant_schedule(Name=\"AllOff\", value=0)\n    all_scheds[\"AllOn\"] = always_on_schedule\n    all_scheds[\"AllOff\"] = always_off_schedule\n    year, *_ = always_on_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n    year, *_ = always_off_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n\n    always_on_schedule = Schedule.constant_schedule(Name=\"AlwaysOn\", value=1)\n    always_off_schedule = Schedule.constant_schedule(Name=\"AlwaysOff\", value=0)\n    all_scheds[\"AlwaysOn\"] = always_on_schedule\n    all_scheds[\"AlwaysOff\"] = always_off_schedule\n    year, *_ = always_on_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n    year, *_ = always_off_schedule.to_year_week_day()\n    year.to_epbunch(idf)\n\n    return idf, all_scheds\n</code></pre>"},{"location":"modules/interface/#epinterface.interface.add_default_sim_controls","title":"<code>add_default_sim_controls(idf)</code>","text":"<p>Helper to add default simulation controls to the IDF model.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF model to add the simulation controls to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The IDF model with the added simulation controls.</p> Source code in <code>epinterface/interface.py</code> <pre><code>def add_default_sim_controls(idf: IDF) -&gt; IDF:\n    \"\"\"Helper to add default simulation controls to the IDF model.\n\n    Args:\n        idf (IDF): The IDF model to add the simulation controls to.\n\n    Returns:\n        IDF: The IDF model with the added simulation controls.\n    \"\"\"\n    # Configure simulation\n    sim_control = SimulationControl(\n        Do_Zone_Sizing_Calculation=\"Yes\",\n        Do_System_Sizing_Calculation=\"Yes\",\n        Do_Plant_Sizing_Calculation=\"No\",\n        Run_Simulation_for_Sizing_Periods=\"Yes\",\n        Run_Simulation_for_Weather_File_Run_Periods=\"Yes\",\n        Do_HVAC_Sizing_Simulation_for_Sizing_Periods=\"Yes\",\n        Maximum_Number_of_HVAC_Sizing_Simulation_Passes=2,\n    )\n    sim_control.add(idf)\n\n    # Configure run period\n    run_period = RunPeriod(\n        Name=\"Year\",\n        Use_Weather_File_Daylight_Saving_Period=\"No\",\n        Use_Weather_File_Rain_Indicators=\"No\",\n        Use_Weather_File_Snow_Indicators=\"No\",\n        Use_Weather_File_Holidays_and_Special_Days=\"No\",\n        Begin_Month=1,\n        Begin_Day_of_Month=1,\n        End_Month=12,\n        End_Day_of_Month=31,\n        Day_of_Week_for_Start_Day=\"Sunday\",\n    )\n    run_period.add(idf)\n\n    # configure timestep\n    timestep = Timestep(\n        Number_of_Timesteps_per_Hour=6,\n    )\n    timestep.add(idf)\n\n    sizing = SizingParameters(\n        Heating_Sizing_Factor=1.15,\n        Cooling_Sizing_Factor=1.15,\n    )\n    sizing.add(idf)\n\n    return idf\n</code></pre>"},{"location":"modules/weather/","title":"Weather","text":"<p>Weather file fetching and caching.</p>"},{"location":"modules/weather/#epinterface.weather.BaseWeather","title":"<code>BaseWeather</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A base class for fetching weather files.</p> <p>Responsible for fetching weather files from a URL and extracting the .epw and .ddy files.</p> <p>Also takes care of caching the weather files in a directory.</p> Source code in <code>epinterface/weather.py</code> <pre><code>class BaseWeather(BaseModel):\n    \"\"\"A base class for fetching weather files.\n\n    Responsible for fetching weather files from a URL and extracting the .epw and .ddy files.\n\n    Also takes care of caching the weather files in a directory.\n    \"\"\"\n\n    Weather: WeatherUrl | Path = Field(\n        default=WeatherUrl(  # pyright: ignore [reportCallIssue]\n            \"https://climate.onebuilding.org/WMO_Region_4_North_and_Central_America/USA_United_States_of_America/MA_Massachusetts/USA_MA_Boston-Logan.Intl.AP.725090_TMYx.2009-2023.zip\"\n        )\n    )\n\n    def fetch_weather(self, cache_dir: Path | str):  # noqa: C901\n        \"\"\"Fetch the weather file from the URL and extract the .epw and .ddy files.\n\n        Args:\n            cache_dir (Path | str): The directory to cache the weather files.\n\n        Returns:\n            epw_path (Path): The path to the .epw file.\n            ddy_path (Path): The path to the .ddy file.\n        \"\"\"\n        if isinstance(cache_dir, str):\n            cache_dir = Path(cache_dir)\n\n        if isinstance(self.Weather, AnyUrl) and (\n            not self.Weather.path or not self.Weather.path.endswith(\".zip\")\n        ):\n            raise NotAZipError()\n        if isinstance(self.Weather, Path) and not self.Weather.suffix == \".zip\":\n            raise NotAZipError()\n        if isinstance(self.Weather, Path) and not self.Weather.anchor:\n            msg = f\"Invalid weather path: {self.Weather}\"\n            raise ValueError(msg)\n        if isinstance(self.Weather, Path) and not self.Weather.exists():\n            msg = f\"File {self.Weather} does not exist.\"\n            raise FileNotFoundError(msg)\n\n        if isinstance(self.Weather, AnyUrl) and self.Weather.path:\n            weather_path = Path(self.Weather.path).relative_to(\"/\")\n        elif isinstance(self.Weather, Path):\n            weather_path = self.Weather.relative_to(self.Weather.anchor)\n        else:\n            msg = f\"Invalid weather path: {self.Weather}\"\n            raise ValueError(msg)\n\n        weather_dir = cache_dir / weather_path.with_suffix(\"\")\n        epw_path = weather_dir / weather_path.with_suffix(\".epw\").name\n        ddy_path = weather_dir / weather_path.with_suffix(\".ddy\").name\n        weather_dir.mkdir(parents=True, exist_ok=True)\n        if not epw_path.exists() or not ddy_path.exists():\n            logger.info(f\"Fetching weather file from {self.Weather}\")\n            # fetch the .zip file, unzip it, and extract the .epw and .ddy files\n            if isinstance(self.Weather, AnyUrl) and self.Weather.scheme in [\n                \"https\",\n                \"http\",\n            ]:\n                client = httpx.Client()\n                response = client.get(str(self.Weather))\n                with tempfile.TemporaryFile() as f:\n                    f.write(response.content)\n                    f.seek(0)\n                    with zipfile.ZipFile(f, \"r\") as z:\n                        if epw_path.name not in z.namelist():\n                            msg = f\"The .epw file {epw_path.name} was not found in the zip file.\"\n                            raise FileNotFoundError(msg)\n                        if ddy_path.name not in z.namelist():\n                            msg = f\"The .ddy file {ddy_path.name} was not found in the zip file.\"\n                            raise FileNotFoundError(msg)\n                        z.extract(epw_path.name, weather_dir)\n                        z.extract(ddy_path.name, weather_dir)\n                client.close()\n            elif isinstance(self.Weather, Path):\n                with zipfile.ZipFile(self.Weather, \"r\") as z:\n                    if epw_path.name not in z.namelist():\n                        msg = f\"The .epw file {epw_path.name} was not found in the zip file.\"\n                        raise FileNotFoundError(msg)\n                    if ddy_path.name not in z.namelist():\n                        msg = f\"The .ddy file {ddy_path.name} was not found in the zip file.\"\n                        raise FileNotFoundError(msg)\n                    z.extract(epw_path.name, weather_dir)\n                    z.extract(ddy_path.name, weather_dir)\n            else:\n                msg = f\"Unsupported scheme: {self.Weather}\"\n                raise ValueError(msg)\n\n        else:\n            logger.info(f\"Using cached weather file from {weather_dir}\")\n        return epw_path, ddy_path\n</code></pre>"},{"location":"modules/weather/#epinterface.weather.BaseWeather.fetch_weather","title":"<code>fetch_weather(cache_dir)</code>","text":"<p>Fetch the weather file from the URL and extract the .epw and .ddy files.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>Path | str</code> <p>The directory to cache the weather files.</p> required <p>Returns:</p> Name Type Description <code>epw_path</code> <code>Path</code> <p>The path to the .epw file.</p> <code>ddy_path</code> <code>Path</code> <p>The path to the .ddy file.</p> Source code in <code>epinterface/weather.py</code> <pre><code>def fetch_weather(self, cache_dir: Path | str):  # noqa: C901\n    \"\"\"Fetch the weather file from the URL and extract the .epw and .ddy files.\n\n    Args:\n        cache_dir (Path | str): The directory to cache the weather files.\n\n    Returns:\n        epw_path (Path): The path to the .epw file.\n        ddy_path (Path): The path to the .ddy file.\n    \"\"\"\n    if isinstance(cache_dir, str):\n        cache_dir = Path(cache_dir)\n\n    if isinstance(self.Weather, AnyUrl) and (\n        not self.Weather.path or not self.Weather.path.endswith(\".zip\")\n    ):\n        raise NotAZipError()\n    if isinstance(self.Weather, Path) and not self.Weather.suffix == \".zip\":\n        raise NotAZipError()\n    if isinstance(self.Weather, Path) and not self.Weather.anchor:\n        msg = f\"Invalid weather path: {self.Weather}\"\n        raise ValueError(msg)\n    if isinstance(self.Weather, Path) and not self.Weather.exists():\n        msg = f\"File {self.Weather} does not exist.\"\n        raise FileNotFoundError(msg)\n\n    if isinstance(self.Weather, AnyUrl) and self.Weather.path:\n        weather_path = Path(self.Weather.path).relative_to(\"/\")\n    elif isinstance(self.Weather, Path):\n        weather_path = self.Weather.relative_to(self.Weather.anchor)\n    else:\n        msg = f\"Invalid weather path: {self.Weather}\"\n        raise ValueError(msg)\n\n    weather_dir = cache_dir / weather_path.with_suffix(\"\")\n    epw_path = weather_dir / weather_path.with_suffix(\".epw\").name\n    ddy_path = weather_dir / weather_path.with_suffix(\".ddy\").name\n    weather_dir.mkdir(parents=True, exist_ok=True)\n    if not epw_path.exists() or not ddy_path.exists():\n        logger.info(f\"Fetching weather file from {self.Weather}\")\n        # fetch the .zip file, unzip it, and extract the .epw and .ddy files\n        if isinstance(self.Weather, AnyUrl) and self.Weather.scheme in [\n            \"https\",\n            \"http\",\n        ]:\n            client = httpx.Client()\n            response = client.get(str(self.Weather))\n            with tempfile.TemporaryFile() as f:\n                f.write(response.content)\n                f.seek(0)\n                with zipfile.ZipFile(f, \"r\") as z:\n                    if epw_path.name not in z.namelist():\n                        msg = f\"The .epw file {epw_path.name} was not found in the zip file.\"\n                        raise FileNotFoundError(msg)\n                    if ddy_path.name not in z.namelist():\n                        msg = f\"The .ddy file {ddy_path.name} was not found in the zip file.\"\n                        raise FileNotFoundError(msg)\n                    z.extract(epw_path.name, weather_dir)\n                    z.extract(ddy_path.name, weather_dir)\n            client.close()\n        elif isinstance(self.Weather, Path):\n            with zipfile.ZipFile(self.Weather, \"r\") as z:\n                if epw_path.name not in z.namelist():\n                    msg = f\"The .epw file {epw_path.name} was not found in the zip file.\"\n                    raise FileNotFoundError(msg)\n                if ddy_path.name not in z.namelist():\n                    msg = f\"The .ddy file {ddy_path.name} was not found in the zip file.\"\n                    raise FileNotFoundError(msg)\n                z.extract(epw_path.name, weather_dir)\n                z.extract(ddy_path.name, weather_dir)\n        else:\n            msg = f\"Unsupported scheme: {self.Weather}\"\n            raise ValueError(msg)\n\n    else:\n        logger.info(f\"Using cached weather file from {weather_dir}\")\n    return epw_path, ddy_path\n</code></pre>"},{"location":"modules/weather/#epinterface.weather.NotAZipError","title":"<code>NotAZipError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a URL does not end with a .zip extension.</p> Source code in <code>epinterface/weather.py</code> <pre><code>class NotAZipError(ValueError):\n    \"\"\"Raised when a URL does not end with a .zip extension.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the error.\"\"\"\n        super().__init__(\"The URL provided does not end with a .zip extension.\")\n</code></pre>"},{"location":"modules/weather/#epinterface.weather.NotAZipError.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the error.</p> Source code in <code>epinterface/weather.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the error.\"\"\"\n    super().__init__(\"The URL provided does not end with a .zip extension.\")\n</code></pre>"},{"location":"modules/weather/#epinterface.weather.check_path_ends_with_zip","title":"<code>check_path_ends_with_zip(url)</code>","text":"<p>Check that the path of the URL ends with a .zip extension.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>AnyUrl</code> <p>The URL to check.</p> required <p>Raises:</p> Type Description <code>NotAZipError</code> <p>If the URL does not end with a .zip extension.</p> <p>Returns:</p> Name Type Description <code>url</code> <code>AnyUrl</code> <p>The URL.</p> Source code in <code>epinterface/weather.py</code> <pre><code>def check_path_ends_with_zip(url: AnyUrl):\n    \"\"\"Check that the path of the URL ends with a .zip extension.\n\n    Args:\n        url (AnyUrl): The URL to check.\n\n    Raises:\n        NotAZipError: If the URL does not end with a .zip extension.\n\n    Returns:\n        url (AnyUrl): The URL.\n    \"\"\"\n    if not url.path:\n        raise NotAZipError()\n    if not url.path.endswith(\".zip\"):\n        raise NotAZipError()\n    return url\n</code></pre>"},{"location":"modules/sbem/","title":"Index","text":"<p>Module for SBEM component library format.</p>"},{"location":"modules/sbem/components/","title":"Components","text":"<p>Components for the SBEM model.</p>"},{"location":"modules/sbem/components/#space-use","title":"Space Use","text":"<p>Space use components for the SBEM library..</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.space_use.EquipmentComponent","title":"<code>EquipmentComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>An equipment object in the SBEM library.</p> Source code in <code>epinterface/sbem/components/space_use.py</code> <pre><code>class EquipmentComponent(NamedObject, MetadataMixin, extra=\"forbid\"):\n    \"\"\"An equipment object in the SBEM library.\"\"\"\n\n    PowerDensity: float = Field(..., title=\"Equipment density of the object [W/m2]\")\n    Schedule: YearComponent = Field(\n        ..., title=\"Equipment schedule of the object [frac]\"\n    )\n    IsOn: BoolStr = Field(..., title=\"Equipment is on\")\n\n    def add_equipment_to_idf_zone(\n        self, idf: IDF, target_zone_or_zone_list_name: str\n    ) -&gt; IDF:\n        \"\"\"Add equipment to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the equipment to.\n            target_zone_or_zone_list_name (str): The name of the zone or zone list to add the equipment to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if not self.IsOn:\n            return idf\n\n        name_prefix = f\"{target_zone_or_zone_list_name}_{self.safe_name}_EQUIPMENT\"\n        idf, year_name = self.Schedule.add_year_to_idf(\n            idf,\n            name_prefix=None,\n            summer_design_day_sch_name=\"d_AllOn_00\",\n            winter_design_day_sch_name=\"d_AllOn_00\",\n        )\n        equipment = ElectricEquipment(\n            Name=name_prefix,\n            Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n            Schedule_Name=year_name,\n            Design_Level_Calculation_Method=\"Watts/Area\",\n            Watts_per_Zone_Floor_Area=self.PowerDensity,\n            Watts_per_Person=None,\n            Fraction_Latent=assumed_constants.FractionLatentEquipment,\n            Fraction_Radiant=assumed_constants.FractionRadiantEquipment,\n            Fraction_Lost=assumed_constants.FractionLostEquipment,\n            EndUse_Subcategory=None,\n        )\n        idf = equipment.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.space_use.EquipmentComponent.add_equipment_to_idf_zone","title":"<code>add_equipment_to_idf_zone(idf, target_zone_or_zone_list_name)</code>","text":"<p>Add equipment to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the equipment to.</p> required <code>target_zone_or_zone_list_name</code> <code>str</code> <p>The name of the zone or zone list to add the equipment to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/sbem/components/space_use.py</code> <pre><code>def add_equipment_to_idf_zone(\n    self, idf: IDF, target_zone_or_zone_list_name: str\n) -&gt; IDF:\n    \"\"\"Add equipment to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the equipment to.\n        target_zone_or_zone_list_name (str): The name of the zone or zone list to add the equipment to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if not self.IsOn:\n        return idf\n\n    name_prefix = f\"{target_zone_or_zone_list_name}_{self.safe_name}_EQUIPMENT\"\n    idf, year_name = self.Schedule.add_year_to_idf(\n        idf,\n        name_prefix=None,\n        summer_design_day_sch_name=\"d_AllOn_00\",\n        winter_design_day_sch_name=\"d_AllOn_00\",\n    )\n    equipment = ElectricEquipment(\n        Name=name_prefix,\n        Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n        Schedule_Name=year_name,\n        Design_Level_Calculation_Method=\"Watts/Area\",\n        Watts_per_Zone_Floor_Area=self.PowerDensity,\n        Watts_per_Person=None,\n        Fraction_Latent=assumed_constants.FractionLatentEquipment,\n        Fraction_Radiant=assumed_constants.FractionRadiantEquipment,\n        Fraction_Lost=assumed_constants.FractionLostEquipment,\n        EndUse_Subcategory=None,\n    )\n    idf = equipment.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.space_use.LightingComponent","title":"<code>LightingComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>A lighting object in the SBEM library.</p> Source code in <code>epinterface/sbem/components/space_use.py</code> <pre><code>class LightingComponent(NamedObject, MetadataMixin, extra=\"forbid\"):\n    \"\"\"A lighting object in the SBEM library.\"\"\"\n\n    PowerDensity: float = Field(\n        ...,\n        title=\"Lighting density of the object [W/m2]\",\n        ge=0,\n    )\n\n    DimmingType: DimmingTypeType = Field(\n        ...,\n        title=\"Dimming type\",\n    )\n    Schedule: YearComponent = Field(..., title=\"Lighting schedule of the object [frac]\")\n    IsOn: BoolStr = Field(..., title=\"Lights are on\")\n\n    def add_lights_to_idf_zone(\n        self, idf: IDF, target_zone_or_zone_list_name: str\n    ) -&gt; IDF:\n        \"\"\"Add lights to an IDF zone.\n\n        Note that this makes some assumptions about the fraction visible/radiant/replaceable.\n\n        Args:\n            idf (IDF): The IDF object to add the lights to.\n            target_zone_or_zone_list_name (str): The name of the zone or zone list to add the lights to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if not self.IsOn:\n            return idf\n\n        if self.DimmingType != \"Off\":\n            raise NotImplementedParameter(\"DimmingType:On\", self.Name, \"Lights\")\n\n        name_prefix = f\"{target_zone_or_zone_list_name}_{self.safe_name}_LIGHTS\"\n        idf, year_name = self.Schedule.add_year_to_idf(\n            idf,\n            name_prefix=None,\n            summer_design_day_sch_name=\"d_AllOn_00\",\n            winter_design_day_sch_name=\"d_AllOn_00\",\n        )\n        lights = Lights(\n            Name=name_prefix,\n            Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n            Schedule_Name=year_name,\n            Design_Level_Calculation_Method=\"Watts/Area\",\n            Watts_per_Zone_Floor_Area=self.PowerDensity,\n            Watts_per_Person=None,\n            Lighting_Level=None,\n            Return_Air_Fraction=assumed_constants.ReturnAirFractionLights,\n            Fraction_Radiant=assumed_constants.FractionRadiantLights,\n            Fraction_Visible=assumed_constants.FractionVisibleLights,\n            Fraction_Replaceable=assumed_constants.FractionReplaceableLights,\n            EndUse_Subcategory=None,\n        )\n        idf = lights.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.space_use.LightingComponent.add_lights_to_idf_zone","title":"<code>add_lights_to_idf_zone(idf, target_zone_or_zone_list_name)</code>","text":"<p>Add lights to an IDF zone.</p> <p>Note that this makes some assumptions about the fraction visible/radiant/replaceable.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the lights to.</p> required <code>target_zone_or_zone_list_name</code> <code>str</code> <p>The name of the zone or zone list to add the lights to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/sbem/components/space_use.py</code> <pre><code>def add_lights_to_idf_zone(\n    self, idf: IDF, target_zone_or_zone_list_name: str\n) -&gt; IDF:\n    \"\"\"Add lights to an IDF zone.\n\n    Note that this makes some assumptions about the fraction visible/radiant/replaceable.\n\n    Args:\n        idf (IDF): The IDF object to add the lights to.\n        target_zone_or_zone_list_name (str): The name of the zone or zone list to add the lights to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if not self.IsOn:\n        return idf\n\n    if self.DimmingType != \"Off\":\n        raise NotImplementedParameter(\"DimmingType:On\", self.Name, \"Lights\")\n\n    name_prefix = f\"{target_zone_or_zone_list_name}_{self.safe_name}_LIGHTS\"\n    idf, year_name = self.Schedule.add_year_to_idf(\n        idf,\n        name_prefix=None,\n        summer_design_day_sch_name=\"d_AllOn_00\",\n        winter_design_day_sch_name=\"d_AllOn_00\",\n    )\n    lights = Lights(\n        Name=name_prefix,\n        Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n        Schedule_Name=year_name,\n        Design_Level_Calculation_Method=\"Watts/Area\",\n        Watts_per_Zone_Floor_Area=self.PowerDensity,\n        Watts_per_Person=None,\n        Lighting_Level=None,\n        Return_Air_Fraction=assumed_constants.ReturnAirFractionLights,\n        Fraction_Radiant=assumed_constants.FractionRadiantLights,\n        Fraction_Visible=assumed_constants.FractionVisibleLights,\n        Fraction_Replaceable=assumed_constants.FractionReplaceableLights,\n        EndUse_Subcategory=None,\n    )\n    idf = lights.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.space_use.OccupancyComponent","title":"<code>OccupancyComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>An occupancy object in the SBEM library.</p> Source code in <code>epinterface/sbem/components/space_use.py</code> <pre><code>class OccupancyComponent(NamedObject, MetadataMixin, extra=\"forbid\"):\n    \"\"\"An occupancy object in the SBEM library.\"\"\"\n\n    PeopleDensity: float = Field(\n        ...,\n        title=\"Occupancy density of the object [ppl/m2]\",\n        ge=0,\n    )\n    Schedule: YearComponent = Field(\n        ..., title=\"Occupancy schedule of the object [frac]\"\n    )\n    IsOn: BoolStr = Field(..., title=\"People are on\")\n    MetabolicRate: float = assumed_constants.MetabolicRate_met\n\n    @property\n    def MetabolicRate_met_to_W(self):\n        \"\"\"Get the metabolic rate in Watts.\"\"\"\n        avg_human_weight_kg = assumed_constants.AvgHumanWeight_kg\n        conversion_factor = physical_constants.ConversionFactor_W_per_kg\n        # mets * kg * W/kg = W\n        return self.MetabolicRate * avg_human_weight_kg * conversion_factor\n\n    def add_people_to_idf_zone(\n        self, idf: IDF, target_zone_or_zone_list_name: str\n    ) -&gt; IDF:\n        \"\"\"Add people to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the people to.\n            target_zone_or_zone_list_name (str): The name of the zone or zone list to add the people to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        if not self.IsOn:\n            return idf\n\n        activity_sch_name = (\n            f\"{target_zone_or_zone_list_name}_{self.safe_name}_PEOPLE_Activity_Schedule\"\n        )\n        lim = ScheduleTypeLimits(\n            Name=\"AnyNumber\",\n            LowerLimit=None,\n            UpperLimit=None,\n        )\n        if not idf.getobject(\"SCHEDULETYPELIMITS\", lim.Name):\n            lim.to_epbunch(idf)\n        activity_sch = Schedule.from_values(\n            Values=[self.MetabolicRate_met_to_W] * 8760,\n            Name=activity_sch_name,\n            Type=lim,  # pyright: ignore [reportArgumentType]\n        )\n        activity_sch_year, *_ = activity_sch.to_year_week_day()\n        activity_sch_year.to_epbunch(idf)\n\n        name_prefix = f\"{target_zone_or_zone_list_name}_{self.safe_name}_PEOPLE\"\n        idf, year_name = self.Schedule.add_year_to_idf(\n            idf,\n            name_prefix=None,\n            summer_design_day_sch_name=\"d_AllOn_00\",\n            winter_design_day_sch_name=\"d_AllOn_00\",\n        )\n        people = People(\n            Name=name_prefix,\n            Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n            Number_of_People_Schedule_Name=year_name,\n            Number_of_People_Calculation_Method=\"People/Area\",\n            Number_of_People=None,\n            Floor_Area_per_Person=None,\n            People_per_Floor_Area=self.PeopleDensity,\n            Fraction_Radiant=assumed_constants.FractionRadiantPeople,\n            Sensible_Heat_Fraction=\"autocalculate\",\n            Activity_Level_Schedule_Name=activity_sch_year.Name,\n        )\n\n        idf = people.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.space_use.OccupancyComponent.MetabolicRate_met_to_W","title":"<code>MetabolicRate_met_to_W</code>  <code>property</code>","text":"<p>Get the metabolic rate in Watts.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.space_use.OccupancyComponent.add_people_to_idf_zone","title":"<code>add_people_to_idf_zone(idf, target_zone_or_zone_list_name)</code>","text":"<p>Add people to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the people to.</p> required <code>target_zone_or_zone_list_name</code> <code>str</code> <p>The name of the zone or zone list to add the people to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/sbem/components/space_use.py</code> <pre><code>def add_people_to_idf_zone(\n    self, idf: IDF, target_zone_or_zone_list_name: str\n) -&gt; IDF:\n    \"\"\"Add people to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the people to.\n        target_zone_or_zone_list_name (str): The name of the zone or zone list to add the people to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    if not self.IsOn:\n        return idf\n\n    activity_sch_name = (\n        f\"{target_zone_or_zone_list_name}_{self.safe_name}_PEOPLE_Activity_Schedule\"\n    )\n    lim = ScheduleTypeLimits(\n        Name=\"AnyNumber\",\n        LowerLimit=None,\n        UpperLimit=None,\n    )\n    if not idf.getobject(\"SCHEDULETYPELIMITS\", lim.Name):\n        lim.to_epbunch(idf)\n    activity_sch = Schedule.from_values(\n        Values=[self.MetabolicRate_met_to_W] * 8760,\n        Name=activity_sch_name,\n        Type=lim,  # pyright: ignore [reportArgumentType]\n    )\n    activity_sch_year, *_ = activity_sch.to_year_week_day()\n    activity_sch_year.to_epbunch(idf)\n\n    name_prefix = f\"{target_zone_or_zone_list_name}_{self.safe_name}_PEOPLE\"\n    idf, year_name = self.Schedule.add_year_to_idf(\n        idf,\n        name_prefix=None,\n        summer_design_day_sch_name=\"d_AllOn_00\",\n        winter_design_day_sch_name=\"d_AllOn_00\",\n    )\n    people = People(\n        Name=name_prefix,\n        Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n        Number_of_People_Schedule_Name=year_name,\n        Number_of_People_Calculation_Method=\"People/Area\",\n        Number_of_People=None,\n        Floor_Area_per_Person=None,\n        People_per_Floor_Area=self.PeopleDensity,\n        Fraction_Radiant=assumed_constants.FractionRadiantPeople,\n        Sensible_Heat_Fraction=\"autocalculate\",\n        Activity_Level_Schedule_Name=activity_sch_year.Name,\n    )\n\n    idf = people.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.space_use.ThermostatComponent","title":"<code>ThermostatComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>A thermostat object in the SBEM library.</p> Source code in <code>epinterface/sbem/components/space_use.py</code> <pre><code>class ThermostatComponent(NamedObject, MetadataMixin, extra=\"forbid\"):\n    \"\"\"A thermostat object in the SBEM library.\"\"\"\n\n    IsOn: BoolStr = Field(..., title=\"Thermostat is on\")\n    HeatingSetpoint: float = Field(\n        ...,\n        title=\"Heating setpoint of the object; ignored if schedule is present, except also used for determining natural ventilation boundaries.\",\n    )\n    HeatingSchedule: YearComponent = Field(..., title=\"Heating schedule of the object\")\n    CoolingSetpoint: float = Field(\n        ...,\n        title=\"Cooling setpoint of the object; ignored if schedule is present, except also used for determining natural ventilation boundaries.\",\n    )\n    CoolingSchedule: YearComponent = Field(..., title=\"Cooling schedule of the object\")\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.space_use.WaterUseComponent","title":"<code>WaterUseComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>A water use object in the SBEM library.</p> Source code in <code>epinterface/sbem/components/space_use.py</code> <pre><code>class WaterUseComponent(NamedObject, MetadataMixin, extra=\"forbid\"):\n    \"\"\"A water use object in the SBEM library.\"\"\"\n\n    FlowRatePerPerson: float = Field(\n        ...,\n        title=\"Flow rate per person [m3/day/p]\",\n        ge=0,\n        le=10,\n        description=\"This is the AVERAGE total amount of water per person per day; \"\n        \"the peak flow rate will be computed dynamically based on the schedule.\",\n    )\n    Schedule: YearComponent = Field(..., title=\"Water schedule\")\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.space_use.ZoneSpaceUseComponent","title":"<code>ZoneSpaceUseComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>Space use object.</p> Source code in <code>epinterface/sbem/components/space_use.py</code> <pre><code>class ZoneSpaceUseComponent(NamedObject, MetadataMixin, extra=\"forbid\"):\n    \"\"\"Space use object.\"\"\"\n\n    Occupancy: OccupancyComponent\n    Lighting: LightingComponent\n    Equipment: EquipmentComponent\n    Thermostat: ThermostatComponent\n    WaterUse: WaterUseComponent\n\n    # TODO: Is this really necessary, or should it be lifted up to the ZoneComponent?\n    # it currently is acting as a very bare bones passthrough.\n    def add_loads_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n        \"\"\"Add the loads to an IDF zone.\n\n        This will add the people, equipment, and lights to the zone.\n\n        Args:\n            idf (IDF): The IDF object to add the loads to.\n            target_zone_name (str): The name of the zone to add the loads to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        idf = self.Lighting.add_lights_to_idf_zone(idf, target_zone_name)\n        idf = self.Occupancy.add_people_to_idf_zone(idf, target_zone_name)\n        idf = self.Equipment.add_equipment_to_idf_zone(idf, target_zone_name)\n        # idf = self.Thermostat.add_thermostat_to_idf_zone(idf, target_zone_name)\n        # raise NotImplementedError\n        return idf\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.space_use.ZoneSpaceUseComponent.add_loads_to_idf_zone","title":"<code>add_loads_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Add the loads to an IDF zone.</p> <p>This will add the people, equipment, and lights to the zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the loads to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the loads to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/sbem/components/space_use.py</code> <pre><code>def add_loads_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n    \"\"\"Add the loads to an IDF zone.\n\n    This will add the people, equipment, and lights to the zone.\n\n    Args:\n        idf (IDF): The IDF object to add the loads to.\n        target_zone_name (str): The name of the zone to add the loads to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    idf = self.Lighting.add_lights_to_idf_zone(idf, target_zone_name)\n    idf = self.Occupancy.add_people_to_idf_zone(idf, target_zone_name)\n    idf = self.Equipment.add_equipment_to_idf_zone(idf, target_zone_name)\n    # idf = self.Thermostat.add_thermostat_to_idf_zone(idf, target_zone_name)\n    # raise NotImplementedError\n    return idf\n</code></pre>"},{"location":"modules/sbem/components/#systems","title":"Systems","text":"<p>Systems components for the SBEM library.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.systems.ConditioningSystemsComponent","title":"<code>ConditioningSystemsComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>A conditioning system object in the SBEM library.</p> Source code in <code>epinterface/sbem/components/systems.py</code> <pre><code>class ConditioningSystemsComponent(NamedObject, MetadataMixin, extra=\"forbid\"):\n    \"\"\"A conditioning system object in the SBEM library.\"\"\"\n\n    Heating: ThermalSystemComponent | None\n    Cooling: ThermalSystemComponent | None\n\n    @model_validator(mode=\"after\")\n    def validate_conditioning_types(self):\n        \"\"\"Validate that the conditioning types are correct.\n\n        Cannot have a heating system assigned to a cooling system and vice versa.\n        \"\"\"\n        if self.Heating and \"heating\" not in self.Heating.ConditioningType.lower():\n            msg = \"Heating system type is only applicable to heating systems.\"\n            raise ValueError(msg)\n        if self.Cooling and \"cooling\" not in self.Cooling.ConditioningType.lower():\n            msg = \"Cooling system type is only applicable to cooling systems.\"\n            raise ValueError(msg)\n\n        return self\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.systems.ConditioningSystemsComponent.validate_conditioning_types","title":"<code>validate_conditioning_types()</code>","text":"<p>Validate that the conditioning types are correct.</p> <p>Cannot have a heating system assigned to a cooling system and vice versa.</p> Source code in <code>epinterface/sbem/components/systems.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_conditioning_types(self):\n    \"\"\"Validate that the conditioning types are correct.\n\n    Cannot have a heating system assigned to a cooling system and vice versa.\n    \"\"\"\n    if self.Heating and \"heating\" not in self.Heating.ConditioningType.lower():\n        msg = \"Heating system type is only applicable to heating systems.\"\n        raise ValueError(msg)\n    if self.Cooling and \"cooling\" not in self.Cooling.ConditioningType.lower():\n        msg = \"Cooling system type is only applicable to cooling systems.\"\n        raise ValueError(msg)\n\n    return self\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.systems.DHWComponent","title":"<code>DHWComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>Domestic Hot Water object.</p> Source code in <code>epinterface/sbem/components/systems.py</code> <pre><code>class DHWComponent(\n    NamedObject,\n    MetadataMixin,\n    extra=\"forbid\",\n):\n    \"\"\"Domestic Hot Water object.\"\"\"\n\n    SystemCOP: float = Field(\n        ...,\n        title=\"Domestic hot water coefficient of performance\",\n        ge=0,\n    )\n    WaterTemperatureInlet: float = Field(\n        ...,\n        title=\"Water temperature inlet [\u00b0C]\",\n        ge=0,\n        le=100,\n    )  # TODO:remove this or just set as constant. Leaving for flexibility here\n\n    DistributionCOP: float = Field(\n        ...,\n        title=\"Distribution coefficient of performance\",\n        ge=0,\n        le=1,\n    )\n\n    WaterSupplyTemperature: float = Field(\n        ...,\n        title=\"Water supply temperature [\u00b0C]\",\n        ge=0,\n        le=100,\n    )\n    IsOn: BoolStr = Field(..., title=\"Is on\")\n    FuelType: DHWFuelType = Field(..., title=\"Hot water fuel type\")\n\n    @model_validator(mode=\"after\")\n    def validate_supply_greater_than_inlet(self):\n        \"\"\"Validate that the supply temperature is greater than the inlet temperature.\"\"\"\n        if self.WaterSupplyTemperature &lt;= self.WaterTemperatureInlet:\n            msg = \"Water supply temperature must be greater than the inlet temperature.\"\n            raise ValueError(msg)\n        return self\n\n    @property\n    def effective_system_cop(self) -&gt; float:\n        \"\"\"Compute the effective system COP based on the system and distribution COPs.\n\n        Returns:\n            cop (float): The effective system COP.\n        \"\"\"\n        return self.SystemCOP * self.DistributionCOP\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.systems.DHWComponent.effective_system_cop","title":"<code>effective_system_cop</code>  <code>property</code>","text":"<p>Compute the effective system COP based on the system and distribution COPs.</p> <p>Returns:</p> Name Type Description <code>cop</code> <code>float</code> <p>The effective system COP.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.systems.DHWComponent.validate_supply_greater_than_inlet","title":"<code>validate_supply_greater_than_inlet()</code>","text":"<p>Validate that the supply temperature is greater than the inlet temperature.</p> Source code in <code>epinterface/sbem/components/systems.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_supply_greater_than_inlet(self):\n    \"\"\"Validate that the supply temperature is greater than the inlet temperature.\"\"\"\n    if self.WaterSupplyTemperature &lt;= self.WaterTemperatureInlet:\n        msg = \"Water supply temperature must be greater than the inlet temperature.\"\n        raise ValueError(msg)\n    return self\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.systems.ThermalSystemComponent","title":"<code>ThermalSystemComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>A thermal system object in the SBEM library.</p> Source code in <code>epinterface/sbem/components/systems.py</code> <pre><code>class ThermalSystemComponent(NamedObject, MetadataMixin, extra=\"forbid\"):\n    \"\"\"A thermal system object in the SBEM library.\"\"\"\n\n    ConditioningType: Literal[\"Heating\", \"Cooling\", \"HeatingAndCooling\"]\n    Fuel: FuelType\n    SystemCOP: float = Field(\n        ...,\n        title=\"System COP\",\n        ge=0,\n    )\n    DistributionCOP: float = Field(..., title=\"Distribution COP\", ge=0)\n\n    @property\n    def effective_system_cop(self) -&gt; float:\n        \"\"\"Compute the effective system COP based on the system and distribution COPs.\n\n        Returns:\n            cop (float): The effective system COP.\n        \"\"\"\n        return self.SystemCOP * self.DistributionCOP\n\n    @property\n    def HeatingSystemType(self) -&gt; HeatingSystemType:\n        \"\"\"Compute the heating system type based on the system COP.\n\n        Returns:\n            heating_system_type (HeatingSystemType): The heating system type.\n        \"\"\"\n        if (\n            self.ConditioningType != \"Heating\"\n            and self.ConditioningType != \"HeatingAndCooling\"\n        ):\n            msg = \"Heating system type is only applicable to heating systems.\"\n            raise ValueError(msg)\n        # TODO: compute based off of CoP\n        msg = \"Heating system type is not implemented.\"\n        raise NotImplementedError(msg)\n        return \"ElectricResistance\"\n\n    @property\n    def CoolingSystemType(self) -&gt; CoolingSystemType:\n        \"\"\"Compute the cooling system type based on the system COP.\n\n        Returns:\n            cooling_system_type (CoolingSystemType): The cooling system type.\n        \"\"\"\n        if (\n            self.ConditioningType != \"Cooling\"\n            and self.ConditioningType != \"HeatingAndCooling\"\n        ):\n            msg = \"Cooling system type is only applicable to cooling systems.\"\n            raise ValueError(msg)\n        # TODO: compute based off of CoP\n        msg = \"Cooling system type is not implemented.\"\n        raise NotImplementedError(msg)\n        return \"DX\"\n\n    @property\n    def DistributionType(self) -&gt; DistributionType:\n        \"\"\"Compute the distribution type based on the system COP.\n\n        Returns:\n            distribution_type (DistributionType): The distribution type.\n        \"\"\"\n        # TODO: compute based off of CoP\n        msg = \"Distribution type is not implemented.\"\n        raise NotImplementedError(msg)\n        return \"Hydronic\"\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.systems.ThermalSystemComponent.CoolingSystemType","title":"<code>CoolingSystemType</code>  <code>property</code>","text":"<p>Compute the cooling system type based on the system COP.</p> <p>Returns:</p> Name Type Description <code>cooling_system_type</code> <code>CoolingSystemType</code> <p>The cooling system type.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.systems.ThermalSystemComponent.DistributionType","title":"<code>DistributionType</code>  <code>property</code>","text":"<p>Compute the distribution type based on the system COP.</p> <p>Returns:</p> Name Type Description <code>distribution_type</code> <code>DistributionType</code> <p>The distribution type.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.systems.ThermalSystemComponent.HeatingSystemType","title":"<code>HeatingSystemType</code>  <code>property</code>","text":"<p>Compute the heating system type based on the system COP.</p> <p>Returns:</p> Name Type Description <code>heating_system_type</code> <code>HeatingSystemType</code> <p>The heating system type.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.systems.ThermalSystemComponent.effective_system_cop","title":"<code>effective_system_cop</code>  <code>property</code>","text":"<p>Compute the effective system COP based on the system and distribution COPs.</p> <p>Returns:</p> Name Type Description <code>cop</code> <code>float</code> <p>The effective system COP.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.systems.VentilationComponent","title":"<code>VentilationComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>A ventilation object in the SBEM library.</p> Source code in <code>epinterface/sbem/components/systems.py</code> <pre><code>class VentilationComponent(NamedObject, MetadataMixin, extra=\"forbid\"):\n    \"\"\"A ventilation object in the SBEM library.\"\"\"\n\n    # TODO: add unit notes in field descriptions\n    FreshAirPerFloorArea: float = Field(\n        ...,\n        title=\"Fresh air per m2 of the object [m\u00b3/s/m\u00b2]\",\n        ge=0,\n        le=0.05,\n    )\n    FreshAirPerPerson: float = Field(\n        ...,\n        title=\"Fresh air per person of the object [m\u00b3/s/p]\",\n        ge=0,\n        le=0.05,\n    )\n    Schedule: YearComponent = Field(..., title=\"Ventilation schedule of the object\")\n    Provider: VentilationProvider = Field(..., title=\"Type of the object\")\n    HRV: HRVMethod = Field(..., title=\"HRV type of the object\")\n    Economizer: EconomizerMethod = Field(..., title=\"Economizer type of the object\")\n    DCV: DCVMethod = Field(..., title=\"DCV type of the object\")\n\n    @model_validator(mode=\"after\")\n    def validate_ventilation_systems(self):\n        \"\"\"Validate that the ventilation systems are correct.\n\n        If the ventilation type is natural, then the zone cannot have variants of mechanical ventilation systems (e.g, HRV, DCV, Economizer).\n        \"\"\"\n        if self.Provider == \"Natural\":\n            if self.HRV != \"NoHRV\":\n                msg = \"Natural ventilation systems can't have HRV.\"\n                raise ValueError(msg)\n            if self.DCV != \"NoDCV\":\n                msg = \"Natural ventilation systems can't have DCV.\"\n                raise ValueError(msg)\n            if self.Economizer != \"NoEconomizer\":\n                msg = \"Natural ventilation systems can't have an Economizer.\"\n                raise ValueError(msg)\n        if self.Provider == \"None\":\n            if self.HRV != \"NoHRV\":\n                msg = \"None ventilation systems can't have HRV.\"\n                raise ValueError(msg)\n            if self.DCV != \"NoDCV\":\n                msg = \"None ventilation systems can't have DCV.\"\n                raise ValueError(msg)\n            if self.Economizer != \"NoEconomizer\":\n                msg = \"None ventilation systems can't have an Economizer.\"\n                raise ValueError(msg)\n        return self\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.systems.VentilationComponent.validate_ventilation_systems","title":"<code>validate_ventilation_systems()</code>","text":"<p>Validate that the ventilation systems are correct.</p> <p>If the ventilation type is natural, then the zone cannot have variants of mechanical ventilation systems (e.g, HRV, DCV, Economizer).</p> Source code in <code>epinterface/sbem/components/systems.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_ventilation_systems(self):\n    \"\"\"Validate that the ventilation systems are correct.\n\n    If the ventilation type is natural, then the zone cannot have variants of mechanical ventilation systems (e.g, HRV, DCV, Economizer).\n    \"\"\"\n    if self.Provider == \"Natural\":\n        if self.HRV != \"NoHRV\":\n            msg = \"Natural ventilation systems can't have HRV.\"\n            raise ValueError(msg)\n        if self.DCV != \"NoDCV\":\n            msg = \"Natural ventilation systems can't have DCV.\"\n            raise ValueError(msg)\n        if self.Economizer != \"NoEconomizer\":\n            msg = \"Natural ventilation systems can't have an Economizer.\"\n            raise ValueError(msg)\n    if self.Provider == \"None\":\n        if self.HRV != \"NoHRV\":\n            msg = \"None ventilation systems can't have HRV.\"\n            raise ValueError(msg)\n        if self.DCV != \"NoDCV\":\n            msg = \"None ventilation systems can't have DCV.\"\n            raise ValueError(msg)\n        if self.Economizer != \"NoEconomizer\":\n            msg = \"None ventilation systems can't have an Economizer.\"\n            raise ValueError(msg)\n    return self\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.systems.ZoneHVACComponent","title":"<code>ZoneHVACComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>Conditioning object in the SBEM library.</p> Source code in <code>epinterface/sbem/components/systems.py</code> <pre><code>class ZoneHVACComponent(\n    NamedObject,\n    MetadataMixin,\n    extra=\"forbid\",\n):\n    \"\"\"Conditioning object in the SBEM library.\"\"\"\n\n    ConditioningSystems: ConditioningSystemsComponent\n    Ventilation: VentilationComponent\n    # TODO: change the structure like ZoneSpaceUse\n    \"\"\"Zone conditioning object.\"\"\"\n\n    def add_conditioning_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n        \"\"\"Add conditioning to an IDF zone.\n\n        This constructs HVAC template objects which get assigned to the zone.\n\n        NB: currently, many of the climate studio parameters are ignored -\n        particularly the ones related to humidity control.\n\n        Args:\n            idf (IDF): The IDF object to add the conditioning to.\n            target_zone_name (str): The name of the zone to add the conditioning to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        # TODO: add the idf conversion functions\n\n        return idf\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.systems.ZoneHVACComponent.Ventilation","title":"<code>Ventilation</code>  <code>instance-attribute</code>","text":"<p>Zone conditioning object.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.systems.ZoneHVACComponent.add_conditioning_to_idf_zone","title":"<code>add_conditioning_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Add conditioning to an IDF zone.</p> <p>This constructs HVAC template objects which get assigned to the zone.</p> <p>NB: currently, many of the climate studio parameters are ignored - particularly the ones related to humidity control.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the conditioning to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the conditioning to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/sbem/components/systems.py</code> <pre><code>def add_conditioning_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n    \"\"\"Add conditioning to an IDF zone.\n\n    This constructs HVAC template objects which get assigned to the zone.\n\n    NB: currently, many of the climate studio parameters are ignored -\n    particularly the ones related to humidity control.\n\n    Args:\n        idf (IDF): The IDF object to add the conditioning to.\n        target_zone_name (str): The name of the zone to add the conditioning to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    # TODO: add the idf conversion functions\n\n    return idf\n</code></pre>"},{"location":"modules/sbem/components/#operations","title":"Operations","text":"<p>Operations components for the SBEM library.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.operations.ZoneOperationsComponent","title":"<code>ZoneOperationsComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>Zone use consolidation across space use, HVAC, DHW.</p> Source code in <code>epinterface/sbem/components/operations.py</code> <pre><code>class ZoneOperationsComponent(\n    NamedObject,\n    MetadataMixin,\n    extra=\"forbid\",\n):\n    \"\"\"Zone use consolidation across space use, HVAC, DHW.\"\"\"\n\n    SpaceUse: ZoneSpaceUseComponent\n    HVAC: ZoneHVACComponent\n    DHW: DHWComponent\n\n    def add_water_use_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n        \"\"\"Handle adding water use to the zone based on both DHW and Operations.SpaceUse.WaterUse.\n\n        We choose to execute this from the zone component interface because it requires context from both\n        zone.Operations.SpaceUse.WaterUse and zone.Operations.\n\n        Note: the water use component's flow rate represents the total amount of water used per person per day;\n        in order to calculate a peak flow rate, we will need to ensure that the product of the schedule and the peak\n        flow rate would resolve to the same daily average value per person.\n\n        This will be responsible for:\n            1. Extracting the total area of the zone by finding the matching surfaces.\n            2. Computing the total number of people in the zone based on the occupancy density and the total area.\n            3. Computing the average flow rate of water use/s in the zone based on the flow rate per person/day and the total number of people.\n            4. Computing the peak flow rate of water use/s in the zone based on the average flow rate and the average fractional value of the schedule.\n            5. Adding the water use equipment to the zone.\n\n\n        # TODO: major problem - this assumes the zone has already been correctly sized!\n        # this method should only actually be called AFTER\n        # the building has been properly rescaled, which currently is executed at the very end.\n        # that hook should probably be moved up.\n\n        Args:\n            idf (IDF): The IDF object to add the operations to.\n            target_zone_name (str): The name of the zone to add the operations to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        # TODO: should IsOn definitely live in DHW? should dhw be nullable?\n        # should it live in spaceuse.wateruse for consistency?\n        if not self.DHW.IsOn:\n            return idf\n\n        # Acquire the relevant data fields\n        flow_rate_per_person_per_day = (\n            self.SpaceUse.WaterUse.FlowRatePerPerson\n        )  # m3/person/day\n        occupant_density = self.SpaceUse.Occupancy.PeopleDensity  # ppl/m2\n        water_supply_temperature = self.DHW.WaterSupplyTemperature  # degC\n        water_temperature_inlet = self.DHW.WaterTemperatureInlet  # degC\n        water_use_frac_sched = self.SpaceUse.WaterUse.Schedule\n        water_use_name = f\"{target_zone_name}_{self.SpaceUse.WaterUse.safe_name}_{self.DHW.safe_name}_WATER\"\n\n        # determine zone area to then compute total people\n        # we will do this by finding all matching surfaces and computing their areas.\n        zone = next(\n            (x for x in idf.idfobjects[\"ZONE\"] if x.Name == target_zone_name), None\n        )\n        if zone is None:\n            raise ValueError(f\"NO_ZONE:{target_zone_name}\")\n        area = get_zone_floor_area(idf, zone.Name)\n        total_ppl = occupant_density * area\n\n        # Compute final flow rates.\n        total_flow_per_day = flow_rate_per_person_per_day * total_ppl  # m3/day\n        avg_flow_per_s = total_flow_per_day / (3600 * 24)  # m3/s\n        # TODO: Update this rather than being constant rate\n\n        lim = \"Temperature\"\n        if not idf.getobject(\"SCHEDULETYPELIMITS\", lim):\n            lim = ScheduleTypeLimits(\n                Name=\"Temperature\",\n                LowerLimit=-60,\n                UpperLimit=200,\n            )\n            lim.to_epbunch(idf)\n\n        # TODO: should we be using time-varying temperatures?\n        target_temperature_schedule = Schedule.constant_schedule(\n            value=water_supply_temperature,  # pyright: ignore [reportArgumentType]\n            Name=f\"{water_use_name}_TargetWaterTemperatureSch\",\n            Type=\"Temperature\",\n        )\n        inlet_temperature_schedule = Schedule.constant_schedule(\n            value=water_temperature_inlet,  # pyright: ignore [reportArgumentType]\n            Name=f\"{water_use_name}_InletWaterTemperatureSch\",\n            Type=\"Temperature\",\n        )\n\n        target_temperature_yr_schedule, *_ = (\n            target_temperature_schedule.to_year_week_day()\n        )\n        inlet_temperature_yr_schedule, *_ = (\n            inlet_temperature_schedule.to_year_week_day()\n        )\n\n        target_temperature_yr_schedule.to_epbunch(idf)\n        inlet_temperature_yr_schedule.to_epbunch(idf)\n\n        if water_use_frac_sched.schedule_type_limits != \"Fraction\":\n            msg = f\"WATER_USE_FRACTION_SCHEDULE_TYPE_NOT_FRACTION:{water_use_name}\"\n            raise ValueError(msg)\n\n        idf, water_use_frac_sch_name = water_use_frac_sched.add_year_to_idf(\n            idf, name_prefix=None\n        )\n        # sch_obj = idf.getobject(\"SCHEDULE:YEAR\", water_use_frac_sch_name)\n        # arch_sch = Schedule.from_epbunch(sch_obj)\n        # values = np.array(arch_sch.Values)\n        # avg_fractional_value = np.sum(values) / 8760\n        logger.warning(\"USING HARDCODED 2018 to compute avg fractional value\")\n        avg_fractional_value = water_use_frac_sched.fractional_year_sum(2018)\n        # total_fractional_value * peak_flow_rate_per_s = avg_float_per_s\n        peak_flow_rate_per_s = avg_flow_per_s / avg_fractional_value\n\n        hot_water = WaterUseEquipment(\n            Name=water_use_name,\n            EndUse_Subcategory=\"Domestic Hot Water\",\n            Peak_Flow_Rate=peak_flow_rate_per_s,\n            Flow_Rate_Fraction_Schedule_Name=water_use_frac_sch_name,\n            Zone_Name=target_zone_name,\n            Target_Temperature_Schedule_Name=target_temperature_yr_schedule.Name,\n            Hot_Water_Supply_Temperature_Schedule_Name=target_temperature_schedule.Name,\n            Cold_Water_Supply_Temperature_Schedule_Name=inlet_temperature_schedule.Name,\n            Sensible_Fraction_Schedule_Name=None,\n            Latent_Fraction_Schedule_Name=None,\n        )\n        idf = hot_water.add(idf)\n        return idf\n\n    def add_thermostat_to_idf_zone(\n        self, idf: IDF, target_zone_name: str\n    ) -&gt; HVACTemplateThermostat:\n        \"\"\"Add a thermostat to the zone.\n\n        Args:\n            idf (IDF): The IDF object to add the thermostat to.\n            target_zone_name (str): The name of the zone to add the thermostat to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        thermostat_name = (\n            f\"{target_zone_name}_{self.SpaceUse.Thermostat.safe_name}_THERMOSTAT\"\n        )\n        heating_schedule = self.SpaceUse.Thermostat.HeatingSchedule\n        cooling_schedule = self.SpaceUse.Thermostat.CoolingSchedule\n\n        heating_schedule_name = None\n        cooling_schedule_name = None\n        if heating_schedule is not None:\n            _, heat_high = self.SpaceUse.Thermostat.HeatingSchedule.bounds\n            heating_design_day = ScheduleDayHourly(\n                Name=f\"{thermostat_name}_HeatingDesignDay\",\n                Schedule_Type_Limits_Name=\"Temperature\",\n                Hour_1=heat_high,\n                Hour_2=heat_high,\n                Hour_3=heat_high,\n                Hour_4=heat_high,\n                Hour_5=heat_high,\n                Hour_6=heat_high,\n                Hour_7=heat_high,\n                Hour_8=heat_high,\n                Hour_9=heat_high,\n                Hour_10=heat_high,\n                Hour_11=heat_high,\n                Hour_12=heat_high,\n                Hour_13=heat_high,\n                Hour_14=heat_high,\n                Hour_15=heat_high,\n                Hour_16=heat_high,\n                Hour_17=heat_high,\n                Hour_18=heat_high,\n                Hour_19=heat_high,\n                Hour_20=heat_high,\n                Hour_21=heat_high,\n                Hour_22=heat_high,\n                Hour_23=heat_high,\n                Hour_24=heat_high,\n            )\n            idf = heating_design_day.add(idf)\n            idf, heating_schedule_name = heating_schedule.add_year_to_idf(\n                idf,\n                name_prefix=None,\n                winter_design_day_sch_name=heating_design_day.Name,\n                summer_design_day_sch_name=heating_design_day.Name,\n            )\n        if cooling_schedule is not None:\n            cool_low, _ = self.SpaceUse.Thermostat.CoolingSchedule.bounds\n            cooling_design_day = ScheduleDayHourly(\n                Name=f\"{thermostat_name}_CoolingDesignDay\",\n                Schedule_Type_Limits_Name=\"Temperature\",\n                Hour_1=cool_low,\n                Hour_2=cool_low,\n                Hour_3=cool_low,\n                Hour_4=cool_low,\n                Hour_5=cool_low,\n                Hour_6=cool_low,\n                Hour_7=cool_low,\n                Hour_8=cool_low,\n                Hour_9=cool_low,\n                Hour_10=cool_low,\n                Hour_11=cool_low,\n                Hour_12=cool_low,\n                Hour_13=cool_low,\n                Hour_14=cool_low,\n                Hour_15=cool_low,\n                Hour_16=cool_low,\n                Hour_17=cool_low,\n                Hour_18=cool_low,\n                Hour_19=cool_low,\n                Hour_20=cool_low,\n                Hour_21=cool_low,\n                Hour_22=cool_low,\n                Hour_23=cool_low,\n                Hour_24=cool_low,\n            )\n\n            idf = cooling_design_day.add(idf)\n            idf, cooling_schedule_name = cooling_schedule.add_year_to_idf(\n                idf,\n                name_prefix=None,\n                winter_design_day_sch_name=cooling_design_day.Name,\n                summer_design_day_sch_name=cooling_design_day.Name,\n            )\n\n        thermostat = HVACTemplateThermostat(\n            Name=thermostat_name,\n            Heating_Setpoint_Schedule_Name=heating_schedule_name,\n            Constant_Heating_Setpoint=self.SpaceUse.Thermostat.HeatingSetpoint\n            if self.SpaceUse.Thermostat.HeatingSchedule is None\n            else None,\n            Cooling_Setpoint_Schedule_Name=cooling_schedule_name,\n            Constant_Cooling_Setpoint=self.SpaceUse.Thermostat.CoolingSetpoint\n            if self.SpaceUse.Thermostat.CoolingSchedule is None\n            else None,\n        )\n\n        idf = thermostat.add(idf)\n\n        return thermostat\n\n    def add_conditioning_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n        \"\"\"Add conditioning to an IDF zone.\"\"\"\n        thermostat = self.add_thermostat_to_idf_zone(idf, target_zone_name)\n        if self.HVAC.Ventilation.DCV != \"NoDCV\":\n            # check the design spec outdoor air for the DCV\n            raise NotImplementedError(\"DCV not implemented.\")\n        hvac_template = HVACTemplateZoneIdealLoadsAirSystem(\n            Zone_Name=target_zone_name,\n            Template_Thermostat_Name=thermostat.Name,\n            Heating_Availability_Schedule_Name=None\n            if self.HVAC.ConditioningSystems.Heating\n            else \"AlwaysOff\",\n            Cooling_Availability_Schedule_Name=None\n            if self.HVAC.ConditioningSystems.Cooling\n            else \"AlwaysOff\",\n            Heating_Limit=\"LimitFlowRateAndCapacity\",\n            Maximum_Heating_Air_Flow_Rate=\"autosize\",\n            Maximum_Sensible_Heating_Capacity=\"autosize\",\n            Cooling_Limit=\"LimitFlowRateAndCapacity\",\n            Maximum_Cooling_Air_Flow_Rate=\"autosize\",\n            Maximum_Total_Cooling_Capacity=\"autosize\",\n            Minimum_Cooling_Supply_Air_Temperature=13,\n            Humidification_Control_Type=\"None\",\n            Outdoor_Air_Flow_Rate_per_Person=self.HVAC.Ventilation.FreshAirPerPerson,\n            Outdoor_Air_Flow_Rate_per_Zone_Floor_Area=self.HVAC.Ventilation.FreshAirPerFloorArea,\n            Outdoor_Air_Flow_Rate_per_Zone=0,\n            Demand_Controlled_Ventilation_Type=\"None\"\n            if self.HVAC.Ventilation.DCV == \"NoDCV\"\n            else self.HVAC.Ventilation.DCV,\n            Outdoor_Air_Economizer_Type=self.HVAC.Ventilation.Economizer,\n            Heat_Recovery_Type=\"None\"\n            if self.HVAC.Ventilation.HRV == \"NoHRV\"\n            else self.HVAC.Ventilation.HRV,\n            Sensible_Heat_Recovery_Effectiveness=assumed_constants.Sensible_Heat_Recovery_Effectiveness,\n            Latent_Heat_Recovery_Effectiveness=assumed_constants.Latent_Heat_Recovery_Effectiveness,\n            Outdoor_Air_Method=\"Sum\"\n            if self.HVAC.Ventilation.Provider == \"Mechanical\"\n            or self.HVAC.Ventilation.Provider == \"Both\"\n            else \"None\",\n        )\n        idf = hvac_template.add(idf)\n\n        if self.HVAC.Ventilation.Provider == \"Natural\":\n            # total_window_area = calculate_window_area_for_zone(idf, target_zone_name)\n            total_window_area = get_zone_glazed_area(idf, target_zone_name)\n\n            if total_window_area == 0:\n                logger.warning(\n                    f\"No windows found for natural ventilation in zone {target_zone_name}\"\n                )\n                return idf\n            vent_wind_stack_name = f\"{target_zone_name}_{self.SpaceUse.Thermostat.safe_name}_{self.HVAC.Ventilation.safe_name}_VENTILATION_WIND_AND_STACK_OPEN_AREA\"\n\n            idf, vent_wind_stack_name_sch = (\n                self.HVAC.Ventilation.Schedule.add_year_to_idf(\n                    idf,\n                    name_prefix=None,\n                    summer_design_day_sch_name=\"d_AllOff_00\",\n                    winter_design_day_sch_name=\"d_AllOff_00\",\n                )\n            )\n            ventilation_wind_and_stack_open_area = ZoneVentilationWindAndStackOpenArea(\n                Name=vent_wind_stack_name,\n                Zone_or_Space_Name=target_zone_name,\n                Minimum_Outdoor_Temperature=12,\n                Height_Difference=0,\n                Delta_Temperature=2,\n                Maximum_Outdoor_Temperature=25,\n                Opening_Area=total_window_area,\n                Opening_Area_Fraction_Schedule_Name=vent_wind_stack_name_sch,\n            )\n            idf = ventilation_wind_and_stack_open_area.add(idf)\n\n        return idf\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.operations.ZoneOperationsComponent.add_conditioning_to_idf_zone","title":"<code>add_conditioning_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Add conditioning to an IDF zone.</p> Source code in <code>epinterface/sbem/components/operations.py</code> <pre><code>def add_conditioning_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n    \"\"\"Add conditioning to an IDF zone.\"\"\"\n    thermostat = self.add_thermostat_to_idf_zone(idf, target_zone_name)\n    if self.HVAC.Ventilation.DCV != \"NoDCV\":\n        # check the design spec outdoor air for the DCV\n        raise NotImplementedError(\"DCV not implemented.\")\n    hvac_template = HVACTemplateZoneIdealLoadsAirSystem(\n        Zone_Name=target_zone_name,\n        Template_Thermostat_Name=thermostat.Name,\n        Heating_Availability_Schedule_Name=None\n        if self.HVAC.ConditioningSystems.Heating\n        else \"AlwaysOff\",\n        Cooling_Availability_Schedule_Name=None\n        if self.HVAC.ConditioningSystems.Cooling\n        else \"AlwaysOff\",\n        Heating_Limit=\"LimitFlowRateAndCapacity\",\n        Maximum_Heating_Air_Flow_Rate=\"autosize\",\n        Maximum_Sensible_Heating_Capacity=\"autosize\",\n        Cooling_Limit=\"LimitFlowRateAndCapacity\",\n        Maximum_Cooling_Air_Flow_Rate=\"autosize\",\n        Maximum_Total_Cooling_Capacity=\"autosize\",\n        Minimum_Cooling_Supply_Air_Temperature=13,\n        Humidification_Control_Type=\"None\",\n        Outdoor_Air_Flow_Rate_per_Person=self.HVAC.Ventilation.FreshAirPerPerson,\n        Outdoor_Air_Flow_Rate_per_Zone_Floor_Area=self.HVAC.Ventilation.FreshAirPerFloorArea,\n        Outdoor_Air_Flow_Rate_per_Zone=0,\n        Demand_Controlled_Ventilation_Type=\"None\"\n        if self.HVAC.Ventilation.DCV == \"NoDCV\"\n        else self.HVAC.Ventilation.DCV,\n        Outdoor_Air_Economizer_Type=self.HVAC.Ventilation.Economizer,\n        Heat_Recovery_Type=\"None\"\n        if self.HVAC.Ventilation.HRV == \"NoHRV\"\n        else self.HVAC.Ventilation.HRV,\n        Sensible_Heat_Recovery_Effectiveness=assumed_constants.Sensible_Heat_Recovery_Effectiveness,\n        Latent_Heat_Recovery_Effectiveness=assumed_constants.Latent_Heat_Recovery_Effectiveness,\n        Outdoor_Air_Method=\"Sum\"\n        if self.HVAC.Ventilation.Provider == \"Mechanical\"\n        or self.HVAC.Ventilation.Provider == \"Both\"\n        else \"None\",\n    )\n    idf = hvac_template.add(idf)\n\n    if self.HVAC.Ventilation.Provider == \"Natural\":\n        # total_window_area = calculate_window_area_for_zone(idf, target_zone_name)\n        total_window_area = get_zone_glazed_area(idf, target_zone_name)\n\n        if total_window_area == 0:\n            logger.warning(\n                f\"No windows found for natural ventilation in zone {target_zone_name}\"\n            )\n            return idf\n        vent_wind_stack_name = f\"{target_zone_name}_{self.SpaceUse.Thermostat.safe_name}_{self.HVAC.Ventilation.safe_name}_VENTILATION_WIND_AND_STACK_OPEN_AREA\"\n\n        idf, vent_wind_stack_name_sch = (\n            self.HVAC.Ventilation.Schedule.add_year_to_idf(\n                idf,\n                name_prefix=None,\n                summer_design_day_sch_name=\"d_AllOff_00\",\n                winter_design_day_sch_name=\"d_AllOff_00\",\n            )\n        )\n        ventilation_wind_and_stack_open_area = ZoneVentilationWindAndStackOpenArea(\n            Name=vent_wind_stack_name,\n            Zone_or_Space_Name=target_zone_name,\n            Minimum_Outdoor_Temperature=12,\n            Height_Difference=0,\n            Delta_Temperature=2,\n            Maximum_Outdoor_Temperature=25,\n            Opening_Area=total_window_area,\n            Opening_Area_Fraction_Schedule_Name=vent_wind_stack_name_sch,\n        )\n        idf = ventilation_wind_and_stack_open_area.add(idf)\n\n    return idf\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.operations.ZoneOperationsComponent.add_thermostat_to_idf_zone","title":"<code>add_thermostat_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Add a thermostat to the zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the thermostat to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the thermostat to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/sbem/components/operations.py</code> <pre><code>def add_thermostat_to_idf_zone(\n    self, idf: IDF, target_zone_name: str\n) -&gt; HVACTemplateThermostat:\n    \"\"\"Add a thermostat to the zone.\n\n    Args:\n        idf (IDF): The IDF object to add the thermostat to.\n        target_zone_name (str): The name of the zone to add the thermostat to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    thermostat_name = (\n        f\"{target_zone_name}_{self.SpaceUse.Thermostat.safe_name}_THERMOSTAT\"\n    )\n    heating_schedule = self.SpaceUse.Thermostat.HeatingSchedule\n    cooling_schedule = self.SpaceUse.Thermostat.CoolingSchedule\n\n    heating_schedule_name = None\n    cooling_schedule_name = None\n    if heating_schedule is not None:\n        _, heat_high = self.SpaceUse.Thermostat.HeatingSchedule.bounds\n        heating_design_day = ScheduleDayHourly(\n            Name=f\"{thermostat_name}_HeatingDesignDay\",\n            Schedule_Type_Limits_Name=\"Temperature\",\n            Hour_1=heat_high,\n            Hour_2=heat_high,\n            Hour_3=heat_high,\n            Hour_4=heat_high,\n            Hour_5=heat_high,\n            Hour_6=heat_high,\n            Hour_7=heat_high,\n            Hour_8=heat_high,\n            Hour_9=heat_high,\n            Hour_10=heat_high,\n            Hour_11=heat_high,\n            Hour_12=heat_high,\n            Hour_13=heat_high,\n            Hour_14=heat_high,\n            Hour_15=heat_high,\n            Hour_16=heat_high,\n            Hour_17=heat_high,\n            Hour_18=heat_high,\n            Hour_19=heat_high,\n            Hour_20=heat_high,\n            Hour_21=heat_high,\n            Hour_22=heat_high,\n            Hour_23=heat_high,\n            Hour_24=heat_high,\n        )\n        idf = heating_design_day.add(idf)\n        idf, heating_schedule_name = heating_schedule.add_year_to_idf(\n            idf,\n            name_prefix=None,\n            winter_design_day_sch_name=heating_design_day.Name,\n            summer_design_day_sch_name=heating_design_day.Name,\n        )\n    if cooling_schedule is not None:\n        cool_low, _ = self.SpaceUse.Thermostat.CoolingSchedule.bounds\n        cooling_design_day = ScheduleDayHourly(\n            Name=f\"{thermostat_name}_CoolingDesignDay\",\n            Schedule_Type_Limits_Name=\"Temperature\",\n            Hour_1=cool_low,\n            Hour_2=cool_low,\n            Hour_3=cool_low,\n            Hour_4=cool_low,\n            Hour_5=cool_low,\n            Hour_6=cool_low,\n            Hour_7=cool_low,\n            Hour_8=cool_low,\n            Hour_9=cool_low,\n            Hour_10=cool_low,\n            Hour_11=cool_low,\n            Hour_12=cool_low,\n            Hour_13=cool_low,\n            Hour_14=cool_low,\n            Hour_15=cool_low,\n            Hour_16=cool_low,\n            Hour_17=cool_low,\n            Hour_18=cool_low,\n            Hour_19=cool_low,\n            Hour_20=cool_low,\n            Hour_21=cool_low,\n            Hour_22=cool_low,\n            Hour_23=cool_low,\n            Hour_24=cool_low,\n        )\n\n        idf = cooling_design_day.add(idf)\n        idf, cooling_schedule_name = cooling_schedule.add_year_to_idf(\n            idf,\n            name_prefix=None,\n            winter_design_day_sch_name=cooling_design_day.Name,\n            summer_design_day_sch_name=cooling_design_day.Name,\n        )\n\n    thermostat = HVACTemplateThermostat(\n        Name=thermostat_name,\n        Heating_Setpoint_Schedule_Name=heating_schedule_name,\n        Constant_Heating_Setpoint=self.SpaceUse.Thermostat.HeatingSetpoint\n        if self.SpaceUse.Thermostat.HeatingSchedule is None\n        else None,\n        Cooling_Setpoint_Schedule_Name=cooling_schedule_name,\n        Constant_Cooling_Setpoint=self.SpaceUse.Thermostat.CoolingSetpoint\n        if self.SpaceUse.Thermostat.CoolingSchedule is None\n        else None,\n    )\n\n    idf = thermostat.add(idf)\n\n    return thermostat\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.operations.ZoneOperationsComponent.add_water_use_to_idf_zone","title":"<code>add_water_use_to_idf_zone(idf, target_zone_name)</code>","text":"<p>Handle adding water use to the zone based on both DHW and Operations.SpaceUse.WaterUse.</p> <p>We choose to execute this from the zone component interface because it requires context from both zone.Operations.SpaceUse.WaterUse and zone.Operations.</p> <p>Note: the water use component's flow rate represents the total amount of water used per person per day; in order to calculate a peak flow rate, we will need to ensure that the product of the schedule and the peak flow rate would resolve to the same daily average value per person.</p> This will be responsible for <ol> <li>Extracting the total area of the zone by finding the matching surfaces.</li> <li>Computing the total number of people in the zone based on the occupancy density and the total area.</li> <li>Computing the average flow rate of water use/s in the zone based on the flow rate per person/day and the total number of people.</li> <li>Computing the peak flow rate of water use/s in the zone based on the average flow rate and the average fractional value of the schedule.</li> <li>Adding the water use equipment to the zone.</li> </ol>"},{"location":"modules/sbem/components/#epinterface.sbem.components.operations.ZoneOperationsComponent.add_water_use_to_idf_zone--todo-major-problem-this-assumes-the-zone-has-already-been-correctly-sized","title":"TODO: major problem - this assumes the zone has already been correctly sized!","text":""},{"location":"modules/sbem/components/#epinterface.sbem.components.operations.ZoneOperationsComponent.add_water_use_to_idf_zone--this-method-should-only-actually-be-called-after","title":"this method should only actually be called AFTER","text":""},{"location":"modules/sbem/components/#epinterface.sbem.components.operations.ZoneOperationsComponent.add_water_use_to_idf_zone--the-building-has-been-properly-rescaled-which-currently-is-executed-at-the-very-end","title":"the building has been properly rescaled, which currently is executed at the very end.","text":""},{"location":"modules/sbem/components/#epinterface.sbem.components.operations.ZoneOperationsComponent.add_water_use_to_idf_zone--that-hook-should-probably-be-moved-up","title":"that hook should probably be moved up.","text":"<p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the operations to.</p> required <code>target_zone_name</code> <code>str</code> <p>The name of the zone to add the operations to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/sbem/components/operations.py</code> <pre><code>def add_water_use_to_idf_zone(self, idf: IDF, target_zone_name: str) -&gt; IDF:\n    \"\"\"Handle adding water use to the zone based on both DHW and Operations.SpaceUse.WaterUse.\n\n    We choose to execute this from the zone component interface because it requires context from both\n    zone.Operations.SpaceUse.WaterUse and zone.Operations.\n\n    Note: the water use component's flow rate represents the total amount of water used per person per day;\n    in order to calculate a peak flow rate, we will need to ensure that the product of the schedule and the peak\n    flow rate would resolve to the same daily average value per person.\n\n    This will be responsible for:\n        1. Extracting the total area of the zone by finding the matching surfaces.\n        2. Computing the total number of people in the zone based on the occupancy density and the total area.\n        3. Computing the average flow rate of water use/s in the zone based on the flow rate per person/day and the total number of people.\n        4. Computing the peak flow rate of water use/s in the zone based on the average flow rate and the average fractional value of the schedule.\n        5. Adding the water use equipment to the zone.\n\n\n    # TODO: major problem - this assumes the zone has already been correctly sized!\n    # this method should only actually be called AFTER\n    # the building has been properly rescaled, which currently is executed at the very end.\n    # that hook should probably be moved up.\n\n    Args:\n        idf (IDF): The IDF object to add the operations to.\n        target_zone_name (str): The name of the zone to add the operations to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    # TODO: should IsOn definitely live in DHW? should dhw be nullable?\n    # should it live in spaceuse.wateruse for consistency?\n    if not self.DHW.IsOn:\n        return idf\n\n    # Acquire the relevant data fields\n    flow_rate_per_person_per_day = (\n        self.SpaceUse.WaterUse.FlowRatePerPerson\n    )  # m3/person/day\n    occupant_density = self.SpaceUse.Occupancy.PeopleDensity  # ppl/m2\n    water_supply_temperature = self.DHW.WaterSupplyTemperature  # degC\n    water_temperature_inlet = self.DHW.WaterTemperatureInlet  # degC\n    water_use_frac_sched = self.SpaceUse.WaterUse.Schedule\n    water_use_name = f\"{target_zone_name}_{self.SpaceUse.WaterUse.safe_name}_{self.DHW.safe_name}_WATER\"\n\n    # determine zone area to then compute total people\n    # we will do this by finding all matching surfaces and computing their areas.\n    zone = next(\n        (x for x in idf.idfobjects[\"ZONE\"] if x.Name == target_zone_name), None\n    )\n    if zone is None:\n        raise ValueError(f\"NO_ZONE:{target_zone_name}\")\n    area = get_zone_floor_area(idf, zone.Name)\n    total_ppl = occupant_density * area\n\n    # Compute final flow rates.\n    total_flow_per_day = flow_rate_per_person_per_day * total_ppl  # m3/day\n    avg_flow_per_s = total_flow_per_day / (3600 * 24)  # m3/s\n    # TODO: Update this rather than being constant rate\n\n    lim = \"Temperature\"\n    if not idf.getobject(\"SCHEDULETYPELIMITS\", lim):\n        lim = ScheduleTypeLimits(\n            Name=\"Temperature\",\n            LowerLimit=-60,\n            UpperLimit=200,\n        )\n        lim.to_epbunch(idf)\n\n    # TODO: should we be using time-varying temperatures?\n    target_temperature_schedule = Schedule.constant_schedule(\n        value=water_supply_temperature,  # pyright: ignore [reportArgumentType]\n        Name=f\"{water_use_name}_TargetWaterTemperatureSch\",\n        Type=\"Temperature\",\n    )\n    inlet_temperature_schedule = Schedule.constant_schedule(\n        value=water_temperature_inlet,  # pyright: ignore [reportArgumentType]\n        Name=f\"{water_use_name}_InletWaterTemperatureSch\",\n        Type=\"Temperature\",\n    )\n\n    target_temperature_yr_schedule, *_ = (\n        target_temperature_schedule.to_year_week_day()\n    )\n    inlet_temperature_yr_schedule, *_ = (\n        inlet_temperature_schedule.to_year_week_day()\n    )\n\n    target_temperature_yr_schedule.to_epbunch(idf)\n    inlet_temperature_yr_schedule.to_epbunch(idf)\n\n    if water_use_frac_sched.schedule_type_limits != \"Fraction\":\n        msg = f\"WATER_USE_FRACTION_SCHEDULE_TYPE_NOT_FRACTION:{water_use_name}\"\n        raise ValueError(msg)\n\n    idf, water_use_frac_sch_name = water_use_frac_sched.add_year_to_idf(\n        idf, name_prefix=None\n    )\n    # sch_obj = idf.getobject(\"SCHEDULE:YEAR\", water_use_frac_sch_name)\n    # arch_sch = Schedule.from_epbunch(sch_obj)\n    # values = np.array(arch_sch.Values)\n    # avg_fractional_value = np.sum(values) / 8760\n    logger.warning(\"USING HARDCODED 2018 to compute avg fractional value\")\n    avg_fractional_value = water_use_frac_sched.fractional_year_sum(2018)\n    # total_fractional_value * peak_flow_rate_per_s = avg_float_per_s\n    peak_flow_rate_per_s = avg_flow_per_s / avg_fractional_value\n\n    hot_water = WaterUseEquipment(\n        Name=water_use_name,\n        EndUse_Subcategory=\"Domestic Hot Water\",\n        Peak_Flow_Rate=peak_flow_rate_per_s,\n        Flow_Rate_Fraction_Schedule_Name=water_use_frac_sch_name,\n        Zone_Name=target_zone_name,\n        Target_Temperature_Schedule_Name=target_temperature_yr_schedule.Name,\n        Hot_Water_Supply_Temperature_Schedule_Name=target_temperature_schedule.Name,\n        Cold_Water_Supply_Temperature_Schedule_Name=inlet_temperature_schedule.Name,\n        Sensible_Fraction_Schedule_Name=None,\n        Latent_Fraction_Schedule_Name=None,\n    )\n    idf = hot_water.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/sbem/components/#envelope","title":"Envelope","text":"<p>Envelope components for the SBEM library.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.ConstructionAssemblyComponent","title":"<code>ConstructionAssemblyComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>Opaque construction object.</p> Source code in <code>epinterface/sbem/components/envelope.py</code> <pre><code>class ConstructionAssemblyComponent(\n    NamedObject,\n    MetadataMixin,\n    extra=\"forbid\",\n):\n    \"\"\"Opaque construction object.\"\"\"\n\n    Layers: list[ConstructionLayerComponent] = Field(\n        ..., title=\"Layers of the opaque construction\"\n    )\n    VegetationLayer: NanStr | None = Field(\n        default=None, title=\"Vegetation layer of the opaque construction\"\n    )\n    Type: ConstructionComponentSurfaceType = Field(\n        ..., title=\"Type of the opaque construction\"\n    )\n\n    @field_validator(\"Layers\", mode=\"after\")\n    def validate_layers(cls, v: list[ConstructionLayerComponent]):\n        \"\"\"Validate the layers of the construction.\"\"\"\n        if len(v) == 0:\n            msg = \"At least one layer is required\"\n            raise ValueError(msg)\n        layer_orders = [layer.LayerOrder for layer in v]\n        if set(layer_orders) != set(range(0, len(v))):\n            msg = \"Layer orders must be consecutive integers starting from 0\"\n            raise ValueError(msg)\n        v = sorted(v, key=lambda x: x.LayerOrder)\n        total_thickness = sum(layer.Thickness for layer in v)\n        if total_thickness &gt; 3:\n            msg = \"Total construction assembly thickness must be less than 3 meters\"\n            raise ValueError(msg)\n        return v\n\n    def add_to_idf(self, idf: IDF) -&gt; IDF:\n        \"\"\"Adds an opaque construction to an IDF object.\n\n        Note that this will add the individual materials as well.\n\n        Args:\n            idf (IDF): The IDF object to add the construction to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        layers = [layer.ep_material for layer in self.Layers]\n\n        construction = Construction(\n            name=self.Name,\n            layers=layers,\n        )\n        idf = construction.add(idf)\n        return idf\n\n    @property\n    def sorted_layers(self):\n        \"\"\"Return the layers of the construction sorted by layer order.\"\"\"\n        return sorted(self.Layers, key=lambda x: x.LayerOrder)\n\n    @property\n    def reversed(self):\n        \"\"\"Return a reversed version of the construction.\"\"\"\n        copy = self.model_copy(deep=True)\n        for i, layer in enumerate(copy.sorted_layers[::-1]):\n            layer.LayerOrder = i\n        copy.Layers = copy.sorted_layers\n        copy.Name = f\"{self.Name}_Reversed\"\n        return copy\n\n    @property\n    def r_value(self):\n        \"\"\"Return the R-value of the construction in m\u00b2K/W.\"\"\"\n        return sum(layer.r_value for layer in self.sorted_layers)\n\n    @property\n    def u_value(self):\n        \"\"\"Return the U-value of the construction in W/m\u00b2K.\"\"\"\n        return 1 / self.r_value\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.ConstructionAssemblyComponent.r_value","title":"<code>r_value</code>  <code>property</code>","text":"<p>Return the R-value of the construction in m\u00b2K/W.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.ConstructionAssemblyComponent.reversed","title":"<code>reversed</code>  <code>property</code>","text":"<p>Return a reversed version of the construction.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.ConstructionAssemblyComponent.sorted_layers","title":"<code>sorted_layers</code>  <code>property</code>","text":"<p>Return the layers of the construction sorted by layer order.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.ConstructionAssemblyComponent.u_value","title":"<code>u_value</code>  <code>property</code>","text":"<p>Return the U-value of the construction in W/m\u00b2K.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.ConstructionAssemblyComponent.add_to_idf","title":"<code>add_to_idf(idf)</code>","text":"<p>Adds an opaque construction to an IDF object.</p> <p>Note that this will add the individual materials as well.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the construction to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/sbem/components/envelope.py</code> <pre><code>def add_to_idf(self, idf: IDF) -&gt; IDF:\n    \"\"\"Adds an opaque construction to an IDF object.\n\n    Note that this will add the individual materials as well.\n\n    Args:\n        idf (IDF): The IDF object to add the construction to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    layers = [layer.ep_material for layer in self.Layers]\n\n    construction = Construction(\n        name=self.Name,\n        layers=layers,\n    )\n    idf = construction.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.ConstructionAssemblyComponent.validate_layers","title":"<code>validate_layers(v)</code>","text":"<p>Validate the layers of the construction.</p> Source code in <code>epinterface/sbem/components/envelope.py</code> <pre><code>@field_validator(\"Layers\", mode=\"after\")\ndef validate_layers(cls, v: list[ConstructionLayerComponent]):\n    \"\"\"Validate the layers of the construction.\"\"\"\n    if len(v) == 0:\n        msg = \"At least one layer is required\"\n        raise ValueError(msg)\n    layer_orders = [layer.LayerOrder for layer in v]\n    if set(layer_orders) != set(range(0, len(v))):\n        msg = \"Layer orders must be consecutive integers starting from 0\"\n        raise ValueError(msg)\n    v = sorted(v, key=lambda x: x.LayerOrder)\n    total_thickness = sum(layer.Thickness for layer in v)\n    if total_thickness &gt; 3:\n        msg = \"Total construction assembly thickness must be less than 3 meters\"\n        raise ValueError(msg)\n    return v\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.ConstructionLayerComponent","title":"<code>ConstructionLayerComponent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Layer of an opaque construction.</p> Source code in <code>epinterface/sbem/components/envelope.py</code> <pre><code>class ConstructionLayerComponent(BaseModel, extra=\"forbid\"):\n    \"\"\"Layer of an opaque construction.\"\"\"\n\n    Thickness: float = Field(..., title=\"Thickness of the layer [m]\", ge=0, le=2)\n    LayerOrder: int\n    ConstructionMaterial: ConstructionMaterialComponent\n\n    @property\n    def name(self):\n        \"\"\"Return the name of the layer.\"\"\"\n        # TODO: do we want to consider scoping construction layer names by parent construction?\n        # We currently have disabled LayerOrder in the name because it was causing\n        # warnings to be rised by EP since a reversed construction would end up with\n        # using different materials though with identical definitions; energyplus would\n        # throw a warning but still proceed.\n        # by not name scoping here by the parent construction, we end up with silent logical\n        # failures in the event where a user has mutated\n        # post-instantiated, decoupled ConstructionMaterial definitions with the same\n        # name.\n        # return f\"{self.LayerOrder}_{self.ConstructionMaterial.Name}_{self.Thickness}m\"\n        return f\"{self.ConstructionMaterial.Name}_{self.Thickness}m\"\n\n    @property\n    def ep_material(self):\n        \"\"\"Return the EP material for the layer.\"\"\"\n        return Material(\n            Name=self.name,\n            Thickness=self.Thickness,\n            Conductivity=self.ConstructionMaterial.Conductivity,\n            Density=self.ConstructionMaterial.Density,\n            Specific_Heat=self.ConstructionMaterial.SpecificHeat,\n            Thermal_Absorptance=self.ConstructionMaterial.ThermalAbsorptance,\n            Solar_Absorptance=self.ConstructionMaterial.SolarAbsorptance,\n            Roughness=self.ConstructionMaterial.Roughness,\n            Visible_Absorptance=self.ConstructionMaterial.VisibleAbsorptance,\n        )\n\n    @property\n    def r_value(self):\n        \"\"\"Return the R-value of the layer in m\u00b2K/W.\"\"\"\n        return self.Thickness / self.ConstructionMaterial.Conductivity\n\n    @property\n    def u_value(self):\n        \"\"\"Return the U-value of the layer in W/m\u00b2K.\"\"\"\n        return 1 / self.r_value\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.ConstructionLayerComponent.ep_material","title":"<code>ep_material</code>  <code>property</code>","text":"<p>Return the EP material for the layer.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.ConstructionLayerComponent.name","title":"<code>name</code>  <code>property</code>","text":"<p>Return the name of the layer.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.ConstructionLayerComponent.r_value","title":"<code>r_value</code>  <code>property</code>","text":"<p>Return the R-value of the layer in m\u00b2K/W.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.ConstructionLayerComponent.u_value","title":"<code>u_value</code>  <code>property</code>","text":"<p>Return the U-value of the layer in W/m\u00b2K.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.EnvelopeAssemblyComponent","title":"<code>EnvelopeAssemblyComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>Zone construction object.</p> Source code in <code>epinterface/sbem/components/envelope.py</code> <pre><code>class EnvelopeAssemblyComponent(\n    NamedObject,\n    MetadataMixin,\n    extra=\"forbid\",\n):\n    \"\"\"Zone construction object.\"\"\"\n\n    FlatRoofAssembly: ConstructionAssemblyComponent = Field(\n        ..., title=\"Flat roof construction object; only used when no attic is present.\"\n    )\n    FacadeAssembly: ConstructionAssemblyComponent = Field(\n        ..., title=\"Facade construction object\"\n    )\n    FloorCeilingAssembly: ConstructionAssemblyComponent = Field(\n        ..., title=\"Floor/ceiling construction object\"\n    )\n    AtticRoofAssembly: ConstructionAssemblyComponent = Field(\n        ...,\n        title=\"Attic roof construction object (outer surface) - only used when attic is present.\",\n    )\n    AtticFloorAssembly: ConstructionAssemblyComponent = Field(\n        ..., title=\"Attic floor construction object  - only used when attic is present.\"\n    )\n    PartitionAssembly: ConstructionAssemblyComponent = Field(\n        ..., title=\"Partition construction object\"\n    )\n    ExternalFloorAssembly: ConstructionAssemblyComponent = Field(\n        ..., title=\"External floor construction object\"\n    )\n    GroundSlabAssembly: ConstructionAssemblyComponent = Field(\n        ..., title=\"Ground slab construction object\"\n    )\n    GroundWallAssembly: ConstructionAssemblyComponent = Field(\n        ...,\n        title=\"Ground wall construction object (only used when basement is present)\",\n    )\n    BasementCeilingAssembly: ConstructionAssemblyComponent = Field(\n        ...,\n        title=\"Basement ceiling construction object (only used when basement is present)\",\n    )\n    InternalMassAssembly: ConstructionAssemblyComponent | None = Field(\n        default=None, title=\"Internal mass construction object\"\n    )\n    InternalMassExposedAreaPerArea: float | None = Field(\n        default=None,\n        title=\"Internal mass exposed area per area [m\u00b2/m\u00b2]\",\n        ge=0,\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_internal_mass_exposed_area_per_area(self):\n        \"\"\"Validate that either both internal mass assembly and internal mass exposed area are provided, or neither.\"\"\"\n        if self.InternalMassAssembly and (\n            self.InternalMassExposedAreaPerArea is None\n            or self.InternalMassExposedAreaPerArea == 0\n        ):\n            msg = \"Internal mass assembly cannot be provided if internal mass exposed area per area is not provided (or 0).\"\n            raise ValueError(msg)\n        if (\n            self.InternalMassExposedAreaPerArea is not None\n            and self.InternalMassExposedAreaPerArea != 0\n        ) and self.InternalMassAssembly is None:\n            msg = \"Internal mass exposed area per area must be provided if internal mass assembly is provided\"\n            raise ValueError(msg)\n        return self\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.EnvelopeAssemblyComponent.validate_internal_mass_exposed_area_per_area","title":"<code>validate_internal_mass_exposed_area_per_area()</code>","text":"<p>Validate that either both internal mass assembly and internal mass exposed area are provided, or neither.</p> Source code in <code>epinterface/sbem/components/envelope.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_internal_mass_exposed_area_per_area(self):\n    \"\"\"Validate that either both internal mass assembly and internal mass exposed area are provided, or neither.\"\"\"\n    if self.InternalMassAssembly and (\n        self.InternalMassExposedAreaPerArea is None\n        or self.InternalMassExposedAreaPerArea == 0\n    ):\n        msg = \"Internal mass assembly cannot be provided if internal mass exposed area per area is not provided (or 0).\"\n        raise ValueError(msg)\n    if (\n        self.InternalMassExposedAreaPerArea is not None\n        and self.InternalMassExposedAreaPerArea != 0\n    ) and self.InternalMassAssembly is None:\n        msg = \"Internal mass exposed area per area must be provided if internal mass assembly is provided\"\n        raise ValueError(msg)\n    return self\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.GlazingConstructionSimpleComponent","title":"<code>GlazingConstructionSimpleComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>StandardMaterialMetadataMixin</code>, <code>MetadataMixin</code></p> <p>Glazing construction object.</p> Source code in <code>epinterface/sbem/components/envelope.py</code> <pre><code>class GlazingConstructionSimpleComponent(\n    NamedObject,\n    StandardMaterialMetadataMixin,\n    MetadataMixin,\n    extra=\"forbid\",\n):\n    \"\"\"Glazing construction object.\"\"\"\n\n    SHGF: float = Field(..., title=\"Solar heat gain factor\", ge=0, le=1)\n    UValue: float = Field(\n        ...,\n        title=\"U-value [W/m\u00b2K]\",\n        ge=0,\n    )\n    TVis: float = Field(..., title=\"Visible transmittance\", ge=0, le=1)\n    Type: WindowType = Field(..., title=\"Type of the glazing construction\")\n\n    def add_to_idf(self, idf: IDF) -&gt; IDF:\n        \"\"\"Adds the glazing construction to an IDF object.\n\n        Args:\n            idf (IDF): The IDF object to add the construction to.\n\n        Returns:\n            IDF: The updated IDF object.\n        \"\"\"\n        glazing_mat = SimpleGlazingMaterial(\n            Name=self.Name,\n            UFactor=self.UValue,\n            Solar_Heat_Gain_Coefficient=self.SHGF,\n            Visible_Transmittance=self.TVis,\n        )\n\n        construction = Construction(\n            name=self.Name,\n            layers=[glazing_mat],\n        )\n\n        idf = construction.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.GlazingConstructionSimpleComponent.add_to_idf","title":"<code>add_to_idf(idf)</code>","text":"<p>Adds the glazing construction to an IDF object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the construction to.</p> required <p>Returns:</p> Name Type Description <code>IDF</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/sbem/components/envelope.py</code> <pre><code>def add_to_idf(self, idf: IDF) -&gt; IDF:\n    \"\"\"Adds the glazing construction to an IDF object.\n\n    Args:\n        idf (IDF): The IDF object to add the construction to.\n\n    Returns:\n        IDF: The updated IDF object.\n    \"\"\"\n    glazing_mat = SimpleGlazingMaterial(\n        Name=self.Name,\n        UFactor=self.UValue,\n        Solar_Heat_Gain_Coefficient=self.SHGF,\n        Visible_Transmittance=self.TVis,\n    )\n\n    construction = Construction(\n        name=self.Name,\n        layers=[glazing_mat],\n    )\n\n    idf = construction.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.InfiltrationComponent","title":"<code>InfiltrationComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>Zone infiltration object.</p> Source code in <code>epinterface/sbem/components/envelope.py</code> <pre><code>class InfiltrationComponent(\n    NamedObject,\n    MetadataMixin,\n    extra=\"forbid\",\n):\n    \"\"\"Zone infiltration object.\"\"\"\n\n    IsOn: BoolStr = Field(..., title=\"Infiltration is on\")\n    # TODO: add assumed_constants\n    # TODO: these values should have stronger validators are on them or be dropped entirely and use defaults from EP wrapper classes\n    ConstantCoefficient: float = Field(\n        ...,\n        title=\"Infiltration constant coefficient\",\n    )\n    TemperatureCoefficient: float = Field(\n        ...,\n        title=\"Infiltration temperature coefficient\",\n    )\n    WindVelocityCoefficient: float = Field(\n        ...,\n        title=\"Infiltration wind velocity coefficient\",\n    )\n    WindVelocitySquaredCoefficient: float = Field(\n        ...,\n        title=\"Infiltration wind velocity squared coefficient\",\n    )\n    AFNAirMassFlowCoefficientCrack: float = Field(\n        ...,\n        title=\"AFN air mass flow coefficient crack\",\n    )\n\n    AirChangesPerHour: float = Field(\n        ...,\n        title=\"Infiltration air changes per hour [ACH]\",\n        ge=0,\n    )\n    FlowPerExteriorSurfaceArea: float = Field(\n        ...,\n        title=\"Infiltration flow per exterior surface area [m3/s/m2]\",\n        ge=0,\n    )\n    CalculationMethod: InfDesignFlowRateCalculationMethodType = Field(\n        ...,\n        title=\"Calculation method\",\n    )\n\n    def add_infiltration_to_idf_zone(\n        self, idf: IDF, target_zone_or_zone_list_name: str\n    ):\n        \"\"\"Add infiltration to an IDF zone.\n\n        Args:\n            idf (IDF): The IDF object to add the infiltration to.\n            target_zone_or_zone_list_name (str): The name of the zone or zone list to add the infiltration to.\n\n        Returns:\n            idf (IDF): The updated IDF object.\n        \"\"\"\n        if not self.IsOn:\n            return idf\n\n        infiltration_schedule_name = (\n            f\"{target_zone_or_zone_list_name}_{self.safe_name}_INFILTRATION_Schedule\"\n        )\n        infiltration_name = (\n            f\"{target_zone_or_zone_list_name}_{self.safe_name}_INFILTRATION\"\n        )\n        schedule = Schedule.constant_schedule(\n            value=1, Name=infiltration_schedule_name, Type=\"Fraction\"\n        )\n        inf_schedule, *_ = schedule.to_year_week_day()\n        inf_schedule.to_epbunch(idf)\n        inf = ZoneInfiltrationDesignFlowRate(\n            Name=infiltration_name,\n            Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n            Schedule_Name=inf_schedule.Name,\n            Design_Flow_Rate_Calculation_Method=self.CalculationMethod,\n            Flow_Rate_per_Exterior_Surface_Area=self.FlowPerExteriorSurfaceArea,\n            Air_Changes_per_Hour=self.AirChangesPerHour,\n            Flow_Rate_per_Floor_Area=None,\n            Design_Flow_Rate=None,\n            # Constant_Term_Coefficient=self.ConstantCoefficient,\n            # Temperature_Term_Coefficient=self.TemperatureCoefficient,\n            # Velocity_Term_Coefficient=self.WindVelocityCoefficient,\n            # Velocity_Squared_Term_Coefficient=self.WindVelocitySquaredCoefficient,\n        )\n        idf = inf.add(idf)\n        return idf\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.InfiltrationComponent.add_infiltration_to_idf_zone","title":"<code>add_infiltration_to_idf_zone(idf, target_zone_or_zone_list_name)</code>","text":"<p>Add infiltration to an IDF zone.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the infiltration to.</p> required <code>target_zone_or_zone_list_name</code> <code>str</code> <p>The name of the zone or zone list to add the infiltration to.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The updated IDF object.</p> Source code in <code>epinterface/sbem/components/envelope.py</code> <pre><code>def add_infiltration_to_idf_zone(\n    self, idf: IDF, target_zone_or_zone_list_name: str\n):\n    \"\"\"Add infiltration to an IDF zone.\n\n    Args:\n        idf (IDF): The IDF object to add the infiltration to.\n        target_zone_or_zone_list_name (str): The name of the zone or zone list to add the infiltration to.\n\n    Returns:\n        idf (IDF): The updated IDF object.\n    \"\"\"\n    if not self.IsOn:\n        return idf\n\n    infiltration_schedule_name = (\n        f\"{target_zone_or_zone_list_name}_{self.safe_name}_INFILTRATION_Schedule\"\n    )\n    infiltration_name = (\n        f\"{target_zone_or_zone_list_name}_{self.safe_name}_INFILTRATION\"\n    )\n    schedule = Schedule.constant_schedule(\n        value=1, Name=infiltration_schedule_name, Type=\"Fraction\"\n    )\n    inf_schedule, *_ = schedule.to_year_week_day()\n    inf_schedule.to_epbunch(idf)\n    inf = ZoneInfiltrationDesignFlowRate(\n        Name=infiltration_name,\n        Zone_or_ZoneList_Name=target_zone_or_zone_list_name,\n        Schedule_Name=inf_schedule.Name,\n        Design_Flow_Rate_Calculation_Method=self.CalculationMethod,\n        Flow_Rate_per_Exterior_Surface_Area=self.FlowPerExteriorSurfaceArea,\n        Air_Changes_per_Hour=self.AirChangesPerHour,\n        Flow_Rate_per_Floor_Area=None,\n        Design_Flow_Rate=None,\n        # Constant_Term_Coefficient=self.ConstantCoefficient,\n        # Temperature_Term_Coefficient=self.TemperatureCoefficient,\n        # Velocity_Term_Coefficient=self.WindVelocityCoefficient,\n        # Velocity_Squared_Term_Coefficient=self.WindVelocitySquaredCoefficient,\n    )\n    idf = inf.add(idf)\n    return idf\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.envelope.ZoneEnvelopeComponent","title":"<code>ZoneEnvelopeComponent</code>","text":"<p>               Bases: <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>Zone envelope object.</p> Source code in <code>epinterface/sbem/components/envelope.py</code> <pre><code>class ZoneEnvelopeComponent(NamedObject, MetadataMixin, extra=\"forbid\"):\n    \"\"\"Zone envelope object.\"\"\"\n\n    Assemblies: EnvelopeAssemblyComponent\n    Infiltration: InfiltrationComponent\n    AtticInfiltration: InfiltrationComponent\n    BasementInfiltration: InfiltrationComponent\n    Window: GlazingConstructionSimpleComponent | None\n</code></pre>"},{"location":"modules/sbem/components/#materials","title":"Materials","text":"<p>Materials for the SBEM library.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.materials.CommonMaterialPropertiesMixin","title":"<code>CommonMaterialPropertiesMixin</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Common material properties for glazing and opaque materials.</p> Source code in <code>epinterface/sbem/components/materials.py</code> <pre><code>class CommonMaterialPropertiesMixin(BaseModel):\n    \"\"\"Common material properties for glazing and opaque materials.\"\"\"\n\n    Conductivity: float = Field(\n        ...,\n        title=\"Conductivity [W/mK]\",\n        ge=0,\n    )\n    Density: float = Field(\n        ...,\n        title=\"Density [kg/m3]\",\n        ge=0,\n    )\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.materials.ConstructionMaterialComponent","title":"<code>ConstructionMaterialComponent</code>","text":"<p>               Bases: <code>ConstructionMaterialProperties</code>, <code>StandardMaterialMetadataMixin</code>, <code>NamedObject</code>, <code>MetadataMixin</code></p> <p>Construction material object.</p> Source code in <code>epinterface/sbem/components/materials.py</code> <pre><code>class ConstructionMaterialComponent(\n    ConstructionMaterialProperties,\n    StandardMaterialMetadataMixin,\n    NamedObject,\n    MetadataMixin,\n    extra=\"forbid\",\n):\n    \"\"\"Construction material object.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.materials.ConstructionMaterialProperties","title":"<code>ConstructionMaterialProperties</code>","text":"<p>               Bases: <code>CommonMaterialPropertiesMixin</code></p> <p>Properties of an opaque material.</p> Source code in <code>epinterface/sbem/components/materials.py</code> <pre><code>class ConstructionMaterialProperties(\n    CommonMaterialPropertiesMixin,\n    extra=\"forbid\",\n):\n    \"\"\"Properties of an opaque material.\"\"\"\n\n    # add in the commonMaterialsPropertis\n    Roughness: MaterialRoughness = Field(..., title=\"Roughness of the opaque material\")\n    SpecificHeat: float = Field(\n        ...,\n        title=\"Specific heat [J/kgK]\",\n        ge=0,\n    )\n    ThermalAbsorptance: float = Field(\n        ...,\n        title=\"Thermal absorptance [0-1]\",\n        ge=0,\n        le=1,\n    )\n    SolarAbsorptance: float = Field(\n        ...,\n        title=\"Solar absorptance [0-1]\",\n        ge=0,\n        le=1,\n    )\n    VisibleAbsorptance: float = Field(\n        ...,\n        title=\"Visible absorptance [0-1]\",\n        ge=0,\n        le=1,\n    )\n\n    TemperatureCoefficientThermalConductivity: float = Field(\n        ...,\n        # a superscript 2 looks like this:\n        title=\"Temperature coefficient of thermal conductivity [W/m.K2\u00b2]\",\n        ge=0,\n    )\n    # TODO: material type should be dynamic user entry or enum\n    Type: ConstructionMaterialType = Field(..., title=\"Type of the opaque material\")\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.materials.EnvironmentalMixin","title":"<code>EnvironmentalMixin</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Environmental data for a SBEM template table object.</p> Source code in <code>epinterface/sbem/components/materials.py</code> <pre><code>class EnvironmentalMixin(BaseModel):\n    \"\"\"Environmental data for a SBEM template table object.\"\"\"\n\n    Cost: float | None = Field(\n        default=None, title=\"Cost\", ge=0, description=\"Cost of the material/unit\"\n    )\n    RateUnit: Literal[\"m3\", \"m2\", \"m\", \"kg\"] | None = Field(\n        default=None,\n        description=\"The base unit for cost and embodied carbon, i.e. $/unit\",\n    )\n    Life: float | None = Field(\n        default=None, title=\"Life [years]\", ge=0, description=\"Life of the material\"\n    )\n    EmbodiedCarbon: float | None = Field(\n        default=None, title=\"Embodied carbon [kgCO2e/unit]\", ge=0\n    )\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.materials.StandardMaterialMetadataMixin","title":"<code>StandardMaterialMetadataMixin</code>","text":"<p>               Bases: <code>EnvironmentalMixin</code>, <code>MetadataMixin</code></p> <p>Standard metadata for a SBEM data.</p> Source code in <code>epinterface/sbem/components/materials.py</code> <pre><code>class StandardMaterialMetadataMixin(EnvironmentalMixin, MetadataMixin):\n    \"\"\"Standard metadata for a SBEM data.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/sbem/components/#schedules","title":"Schedules","text":"<p>This module contains the definitions for the schedules.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.DayComponent","title":"<code>DayComponent</code>","text":"<p>               Bases: <code>NamedObject</code></p> <p>A day of the week with a schedule type limit and a list of values.</p> Source code in <code>epinterface/sbem/components/schedules.py</code> <pre><code>class DayComponent(NamedObject, extra=\"forbid\"):\n    \"\"\"A day of the week with a schedule type limit and a list of values.\"\"\"\n\n    Type: ScheduleTypeLimitType = Field(\n        ..., description=\"The ScheduleTypeLimits of the day.\"\n    )\n    Hour_00: float\n    Hour_01: float\n    Hour_02: float\n    Hour_03: float\n    Hour_04: float\n    Hour_05: float\n    Hour_06: float\n    Hour_07: float\n    Hour_08: float\n    Hour_09: float\n    Hour_10: float\n    Hour_11: float\n    Hour_12: float\n    Hour_13: float\n    Hour_14: float\n    Hour_15: float\n    Hour_16: float\n    Hour_17: float\n    Hour_18: float\n    Hour_19: float\n    Hour_20: float\n    Hour_21: float\n    Hour_22: float\n    Hour_23: float\n\n    @property\n    def AverageValue(self) -&gt; float:\n        \"\"\"Get the average value of the day.\"\"\"\n        return sum(self.Values) / len(self.Values)\n\n    @property\n    def bounds(self) -&gt; tuple[float, float]:\n        \"\"\"Get the bounds of the day.\"\"\"\n        return min(self.Values), max(self.Values)\n\n    @property\n    def Values(self) -&gt; list[float]:\n        \"\"\"Get the values of the day as a list.\"\"\"\n        return [\n            self.Hour_00,\n            self.Hour_01,\n            self.Hour_02,\n            self.Hour_03,\n            self.Hour_04,\n            self.Hour_05,\n            self.Hour_06,\n            self.Hour_07,\n            self.Hour_08,\n            self.Hour_09,\n            self.Hour_10,\n            self.Hour_11,\n            self.Hour_12,\n            self.Hour_13,\n            self.Hour_14,\n            self.Hour_15,\n            self.Hour_16,\n            self.Hour_17,\n            self.Hour_18,\n            self.Hour_19,\n            self.Hour_20,\n            self.Hour_21,\n            self.Hour_22,\n            self.Hour_23,\n        ]\n\n    @model_validator(mode=\"after\")\n    def validate_values(self):\n        \"\"\"Validate the values of the day are consistent with the schedule type limit.\"\"\"\n        # TODO: Implement with a eye for Archetypal\n\n        lim_low = TypeLimits[self.Type].Lower_Limit_Value\n        lim_high = TypeLimits[self.Type].Upper_Limit_Value\n        if lim_low is not None and any(v &lt; lim_low for v in self.Values):\n            msg = f\"Values are less than the lower limit: {lim_low}\"\n            raise ValueError(msg)\n        if lim_high is not None and any(v &gt; lim_high for v in self.Values):\n            msg = f\"Values are greater than the upper limit: {lim_high}\"\n            raise ValueError(msg)\n        return self\n\n    def add_day_to_idf(self, idf: IDF, name_prefix: str | None) -&gt; tuple[IDF, str]:\n        \"\"\"Add the day to the IDF.\n\n        The name prefix can be used to scope the schedule creation to ensure a unique schedule per object.\n\n        Args:\n            idf (IDF): The IDF object to add the day to.\n            name_prefix (str | None): The prefix to use for the schedule name.\n\n        Returns:\n            idf (IDF): The IDF object with the day added.\n            day_name (str): The name of the day schedule.\n        \"\"\"\n        desired_name = self.Name\n        if name_prefix is not None:\n            desired_name = f\"{name_prefix}_DAY_{desired_name}\"\n\n        if idf.getobject(\"SCHEDULE:DAY:HOURLY\", desired_name):\n            return idf, desired_name\n\n        day_sched = ScheduleDayHourly(\n            Name=desired_name,\n            Schedule_Type_Limits_Name=self.Type,\n            Hour_1=self.Hour_00,\n            Hour_2=self.Hour_01,\n            Hour_3=self.Hour_02,\n            Hour_4=self.Hour_03,\n            Hour_5=self.Hour_04,\n            Hour_6=self.Hour_05,\n            Hour_7=self.Hour_06,\n            Hour_8=self.Hour_07,\n            Hour_9=self.Hour_08,\n            Hour_10=self.Hour_09,\n            Hour_11=self.Hour_10,\n            Hour_12=self.Hour_11,\n            Hour_13=self.Hour_12,\n            Hour_14=self.Hour_13,\n            Hour_15=self.Hour_14,\n            Hour_16=self.Hour_15,\n            Hour_17=self.Hour_16,\n            Hour_18=self.Hour_17,\n            Hour_19=self.Hour_18,\n            Hour_20=self.Hour_19,\n            Hour_21=self.Hour_20,\n            Hour_22=self.Hour_21,\n            Hour_23=self.Hour_22,\n            Hour_24=self.Hour_23,\n        )\n        idf = day_sched.add(idf)\n        return idf, day_sched.Name\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.DayComponent.AverageValue","title":"<code>AverageValue</code>  <code>property</code>","text":"<p>Get the average value of the day.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.DayComponent.Values","title":"<code>Values</code>  <code>property</code>","text":"<p>Get the values of the day as a list.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.DayComponent.bounds","title":"<code>bounds</code>  <code>property</code>","text":"<p>Get the bounds of the day.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.DayComponent.add_day_to_idf","title":"<code>add_day_to_idf(idf, name_prefix)</code>","text":"<p>Add the day to the IDF.</p> <p>The name prefix can be used to scope the schedule creation to ensure a unique schedule per object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the day to.</p> required <code>name_prefix</code> <code>str | None</code> <p>The prefix to use for the schedule name.</p> required <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The IDF object with the day added.</p> <code>day_name</code> <code>str</code> <p>The name of the day schedule.</p> Source code in <code>epinterface/sbem/components/schedules.py</code> <pre><code>def add_day_to_idf(self, idf: IDF, name_prefix: str | None) -&gt; tuple[IDF, str]:\n    \"\"\"Add the day to the IDF.\n\n    The name prefix can be used to scope the schedule creation to ensure a unique schedule per object.\n\n    Args:\n        idf (IDF): The IDF object to add the day to.\n        name_prefix (str | None): The prefix to use for the schedule name.\n\n    Returns:\n        idf (IDF): The IDF object with the day added.\n        day_name (str): The name of the day schedule.\n    \"\"\"\n    desired_name = self.Name\n    if name_prefix is not None:\n        desired_name = f\"{name_prefix}_DAY_{desired_name}\"\n\n    if idf.getobject(\"SCHEDULE:DAY:HOURLY\", desired_name):\n        return idf, desired_name\n\n    day_sched = ScheduleDayHourly(\n        Name=desired_name,\n        Schedule_Type_Limits_Name=self.Type,\n        Hour_1=self.Hour_00,\n        Hour_2=self.Hour_01,\n        Hour_3=self.Hour_02,\n        Hour_4=self.Hour_03,\n        Hour_5=self.Hour_04,\n        Hour_6=self.Hour_05,\n        Hour_7=self.Hour_06,\n        Hour_8=self.Hour_07,\n        Hour_9=self.Hour_08,\n        Hour_10=self.Hour_09,\n        Hour_11=self.Hour_10,\n        Hour_12=self.Hour_11,\n        Hour_13=self.Hour_12,\n        Hour_14=self.Hour_13,\n        Hour_15=self.Hour_14,\n        Hour_16=self.Hour_15,\n        Hour_17=self.Hour_16,\n        Hour_18=self.Hour_17,\n        Hour_19=self.Hour_18,\n        Hour_20=self.Hour_19,\n        Hour_21=self.Hour_20,\n        Hour_22=self.Hour_21,\n        Hour_23=self.Hour_22,\n        Hour_24=self.Hour_23,\n    )\n    idf = day_sched.add(idf)\n    return idf, day_sched.Name\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.DayComponent.validate_values","title":"<code>validate_values()</code>","text":"<p>Validate the values of the day are consistent with the schedule type limit.</p> Source code in <code>epinterface/sbem/components/schedules.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_values(self):\n    \"\"\"Validate the values of the day are consistent with the schedule type limit.\"\"\"\n    # TODO: Implement with a eye for Archetypal\n\n    lim_low = TypeLimits[self.Type].Lower_Limit_Value\n    lim_high = TypeLimits[self.Type].Upper_Limit_Value\n    if lim_low is not None and any(v &lt; lim_low for v in self.Values):\n        msg = f\"Values are less than the lower limit: {lim_low}\"\n        raise ValueError(msg)\n    if lim_high is not None and any(v &gt; lim_high for v in self.Values):\n        msg = f\"Values are greater than the upper limit: {lim_high}\"\n        raise ValueError(msg)\n    return self\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.WeekComponent","title":"<code>WeekComponent</code>","text":"<p>               Bases: <code>NamedObject</code></p> <p>A week with a list of days.</p> Source code in <code>epinterface/sbem/components/schedules.py</code> <pre><code>class WeekComponent(NamedObject, extra=\"forbid\"):\n    \"\"\"A week with a list of days.\"\"\"\n\n    Monday: DayComponent\n    Tuesday: DayComponent\n    Wednesday: DayComponent\n    Thursday: DayComponent\n    Friday: DayComponent\n    Saturday: DayComponent\n    Sunday: DayComponent\n\n    @model_validator(mode=\"after\")\n    def validate_type_limits_are_consistent(self):\n        \"\"\"Validate that the type limits are consistent.\"\"\"\n        lim = self.Monday.Type\n        for day in self.Days:\n            if day.Type != lim:\n                msg = \"Type limits are not consistent\"\n                raise ValueError(msg)\n        return self\n\n    @property\n    def bounds(self) -&gt; tuple[float, float]:\n        \"\"\"Get the bounds of the week.\"\"\"\n        lows = [day.bounds[0] for day in self.Days]\n        highs = [day.bounds[1] for day in self.Days]\n        return min(lows), max(highs)\n\n    @property\n    def AverageValue(self) -&gt; float:\n        \"\"\"Get the average value of the week.\"\"\"\n        return sum(day.AverageValue for day in self.Days) / len(self.Days)\n\n    @property\n    def Days(self) -&gt; list[DayComponent]:\n        \"\"\"Get the days of the week as a list.\"\"\"\n        return [\n            self.Monday,\n            self.Tuesday,\n            self.Wednesday,\n            self.Thursday,\n            self.Friday,\n            self.Saturday,\n            self.Sunday,\n        ]\n\n    def add_week_to_idf(\n        self,\n        idf: IDF,\n        name_prefix: str | None,\n        summer_design_day_sch_name: str | None = None,\n        winter_design_day_sch_name: str | None = None,\n    ) -&gt; tuple[IDF, str]:\n        \"\"\"Add the week to the IDF.\n\n        The name prefix can be used to scope the schedule creation to ensure a unique schedule per object.\n\n        Args:\n            idf (IDF): The IDF object to add the week to.\n            name_prefix (str | None): The prefix to use for the schedule name.\n            summer_design_day_sch_name (str | None): The name of the summer design day schedule.\n            winter_design_day_sch_name (str | None): The name of the winter design day schedule.\n\n        Returns:\n            idf (IDF): The IDF object with the week added.\n            week_name (str): The name of the week schedule.\n        \"\"\"\n        desired_name = self.Name\n        if name_prefix is not None:\n            desired_name = f\"{name_prefix}_WEEK_{desired_name}\"\n\n        if idf.getobject(\"SCHEDULE:WEEK:DAILY\", desired_name):\n            return idf, desired_name\n\n        idf, monday_name = self.Monday.add_day_to_idf(idf, name_prefix)\n        idf, tuesday_name = self.Tuesday.add_day_to_idf(idf, name_prefix)\n        idf, wednesday_name = self.Wednesday.add_day_to_idf(idf, name_prefix)\n        idf, thursday_name = self.Thursday.add_day_to_idf(idf, name_prefix)\n        idf, friday_name = self.Friday.add_day_to_idf(idf, name_prefix)\n        idf, saturday_name = self.Saturday.add_day_to_idf(idf, name_prefix)\n        idf, sunday_name = self.Sunday.add_day_to_idf(idf, name_prefix)\n        week_sched = ScheduleWeekDaily(\n            Name=desired_name,\n            Monday_ScheduleDay_Name=monday_name,\n            Tuesday_ScheduleDay_Name=tuesday_name,\n            Wednesday_ScheduleDay_Name=wednesday_name,\n            Thursday_ScheduleDay_Name=thursday_name,\n            Friday_ScheduleDay_Name=friday_name,\n            Saturday_ScheduleDay_Name=saturday_name,\n            Sunday_ScheduleDay_Name=sunday_name,\n            SummerDesignDay_ScheduleDay_Name=summer_design_day_sch_name,\n            WinterDesignDay_ScheduleDay_Name=winter_design_day_sch_name,\n        )\n        idf = week_sched.add(idf)\n        return idf, week_sched.Name\n\n    @property\n    def Type(self) -&gt; ScheduleTypeLimitType:\n        \"\"\"Get the type limit of the week.\"\"\"\n        return self.Monday.Type\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.WeekComponent.AverageValue","title":"<code>AverageValue</code>  <code>property</code>","text":"<p>Get the average value of the week.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.WeekComponent.Days","title":"<code>Days</code>  <code>property</code>","text":"<p>Get the days of the week as a list.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.WeekComponent.Type","title":"<code>Type</code>  <code>property</code>","text":"<p>Get the type limit of the week.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.WeekComponent.bounds","title":"<code>bounds</code>  <code>property</code>","text":"<p>Get the bounds of the week.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.WeekComponent.add_week_to_idf","title":"<code>add_week_to_idf(idf, name_prefix, summer_design_day_sch_name=None, winter_design_day_sch_name=None)</code>","text":"<p>Add the week to the IDF.</p> <p>The name prefix can be used to scope the schedule creation to ensure a unique schedule per object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the week to.</p> required <code>name_prefix</code> <code>str | None</code> <p>The prefix to use for the schedule name.</p> required <code>summer_design_day_sch_name</code> <code>str | None</code> <p>The name of the summer design day schedule.</p> <code>None</code> <code>winter_design_day_sch_name</code> <code>str | None</code> <p>The name of the winter design day schedule.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The IDF object with the week added.</p> <code>week_name</code> <code>str</code> <p>The name of the week schedule.</p> Source code in <code>epinterface/sbem/components/schedules.py</code> <pre><code>def add_week_to_idf(\n    self,\n    idf: IDF,\n    name_prefix: str | None,\n    summer_design_day_sch_name: str | None = None,\n    winter_design_day_sch_name: str | None = None,\n) -&gt; tuple[IDF, str]:\n    \"\"\"Add the week to the IDF.\n\n    The name prefix can be used to scope the schedule creation to ensure a unique schedule per object.\n\n    Args:\n        idf (IDF): The IDF object to add the week to.\n        name_prefix (str | None): The prefix to use for the schedule name.\n        summer_design_day_sch_name (str | None): The name of the summer design day schedule.\n        winter_design_day_sch_name (str | None): The name of the winter design day schedule.\n\n    Returns:\n        idf (IDF): The IDF object with the week added.\n        week_name (str): The name of the week schedule.\n    \"\"\"\n    desired_name = self.Name\n    if name_prefix is not None:\n        desired_name = f\"{name_prefix}_WEEK_{desired_name}\"\n\n    if idf.getobject(\"SCHEDULE:WEEK:DAILY\", desired_name):\n        return idf, desired_name\n\n    idf, monday_name = self.Monday.add_day_to_idf(idf, name_prefix)\n    idf, tuesday_name = self.Tuesday.add_day_to_idf(idf, name_prefix)\n    idf, wednesday_name = self.Wednesday.add_day_to_idf(idf, name_prefix)\n    idf, thursday_name = self.Thursday.add_day_to_idf(idf, name_prefix)\n    idf, friday_name = self.Friday.add_day_to_idf(idf, name_prefix)\n    idf, saturday_name = self.Saturday.add_day_to_idf(idf, name_prefix)\n    idf, sunday_name = self.Sunday.add_day_to_idf(idf, name_prefix)\n    week_sched = ScheduleWeekDaily(\n        Name=desired_name,\n        Monday_ScheduleDay_Name=monday_name,\n        Tuesday_ScheduleDay_Name=tuesday_name,\n        Wednesday_ScheduleDay_Name=wednesday_name,\n        Thursday_ScheduleDay_Name=thursday_name,\n        Friday_ScheduleDay_Name=friday_name,\n        Saturday_ScheduleDay_Name=saturday_name,\n        Sunday_ScheduleDay_Name=sunday_name,\n        SummerDesignDay_ScheduleDay_Name=summer_design_day_sch_name,\n        WinterDesignDay_ScheduleDay_Name=winter_design_day_sch_name,\n    )\n    idf = week_sched.add(idf)\n    return idf, week_sched.Name\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.WeekComponent.validate_type_limits_are_consistent","title":"<code>validate_type_limits_are_consistent()</code>","text":"<p>Validate that the type limits are consistent.</p> Source code in <code>epinterface/sbem/components/schedules.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_type_limits_are_consistent(self):\n    \"\"\"Validate that the type limits are consistent.\"\"\"\n    lim = self.Monday.Type\n    for day in self.Days:\n        if day.Type != lim:\n            msg = \"Type limits are not consistent\"\n            raise ValueError(msg)\n    return self\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.YearComponent","title":"<code>YearComponent</code>","text":"<p>               Bases: <code>NamedObject</code></p> <p>A year with a schedule type limit and a list of repeated weeks.</p> Source code in <code>epinterface/sbem/components/schedules.py</code> <pre><code>class YearComponent(NamedObject, extra=\"forbid\"):\n    \"\"\"A year with a schedule type limit and a list of repeated weeks.\"\"\"\n\n    Type: YearScheduleCategory = Field(\n        ..., description=\"The system that the schedule is applicable to.\"\n    )\n    January: WeekComponent\n    February: WeekComponent\n    March: WeekComponent\n    April: WeekComponent\n    May: WeekComponent\n    June: WeekComponent\n    July: WeekComponent\n    August: WeekComponent\n    September: WeekComponent\n    October: WeekComponent\n    November: WeekComponent\n    December: WeekComponent\n\n    @property\n    def AverageValue(self) -&gt; float:\n        \"\"\"Get the average value of the year.\"\"\"\n        return sum(week.AverageValue for week in self.Weeks) / len(self.Weeks)\n\n    @property\n    def MonthlyAverageValues(self) -&gt; list[float]:\n        \"\"\"Get the average values of the year.\"\"\"\n        return [week.AverageValue for week in self.Weeks]\n\n    @property\n    def bounds(self) -&gt; tuple[float, float]:\n        \"\"\"Get the bounds of the year.\"\"\"\n        lows = [week.bounds[0] for week in self.Weeks]\n        highs = [week.bounds[1] for week in self.Weeks]\n        return min(lows), max(highs)\n\n    @property\n    def Weeks(self) -&gt; list[WeekComponent]:\n        \"\"\"Get the weeks of the year as a list.\"\"\"\n        return [\n            self.January,\n            self.February,\n            self.March,\n            self.April,\n            self.May,\n            self.June,\n            self.July,\n            self.August,\n            self.September,\n            self.October,\n            self.November,\n            self.December,\n        ]\n\n    @model_validator(mode=\"after\")\n    def check_weeks_have_consistent_type(self):\n        \"\"\"Check that the weeks have a consistent type.\"\"\"\n        lim = self.January.Type\n        for week in self.Weeks:\n            if week.Type != lim:\n                msg = \"Type limits are not consistent\"\n                raise ValueError(msg)\n\n        return self\n\n    @property\n    def schedule_type_limits(self):\n        \"\"\"Get the schedule type limits for the year.\"\"\"\n        return self.January.Type\n\n    def add_year_to_idf(\n        self,\n        idf: IDF,\n        name_prefix: str | None = None,\n        summer_design_day_sch_name: str | None = None,\n        winter_design_day_sch_name: str | None = None,\n    ):\n        \"\"\"Add the year to the IDF.\n\n        The name prefix can be used to scope the schedule creation to ensure a unique schedule per object.\n\n        Args:\n            idf (IDF): The IDF object to add the year to.\n            name_prefix (str | None): The prefix to use for the schedule name.\n            summer_design_day_sch_name (str | None): The name of the summer design day schedule.\n            winter_design_day_sch_name (str | None): The name of the winter design day schedule.\n\n        Returns:\n            idf (IDF): The IDF object with the year added.\n            year_name (str): The name of the year schedule.\n        \"\"\"\n        desired_name = self.Name\n        if name_prefix is not None:\n            desired_name = f\"{name_prefix}_YEAR_{desired_name}\"\n\n        if idf.getobject(\"SCHEDULE:YEAR\", desired_name):\n            return idf, desired_name\n\n        idf, jan_name = self.January.add_week_to_idf(\n            idf,\n            name_prefix,\n            summer_design_day_sch_name=summer_design_day_sch_name,\n            winter_design_day_sch_name=winter_design_day_sch_name,\n        )\n        idf, feb_name = self.February.add_week_to_idf(\n            idf,\n            name_prefix,\n            summer_design_day_sch_name=summer_design_day_sch_name,\n            winter_design_day_sch_name=winter_design_day_sch_name,\n        )\n        idf, mar_name = self.March.add_week_to_idf(\n            idf,\n            name_prefix,\n            summer_design_day_sch_name=summer_design_day_sch_name,\n            winter_design_day_sch_name=winter_design_day_sch_name,\n        )\n        idf, apr_name = self.April.add_week_to_idf(\n            idf,\n            name_prefix,\n            summer_design_day_sch_name=summer_design_day_sch_name,\n            winter_design_day_sch_name=winter_design_day_sch_name,\n        )\n        idf, may_name = self.May.add_week_to_idf(\n            idf,\n            name_prefix,\n            summer_design_day_sch_name=summer_design_day_sch_name,\n            winter_design_day_sch_name=winter_design_day_sch_name,\n        )\n        idf, jun_name = self.June.add_week_to_idf(\n            idf,\n            name_prefix,\n            summer_design_day_sch_name=summer_design_day_sch_name,\n            winter_design_day_sch_name=winter_design_day_sch_name,\n        )\n        idf, jul_name = self.July.add_week_to_idf(\n            idf,\n            name_prefix,\n            summer_design_day_sch_name=summer_design_day_sch_name,\n            winter_design_day_sch_name=winter_design_day_sch_name,\n        )\n        idf, aug_name = self.August.add_week_to_idf(\n            idf,\n            name_prefix,\n            summer_design_day_sch_name=summer_design_day_sch_name,\n            winter_design_day_sch_name=winter_design_day_sch_name,\n        )\n        idf, sep_name = self.September.add_week_to_idf(\n            idf,\n            name_prefix,\n            summer_design_day_sch_name=summer_design_day_sch_name,\n            winter_design_day_sch_name=winter_design_day_sch_name,\n        )\n        idf, oct_name = self.October.add_week_to_idf(\n            idf,\n            name_prefix,\n            summer_design_day_sch_name=summer_design_day_sch_name,\n            winter_design_day_sch_name=winter_design_day_sch_name,\n        )\n        idf, nov_name = self.November.add_week_to_idf(\n            idf,\n            name_prefix,\n            summer_design_day_sch_name=summer_design_day_sch_name,\n            winter_design_day_sch_name=winter_design_day_sch_name,\n        )\n        idf, dec_name = self.December.add_week_to_idf(\n            idf,\n            name_prefix,\n            summer_design_day_sch_name=summer_design_day_sch_name,\n            winter_design_day_sch_name=winter_design_day_sch_name,\n        )\n        year_sched = ScheduleYear(\n            Name=self.Name,\n            Schedule_Type_Limits_Name=self.schedule_type_limits,\n            ScheduleWeek_Name_1=jan_name,\n            Start_Month_1=1,\n            Start_Day_1=1,\n            End_Month_1=1,\n            End_Day_1=31,\n            ScheduleWeek_Name_2=feb_name,\n            Start_Month_2=2,\n            Start_Day_2=1,\n            End_Month_2=2,\n            End_Day_2=28,\n            ScheduleWeek_Name_3=mar_name,\n            Start_Month_3=3,\n            Start_Day_3=1,\n            End_Month_3=3,\n            End_Day_3=31,\n            ScheduleWeek_Name_4=apr_name,\n            Start_Month_4=4,\n            Start_Day_4=1,\n            End_Month_4=4,\n            End_Day_4=30,\n            ScheduleWeek_Name_5=may_name,\n            Start_Month_5=5,\n            Start_Day_5=1,\n            End_Month_5=5,\n            End_Day_5=31,\n            ScheduleWeek_Name_6=jun_name,\n            Start_Month_6=6,\n            Start_Day_6=1,\n            End_Month_6=6,\n            End_Day_6=30,\n            ScheduleWeek_Name_7=jul_name,\n            Start_Month_7=7,\n            Start_Day_7=1,\n            End_Month_7=7,\n            End_Day_7=31,\n            ScheduleWeek_Name_8=aug_name,\n            Start_Month_8=8,\n            Start_Day_8=1,\n            End_Month_8=8,\n            End_Day_8=31,\n            ScheduleWeek_Name_9=sep_name,\n            Start_Month_9=9,\n            Start_Day_9=1,\n            End_Month_9=9,\n            End_Day_9=30,\n            ScheduleWeek_Name_10=oct_name,\n            Start_Month_10=10,\n            Start_Day_10=1,\n            End_Month_10=10,\n            End_Day_10=31,\n            ScheduleWeek_Name_11=nov_name,\n            Start_Month_11=11,\n            Start_Day_11=1,\n            End_Month_11=11,\n            End_Day_11=30,\n            ScheduleWeek_Name_12=dec_name,\n            Start_Month_12=12,\n            Start_Day_12=1,\n            End_Month_12=12,\n            End_Day_12=31,\n        )\n        idf = year_sched.add(idf)\n\n        type_lim = self.schedule_type_limits\n        if not idf.getobject(\"SCHEDULETYPELIMITS\", type_lim):\n            if type_lim not in TypeLimits:\n                msg = f\"Type {type_lim} not in TypeLimits, unsure how to add to IDF.\"\n                raise ValueError(msg)\n            lim = TypeLimits[type_lim]\n            lim.add(idf)\n\n        return idf, year_sched.Name\n\n    def fractional_year_sum(self, year: int):\n        \"\"\"Compute the sum of the year as a fraction of the year.\"\"\"\n        if self.schedule_type_limits != \"Fraction\":\n            msg = \"Schedule type limits are not Fraction, cannot compute year sum.\"\n            raise ValueError(msg)\n\n        # get the numer of Mondays in each month, tuesdays in each month, etc.\n\n        def get_num_days_in_month(\n            month: Literal[\n                \"January\",\n                \"February\",\n                \"March\",\n                \"April\",\n                \"May\",\n                \"June\",\n                \"July\",\n                \"August\",\n                \"September\",\n                \"October\",\n                \"November\",\n                \"December\",\n            ],\n            year: int,\n            day_of_week: Literal[\n                \"Monday\",\n                \"Tuesday\",\n                \"Wednesday\",\n                \"Thursday\",\n                \"Friday\",\n                \"Saturday\",\n                \"Sunday\",\n            ],\n        ):\n            \"\"\"Get the number of days in a month for a given year and day of the week.\"\"\"\n            # get the number of days in the month\n            month_map = {\n                \"January\": 1,\n                \"February\": 2,\n                \"March\": 3,\n                \"April\": 4,\n                \"May\": 5,\n                \"June\": 6,\n                \"July\": 7,\n                \"August\": 8,\n                \"September\": 9,\n                \"October\": 10,\n                \"November\": 11,\n                \"December\": 12,\n            }\n            _weekday, num_days = calendar.monthrange(year, month_map[month])\n\n            # get the number of days of the week in the month\n            days_of_week = [calendar.day_name[(day + 1) % 7] for day in range(num_days)]\n            return days_of_week.count(day_of_week)\n\n        # get the number of Mondays in each month\n        months: list[\n            Literal[\n                \"January\",\n                \"February\",\n                \"March\",\n                \"April\",\n                \"May\",\n                \"June\",\n                \"July\",\n                \"August\",\n                \"September\",\n                \"October\",\n                \"November\",\n                \"December\",\n            ]\n        ] = [\n            \"January\",\n            \"February\",\n            \"March\",\n            \"April\",\n            \"May\",\n            \"June\",\n            \"July\",\n            \"August\",\n            \"September\",\n            \"October\",\n            \"November\",\n            \"December\",\n        ]\n        num_mondays = [get_num_days_in_month(month, year, \"Monday\") for month in months]\n        num_tuesdays = [\n            get_num_days_in_month(month, year, \"Tuesday\") for month in months\n        ]\n        num_wednesdays = [\n            get_num_days_in_month(month, year, \"Wednesday\") for month in months\n        ]\n        num_thursdays = [\n            get_num_days_in_month(month, year, \"Thursday\") for month in months\n        ]\n        num_fridays = [get_num_days_in_month(month, year, \"Friday\") for month in months]\n        num_saturdays = [\n            get_num_days_in_month(month, year, \"Saturday\") for month in months\n        ]\n        num_sundays = [get_num_days_in_month(month, year, \"Sunday\") for month in months]\n\n        monday_sums = [\n            sum(getattr(self, month).Monday.Values) * num_days\n            for month, num_days in zip(months, num_mondays, strict=True)\n        ]\n        tuesday_sums = [\n            sum(getattr(self, month).Tuesday.Values) * num_days\n            for month, num_days in zip(months, num_tuesdays, strict=True)\n        ]\n        wednesday_sums = [\n            sum(getattr(self, month).Wednesday.Values) * num_days\n            for month, num_days in zip(months, num_wednesdays, strict=True)\n        ]\n        thursday_sums = [\n            sum(getattr(self, month).Thursday.Values) * num_days\n            for month, num_days in zip(months, num_thursdays, strict=True)\n        ]\n        friday_sums = [\n            sum(getattr(self, month).Friday.Values) * num_days\n            for month, num_days in zip(months, num_fridays, strict=True)\n        ]\n        saturday_sums = [\n            sum(getattr(self, month).Saturday.Values) * num_days\n            for month, num_days in zip(months, num_saturdays, strict=True)\n        ]\n        sunday_sums = [\n            sum(getattr(self, month).Sunday.Values) * num_days\n            for month, num_days in zip(months, num_sundays, strict=True)\n        ]\n\n        monday_sum = sum(monday_sums)\n        tuesday_sum = sum(tuesday_sums)\n        wednesday_sum = sum(wednesday_sums)\n        thursday_sum = sum(thursday_sums)\n        friday_sum = sum(friday_sums)\n        saturday_sum = sum(saturday_sums)\n        sunday_sum = sum(sunday_sums)\n\n        annual_sum = (\n            monday_sum\n            + tuesday_sum\n            + wednesday_sum\n            + thursday_sum\n            + friday_sum\n            + saturday_sum\n            + sunday_sum\n        )\n        days_in_year = calendar.isleap(year) * 366 + (1 - calendar.isleap(year)) * 365\n\n        return annual_sum / (days_in_year * 24)\n\n    @field_validator(\"Name\")\n    def validate_name(cls, v):\n        \"\"\"Validate the name of the schedule, specifically that it cannot be a protected name.\"\"\"\n        if v in PROTECTED_SCHEDULE_NAMES or \"Activity_Schedule\" in v:\n            msg = f\"Schedule name {v} is protected, please choose another name.\"\n            raise ValueError(msg)\n        return v\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.YearComponent.AverageValue","title":"<code>AverageValue</code>  <code>property</code>","text":"<p>Get the average value of the year.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.YearComponent.MonthlyAverageValues","title":"<code>MonthlyAverageValues</code>  <code>property</code>","text":"<p>Get the average values of the year.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.YearComponent.Weeks","title":"<code>Weeks</code>  <code>property</code>","text":"<p>Get the weeks of the year as a list.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.YearComponent.bounds","title":"<code>bounds</code>  <code>property</code>","text":"<p>Get the bounds of the year.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.YearComponent.schedule_type_limits","title":"<code>schedule_type_limits</code>  <code>property</code>","text":"<p>Get the schedule type limits for the year.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.YearComponent.add_year_to_idf","title":"<code>add_year_to_idf(idf, name_prefix=None, summer_design_day_sch_name=None, winter_design_day_sch_name=None)</code>","text":"<p>Add the year to the IDF.</p> <p>The name prefix can be used to scope the schedule creation to ensure a unique schedule per object.</p> <p>Parameters:</p> Name Type Description Default <code>idf</code> <code>IDF</code> <p>The IDF object to add the year to.</p> required <code>name_prefix</code> <code>str | None</code> <p>The prefix to use for the schedule name.</p> <code>None</code> <code>summer_design_day_sch_name</code> <code>str | None</code> <p>The name of the summer design day schedule.</p> <code>None</code> <code>winter_design_day_sch_name</code> <code>str | None</code> <p>The name of the winter design day schedule.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>idf</code> <code>IDF</code> <p>The IDF object with the year added.</p> <code>year_name</code> <code>str</code> <p>The name of the year schedule.</p> Source code in <code>epinterface/sbem/components/schedules.py</code> <pre><code>def add_year_to_idf(\n    self,\n    idf: IDF,\n    name_prefix: str | None = None,\n    summer_design_day_sch_name: str | None = None,\n    winter_design_day_sch_name: str | None = None,\n):\n    \"\"\"Add the year to the IDF.\n\n    The name prefix can be used to scope the schedule creation to ensure a unique schedule per object.\n\n    Args:\n        idf (IDF): The IDF object to add the year to.\n        name_prefix (str | None): The prefix to use for the schedule name.\n        summer_design_day_sch_name (str | None): The name of the summer design day schedule.\n        winter_design_day_sch_name (str | None): The name of the winter design day schedule.\n\n    Returns:\n        idf (IDF): The IDF object with the year added.\n        year_name (str): The name of the year schedule.\n    \"\"\"\n    desired_name = self.Name\n    if name_prefix is not None:\n        desired_name = f\"{name_prefix}_YEAR_{desired_name}\"\n\n    if idf.getobject(\"SCHEDULE:YEAR\", desired_name):\n        return idf, desired_name\n\n    idf, jan_name = self.January.add_week_to_idf(\n        idf,\n        name_prefix,\n        summer_design_day_sch_name=summer_design_day_sch_name,\n        winter_design_day_sch_name=winter_design_day_sch_name,\n    )\n    idf, feb_name = self.February.add_week_to_idf(\n        idf,\n        name_prefix,\n        summer_design_day_sch_name=summer_design_day_sch_name,\n        winter_design_day_sch_name=winter_design_day_sch_name,\n    )\n    idf, mar_name = self.March.add_week_to_idf(\n        idf,\n        name_prefix,\n        summer_design_day_sch_name=summer_design_day_sch_name,\n        winter_design_day_sch_name=winter_design_day_sch_name,\n    )\n    idf, apr_name = self.April.add_week_to_idf(\n        idf,\n        name_prefix,\n        summer_design_day_sch_name=summer_design_day_sch_name,\n        winter_design_day_sch_name=winter_design_day_sch_name,\n    )\n    idf, may_name = self.May.add_week_to_idf(\n        idf,\n        name_prefix,\n        summer_design_day_sch_name=summer_design_day_sch_name,\n        winter_design_day_sch_name=winter_design_day_sch_name,\n    )\n    idf, jun_name = self.June.add_week_to_idf(\n        idf,\n        name_prefix,\n        summer_design_day_sch_name=summer_design_day_sch_name,\n        winter_design_day_sch_name=winter_design_day_sch_name,\n    )\n    idf, jul_name = self.July.add_week_to_idf(\n        idf,\n        name_prefix,\n        summer_design_day_sch_name=summer_design_day_sch_name,\n        winter_design_day_sch_name=winter_design_day_sch_name,\n    )\n    idf, aug_name = self.August.add_week_to_idf(\n        idf,\n        name_prefix,\n        summer_design_day_sch_name=summer_design_day_sch_name,\n        winter_design_day_sch_name=winter_design_day_sch_name,\n    )\n    idf, sep_name = self.September.add_week_to_idf(\n        idf,\n        name_prefix,\n        summer_design_day_sch_name=summer_design_day_sch_name,\n        winter_design_day_sch_name=winter_design_day_sch_name,\n    )\n    idf, oct_name = self.October.add_week_to_idf(\n        idf,\n        name_prefix,\n        summer_design_day_sch_name=summer_design_day_sch_name,\n        winter_design_day_sch_name=winter_design_day_sch_name,\n    )\n    idf, nov_name = self.November.add_week_to_idf(\n        idf,\n        name_prefix,\n        summer_design_day_sch_name=summer_design_day_sch_name,\n        winter_design_day_sch_name=winter_design_day_sch_name,\n    )\n    idf, dec_name = self.December.add_week_to_idf(\n        idf,\n        name_prefix,\n        summer_design_day_sch_name=summer_design_day_sch_name,\n        winter_design_day_sch_name=winter_design_day_sch_name,\n    )\n    year_sched = ScheduleYear(\n        Name=self.Name,\n        Schedule_Type_Limits_Name=self.schedule_type_limits,\n        ScheduleWeek_Name_1=jan_name,\n        Start_Month_1=1,\n        Start_Day_1=1,\n        End_Month_1=1,\n        End_Day_1=31,\n        ScheduleWeek_Name_2=feb_name,\n        Start_Month_2=2,\n        Start_Day_2=1,\n        End_Month_2=2,\n        End_Day_2=28,\n        ScheduleWeek_Name_3=mar_name,\n        Start_Month_3=3,\n        Start_Day_3=1,\n        End_Month_3=3,\n        End_Day_3=31,\n        ScheduleWeek_Name_4=apr_name,\n        Start_Month_4=4,\n        Start_Day_4=1,\n        End_Month_4=4,\n        End_Day_4=30,\n        ScheduleWeek_Name_5=may_name,\n        Start_Month_5=5,\n        Start_Day_5=1,\n        End_Month_5=5,\n        End_Day_5=31,\n        ScheduleWeek_Name_6=jun_name,\n        Start_Month_6=6,\n        Start_Day_6=1,\n        End_Month_6=6,\n        End_Day_6=30,\n        ScheduleWeek_Name_7=jul_name,\n        Start_Month_7=7,\n        Start_Day_7=1,\n        End_Month_7=7,\n        End_Day_7=31,\n        ScheduleWeek_Name_8=aug_name,\n        Start_Month_8=8,\n        Start_Day_8=1,\n        End_Month_8=8,\n        End_Day_8=31,\n        ScheduleWeek_Name_9=sep_name,\n        Start_Month_9=9,\n        Start_Day_9=1,\n        End_Month_9=9,\n        End_Day_9=30,\n        ScheduleWeek_Name_10=oct_name,\n        Start_Month_10=10,\n        Start_Day_10=1,\n        End_Month_10=10,\n        End_Day_10=31,\n        ScheduleWeek_Name_11=nov_name,\n        Start_Month_11=11,\n        Start_Day_11=1,\n        End_Month_11=11,\n        End_Day_11=30,\n        ScheduleWeek_Name_12=dec_name,\n        Start_Month_12=12,\n        Start_Day_12=1,\n        End_Month_12=12,\n        End_Day_12=31,\n    )\n    idf = year_sched.add(idf)\n\n    type_lim = self.schedule_type_limits\n    if not idf.getobject(\"SCHEDULETYPELIMITS\", type_lim):\n        if type_lim not in TypeLimits:\n            msg = f\"Type {type_lim} not in TypeLimits, unsure how to add to IDF.\"\n            raise ValueError(msg)\n        lim = TypeLimits[type_lim]\n        lim.add(idf)\n\n    return idf, year_sched.Name\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.YearComponent.check_weeks_have_consistent_type","title":"<code>check_weeks_have_consistent_type()</code>","text":"<p>Check that the weeks have a consistent type.</p> Source code in <code>epinterface/sbem/components/schedules.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_weeks_have_consistent_type(self):\n    \"\"\"Check that the weeks have a consistent type.\"\"\"\n    lim = self.January.Type\n    for week in self.Weeks:\n        if week.Type != lim:\n            msg = \"Type limits are not consistent\"\n            raise ValueError(msg)\n\n    return self\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.YearComponent.fractional_year_sum","title":"<code>fractional_year_sum(year)</code>","text":"<p>Compute the sum of the year as a fraction of the year.</p> Source code in <code>epinterface/sbem/components/schedules.py</code> <pre><code>def fractional_year_sum(self, year: int):\n    \"\"\"Compute the sum of the year as a fraction of the year.\"\"\"\n    if self.schedule_type_limits != \"Fraction\":\n        msg = \"Schedule type limits are not Fraction, cannot compute year sum.\"\n        raise ValueError(msg)\n\n    # get the numer of Mondays in each month, tuesdays in each month, etc.\n\n    def get_num_days_in_month(\n        month: Literal[\n            \"January\",\n            \"February\",\n            \"March\",\n            \"April\",\n            \"May\",\n            \"June\",\n            \"July\",\n            \"August\",\n            \"September\",\n            \"October\",\n            \"November\",\n            \"December\",\n        ],\n        year: int,\n        day_of_week: Literal[\n            \"Monday\",\n            \"Tuesday\",\n            \"Wednesday\",\n            \"Thursday\",\n            \"Friday\",\n            \"Saturday\",\n            \"Sunday\",\n        ],\n    ):\n        \"\"\"Get the number of days in a month for a given year and day of the week.\"\"\"\n        # get the number of days in the month\n        month_map = {\n            \"January\": 1,\n            \"February\": 2,\n            \"March\": 3,\n            \"April\": 4,\n            \"May\": 5,\n            \"June\": 6,\n            \"July\": 7,\n            \"August\": 8,\n            \"September\": 9,\n            \"October\": 10,\n            \"November\": 11,\n            \"December\": 12,\n        }\n        _weekday, num_days = calendar.monthrange(year, month_map[month])\n\n        # get the number of days of the week in the month\n        days_of_week = [calendar.day_name[(day + 1) % 7] for day in range(num_days)]\n        return days_of_week.count(day_of_week)\n\n    # get the number of Mondays in each month\n    months: list[\n        Literal[\n            \"January\",\n            \"February\",\n            \"March\",\n            \"April\",\n            \"May\",\n            \"June\",\n            \"July\",\n            \"August\",\n            \"September\",\n            \"October\",\n            \"November\",\n            \"December\",\n        ]\n    ] = [\n        \"January\",\n        \"February\",\n        \"March\",\n        \"April\",\n        \"May\",\n        \"June\",\n        \"July\",\n        \"August\",\n        \"September\",\n        \"October\",\n        \"November\",\n        \"December\",\n    ]\n    num_mondays = [get_num_days_in_month(month, year, \"Monday\") for month in months]\n    num_tuesdays = [\n        get_num_days_in_month(month, year, \"Tuesday\") for month in months\n    ]\n    num_wednesdays = [\n        get_num_days_in_month(month, year, \"Wednesday\") for month in months\n    ]\n    num_thursdays = [\n        get_num_days_in_month(month, year, \"Thursday\") for month in months\n    ]\n    num_fridays = [get_num_days_in_month(month, year, \"Friday\") for month in months]\n    num_saturdays = [\n        get_num_days_in_month(month, year, \"Saturday\") for month in months\n    ]\n    num_sundays = [get_num_days_in_month(month, year, \"Sunday\") for month in months]\n\n    monday_sums = [\n        sum(getattr(self, month).Monday.Values) * num_days\n        for month, num_days in zip(months, num_mondays, strict=True)\n    ]\n    tuesday_sums = [\n        sum(getattr(self, month).Tuesday.Values) * num_days\n        for month, num_days in zip(months, num_tuesdays, strict=True)\n    ]\n    wednesday_sums = [\n        sum(getattr(self, month).Wednesday.Values) * num_days\n        for month, num_days in zip(months, num_wednesdays, strict=True)\n    ]\n    thursday_sums = [\n        sum(getattr(self, month).Thursday.Values) * num_days\n        for month, num_days in zip(months, num_thursdays, strict=True)\n    ]\n    friday_sums = [\n        sum(getattr(self, month).Friday.Values) * num_days\n        for month, num_days in zip(months, num_fridays, strict=True)\n    ]\n    saturday_sums = [\n        sum(getattr(self, month).Saturday.Values) * num_days\n        for month, num_days in zip(months, num_saturdays, strict=True)\n    ]\n    sunday_sums = [\n        sum(getattr(self, month).Sunday.Values) * num_days\n        for month, num_days in zip(months, num_sundays, strict=True)\n    ]\n\n    monday_sum = sum(monday_sums)\n    tuesday_sum = sum(tuesday_sums)\n    wednesday_sum = sum(wednesday_sums)\n    thursday_sum = sum(thursday_sums)\n    friday_sum = sum(friday_sums)\n    saturday_sum = sum(saturday_sums)\n    sunday_sum = sum(sunday_sums)\n\n    annual_sum = (\n        monday_sum\n        + tuesday_sum\n        + wednesday_sum\n        + thursday_sum\n        + friday_sum\n        + saturday_sum\n        + sunday_sum\n    )\n    days_in_year = calendar.isleap(year) * 366 + (1 - calendar.isleap(year)) * 365\n\n    return annual_sum / (days_in_year * 24)\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.schedules.YearComponent.validate_name","title":"<code>validate_name(v)</code>","text":"<p>Validate the name of the schedule, specifically that it cannot be a protected name.</p> Source code in <code>epinterface/sbem/components/schedules.py</code> <pre><code>@field_validator(\"Name\")\ndef validate_name(cls, v):\n    \"\"\"Validate the name of the schedule, specifically that it cannot be a protected name.\"\"\"\n    if v in PROTECTED_SCHEDULE_NAMES or \"Activity_Schedule\" in v:\n        msg = f\"Schedule name {v} is protected, please choose another name.\"\n        raise ValueError(msg)\n    return v\n</code></pre>"},{"location":"modules/sbem/components/#zones","title":"Zones","text":"<p>Zone components.</p>"},{"location":"modules/sbem/components/#epinterface.sbem.components.zones.ZoneComponent","title":"<code>ZoneComponent</code>","text":"<p>               Bases: <code>NamedObject</code></p> <p>Zone definition.</p> Source code in <code>epinterface/sbem/components/zones.py</code> <pre><code>class ZoneComponent(NamedObject):\n    \"\"\"Zone definition.\"\"\"\n\n    Operations: ZoneOperationsComponent\n    Envelope: ZoneEnvelopeComponent\n\n    def add_to_idf_zone(self, idf: IDF, zone_name: str) -&gt; IDF:\n        \"\"\"Add the zone to the IDF.\"\"\"\n        # TODO: consider lifting up the individual loads since the pass through method here\n        # does not actually handle all of space use, given that it must synthesize\n        # DHW and Operations.SpaceUse.WaterUse\n        idf = self.Operations.SpaceUse.add_loads_to_idf_zone(idf, zone_name)\n        idf = self.Operations.add_water_use_to_idf_zone(idf, zone_name)\n        idf = self.Operations.add_conditioning_to_idf_zone(idf, zone_name)\n        idf = self.Envelope.Infiltration.add_infiltration_to_idf_zone(idf, zone_name)\n        return idf\n</code></pre>"},{"location":"modules/sbem/components/#epinterface.sbem.components.zones.ZoneComponent.add_to_idf_zone","title":"<code>add_to_idf_zone(idf, zone_name)</code>","text":"<p>Add the zone to the IDF.</p> Source code in <code>epinterface/sbem/components/zones.py</code> <pre><code>def add_to_idf_zone(self, idf: IDF, zone_name: str) -&gt; IDF:\n    \"\"\"Add the zone to the IDF.\"\"\"\n    # TODO: consider lifting up the individual loads since the pass through method here\n    # does not actually handle all of space use, given that it must synthesize\n    # DHW and Operations.SpaceUse.WaterUse\n    idf = self.Operations.SpaceUse.add_loads_to_idf_zone(idf, zone_name)\n    idf = self.Operations.add_water_use_to_idf_zone(idf, zone_name)\n    idf = self.Operations.add_conditioning_to_idf_zone(idf, zone_name)\n    idf = self.Envelope.Infiltration.add_infiltration_to_idf_zone(idf, zone_name)\n    return idf\n</code></pre>"},{"location":"modules/sbem/composer/","title":"Composer","text":"<p>A module for automatically fetching and composing SBEM objects.</p>"},{"location":"modules/sbem/composer/#epinterface.sbem.components.composer.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":"<p>Tree construction:</p> <p>Every node in the tree may or may not have a selector action specified. --&gt; If it is specified, then we will select the deep tree for the requested compounded key from the datasource.  There will be options for if the key is not found ( e.g. fallbacks or raises.) --&gt; if it is specified, it will be loaded before it's children, but it's children (may) overwrite if specified. --&gt; If it is not specified, then it's children must be specified to avoid construction failure.</p> <p>Branching: Handle node, then handle its children.</p> <p>Base case: Start at root node.</p>"},{"location":"modules/sbem/composer/#epinterface.sbem.components.composer.BaseResolutionTree","title":"<code>BaseResolutionTree</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A base class for Resolvers.</p> Source code in <code>epinterface/sbem/components/composer.py</code> <pre><code>class BaseResolutionTree(BaseModel):\n    \"\"\"A base class for Resolvers.\"\"\"\n</code></pre>"},{"location":"modules/sbem/composer/#epinterface.sbem.components.composer.ComponentNameConstructor","title":"<code>ComponentNameConstructor</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A constructor for the name of a component. based off of a list of source fields.</p> Source code in <code>epinterface/sbem/components/composer.py</code> <pre><code>class ComponentNameConstructor(BaseModel, extra=\"forbid\"):\n    \"\"\"A constructor for the name of a component. based off of a list of source fields.\"\"\"\n\n    source_fields: list[str] = Field(default_factory=list)\n    prefix: str | None = None\n    suffix: str | None = None\n\n    def construct_name(self, x: dict[str, Any]) -&gt; str:\n        \"\"\"Construct the name of a component based off of a dictionary of source fields.\"\"\"\n        for field in self.source_fields:\n            if field not in x:\n                # TODO: implement things like fallback values, e.g. if a field is not found, should we assume a value for that field?\n                # should we silently fail?\n                # should we warn? should we raise?\n                msg = f\"{field} is not in the source fields.\"\n                raise ValueError(msg)\n        core_name = \"_\".join(x[field] for field in self.source_fields)\n        if self.prefix is not None:\n            core_name = f\"{self.prefix}_{core_name}\"\n        if self.suffix is not None:\n            core_name = f\"{core_name}_{self.suffix}\"\n        return core_name\n</code></pre>"},{"location":"modules/sbem/composer/#epinterface.sbem.components.composer.ComponentNameConstructor.construct_name","title":"<code>construct_name(x)</code>","text":"<p>Construct the name of a component based off of a dictionary of source fields.</p> Source code in <code>epinterface/sbem/components/composer.py</code> <pre><code>def construct_name(self, x: dict[str, Any]) -&gt; str:\n    \"\"\"Construct the name of a component based off of a dictionary of source fields.\"\"\"\n    for field in self.source_fields:\n        if field not in x:\n            # TODO: implement things like fallback values, e.g. if a field is not found, should we assume a value for that field?\n            # should we silently fail?\n            # should we warn? should we raise?\n            msg = f\"{field} is not in the source fields.\"\n            raise ValueError(msg)\n    core_name = \"_\".join(x[field] for field in self.source_fields)\n    if self.prefix is not None:\n        core_name = f\"{self.prefix}_{core_name}\"\n    if self.suffix is not None:\n        core_name = f\"{core_name}_{self.suffix}\"\n    return core_name\n</code></pre>"},{"location":"modules/sbem/composer/#epinterface.sbem.components.composer.construct_composer_model","title":"<code>construct_composer_model(g, root_validator, use_children=True, extra_handling='forbid', allow_partials=True)</code>","text":"<p>Abstractly constructs a composition model from a graph of SBEM hierarchies.</p> <p>The ComposerModel.get_component(x: dict) method can be used to generate a composition of SBEM objects through the hierarchy, starting with the root node, and then substituting child nodes as they become available.</p> <p>Setting allow_partials to False will require a complete tree (but also use autopopulation) - this is mainly for easily generating schemas.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>DiGraph</code> <p>The graph to construct the model from.</p> required <code>root_validator</code> <code>type[NamedObject]</code> <p>The root validator type.</p> required <code>use_children</code> <code>bool</code> <p>Whether to use <code>children</code> nesting keys (more verbose structure)</p> <code>True</code> <code>extra_handling</code> <code>Literal['ignore', 'forbid']</code> <p>Whether to allow extra fields when validating provided serialized schemas.</p> <code>'forbid'</code> <code>allow_partials</code> <code>bool</code> <p>Whether to allow partial resolutions.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>composer_model</code> <code>BaseResolutionTree</code> <p>A pydantic model that can be used to execute component mapping and composition.</p> Source code in <code>epinterface/sbem/components/composer.py</code> <pre><code>def construct_composer_model(  # noqa: C901\n    g: nx.DiGraph,\n    root_validator: type[NamedObject],\n    use_children: bool = True,\n    extra_handling: Literal[\"ignore\", \"forbid\"] = \"forbid\",\n    allow_partials: bool = True,\n):\n    \"\"\"Abstractly constructs a composition model from a graph of SBEM hierarchies.\n\n    The ComposerModel.get_component(x: dict) method can be used to generate a composition of SBEM\n    objects through the hierarchy, starting with the root node, and then substituting child nodes as they\n    become available.\n\n    Setting allow_partials to False will require a complete tree (but also use autopopulation) - this is mainly for easily generating schemas.\n\n    Args:\n        g (nx.DiGraph): The graph to construct the model from.\n        root_validator (type[NamedObject]): The root validator type.\n        use_children (bool): Whether to use `children` nesting keys (more verbose structure)\n        extra_handling (Literal[\"ignore\", \"forbid\"]): Whether to allow extra fields when validating provided serialized schemas.\n        allow_partials (bool): Whether to allow partial resolutions.\n\n    Returns:\n        composer_model (BaseResolutionTree): A pydantic model that can be used to execute component mapping and composition.\n    \"\"\"\n    from prisma import Prisma\n\n    from epinterface.sbem.prisma.client import deep_fetcher\n\n    # Cache to avoid recomputing the same field types - e.g. once\n    # we have computed the field type for a Occupancy.Schedule,\n    # we can immediately return it for Lighting.Schedule, Thermostat.HeatingSchedule, etc.\n    resolved_field_types = {}\n\n    def get_field_type_for_edge(\n        g: nx.DiGraph,\n        target_node_name: str,  # TODO: this will cause infinite recursion when a parent and child have named fields in common.\n        target_node_type: type[NamedObject],\n        use_children: bool,\n        allow_partials: bool,\n    ):\n        if target_node_type not in resolved_field_types:\n            resolved_field_types[target_node_type] = handle_node(\n                g,\n                target_node_name,\n                use_children,\n                target_node_type,\n                allow_partials=allow_partials,\n            )\n        return (\n            (resolved_field_types[target_node_type] | None, None)\n            if allow_partials\n            else (\n                resolved_field_types[target_node_type],\n                resolved_field_types[target_node_type](selector=None),\n            )\n        )\n\n    # TODO: figure out how to abstract this so that the root node type passed in can be used to\n    # give type safety assurances on the selector.get_component() method..\n    def handle_node(  # noqa: C901\n        g: nx.DiGraph,\n        node: str,\n        use_children: bool,\n        validator: type[NamedObject],\n        allow_partials: bool,\n    ):\n        edges_starting_at_node = g.edges(node, data=True)\n        node_fields = {}\n        for _parent_name, child_name, data in edges_starting_at_node:\n            node_fields[child_name] = get_field_type_for_edge(\n                g,\n                child_name,\n                data[\"data\"][\"type\"],\n                use_children=use_children,\n                allow_partials=allow_partials,\n            )\n        this_selector = (ComponentNameConstructor | None, None)\n\n        # TODO: lift some of this scope up so we don't have a bunch of classes which are not part of the same\n        # inheritance hierarchy.\n        class ResolutionTreeWithValidator(BaseResolutionTree, extra=extra_handling):\n            ValClass: ClassVar[type[NamedObject]] = validator\n            selector: ComponentNameConstructor | None\n\n            # TODO: we should allow fetching from in mem caches or other sources\n            # so that this becomes abstracted and decoupled from the\n            # database logic.\n            @classmethod\n            def get_deep_fetcher(cls):\n                \"\"\"Get the deep fetcher for the component corresponding to the selected validator.\"\"\"\n                return deep_fetcher.get_deep_fetcher(cls.ValClass)\n\n            @classmethod\n            def create_data_entry_template(cls):\n                g = construct_graph(cls.ValClass)\n                Model = construct_composer_model(\n                    g,\n                    root_validator=cls.ValClass,\n                    use_children=False,\n                    allow_partials=False,\n                )\n                model = Model(\n                    selector=ComponentNameConstructor(\n                        source_fields=[\"selector_col_a\", \"selector_col_b\"]\n                    )\n                )\n\n                return yaml.safe_dump(\n                    model.model_dump(\n                        exclude_none=True,\n                    ),\n                    indent=2,\n                )\n\n            def get_component(\n                self,\n                context: dict,\n                allow_unvalidated: bool = False,\n                db: Prisma | None = None,\n                do_validate_resolution: bool = True,\n            ):\n                \"\"\"Construct a component from the context dictionary, including executing subconstructions.\n\n                Args:\n                    context (dict): The context dictionary.\n                    allow_unvalidated (bool): Whether to allow unvalidated components during construction - necessary for partial overwrites.\n                    db (Prisma | None): The database to use.\n                    do_validate_resolution (bool): Whether to validate that the resolution is guaranteed to return a component (assuming no db calls fail).  We skip this on children since they are allowed to be partial.\n\n                Returns:\n                    component (NamedObject): The constructed component.\n                \"\"\"\n                self.validate_successful_resolution(do_validate_resolution)\n                component_name = (\n                    self.selector.construct_name(context)\n                    if self.selector is not None\n                    else None\n                )\n                children_components = {}\n                for field_name in self.model_dump():\n                    field_selector = getattr(self, field_name)\n                    if (\n                        # TODO: rewrite this check to use issubclass with BaseResolutionTree\n                        # but BaseResolutionTree will need updating so that it is generic enough to include get_component\n                        not isinstance(field_selector, ComponentNameConstructor)\n                        and field_selector is not None\n                    ):\n                        children_components[field_name] = field_selector.get_component(\n                            context=context,\n                            allow_unvalidated=True,\n                            db=db,\n                            do_validate_resolution=False,\n                        )\n\n                if component_name is None:\n                    component_name = f\"{self.ValClass.__name__}_{str(uuid.uuid4())[:8]}\"\n                    try:\n                        component = self.ValClass(\n                            Name=component_name, **children_components\n                        )\n                    except Exception:\n                        if allow_unvalidated:\n                            return {\"Name\": component_name, **children_components}\n                        else:\n                            raise\n                else:\n                    fetcher = self.get_deep_fetcher()\n                    _record, component_base = fetcher.get_deep_object(\n                        component_name, db=db\n                    )\n                    data = component_base.model_dump(exclude_none=True)\n\n                    recursive_tree_dict_merge(data, children_components)\n\n                    component = self.ValClass(**data)\n                return component\n\n            def validate_successful_resolution(\n                self, raise_on_failure: bool = True\n            ) -&gt; tuple[bool, list[str]]:\n                \"\"\"Validate that the tree will always resolve to a valid component.\n\n                This is true if either (a) the selector is not None, or (b) all of its (required) children's successfully resolve,\n                meaning we will use a recursive computation.\n\n\n                Note: special handling is not yet implemented for the case where a child is nullable.\n\n                Note: special handling will be required if/when non-deep keys (e.g. float params) become targetable.\n                \"\"\"\n                # Children can be incomplete if parent is not specified.\n                # so we circuit break if the parent has a selector.\n                if self.selector is not None:\n                    return True, []\n\n                children_to_check = [\n                    child for child in self.model_fields if child != \"selector\"\n                ]\n                if len(children_to_check) == 0:\n                    # We are at a leaf node, which is only valid if it has a selector.\n                    # TODO: in the future, leaf nodes could be constructed dynamically by assigning computers for field values.\n                    return False, [\"NoSelectorSpecified\"]\n                is_valid = True\n                errors = []\n                for child in children_to_check:\n                    child_selector = getattr(self, child)\n                    if child_selector is None:\n                        is_valid = False\n                        msg = f\"{child}:NoSelectorSpecified\"\n                        errors.append(msg)\n                        continue\n                    if not issubclass(child_selector.__class__, BaseResolutionTree):\n                        msg = f\"{child}:UnexpectedNonSelector[{type(child_selector)}]\"\n                        is_valid = False\n                        errors.append(msg)\n                        continue\n                    child_is_valid, child_errors = (\n                        child_selector.validate_successful_resolution(\n                            raise_on_failure=False\n                        )\n                    )\n                    is_valid = is_valid and child_is_valid\n                    errors.extend([f\"{child}:{error}\" for error in child_errors])\n\n                if raise_on_failure and not is_valid:\n                    raise ValueError(\"\\n\".join(errors))\n                return is_valid, errors\n\n        if use_children:\n            children_model = create_model(\n                f\"{node}Selector\",\n                **node_fields,\n            )\n\n            return create_model(\n                f\"{node}Selector\",\n                children=(children_model | None, None),\n                selector=this_selector,\n                __base__=ResolutionTreeWithValidator,\n            )\n        else:\n            # we want to add a classvar to the model which stores the validator\n\n            return create_model(\n                f\"{node}Selector\",\n                **node_fields,\n                selector=this_selector,\n                __base__=ResolutionTreeWithValidator,\n            )\n\n    return handle_node(\n        g,\n        \"root\",\n        use_children=use_children,\n        validator=root_validator,\n        allow_partials=allow_partials,\n    )\n</code></pre>"},{"location":"modules/sbem/composer/#epinterface.sbem.components.composer.construct_graph","title":"<code>construct_graph(root_node)</code>","text":"<p>Construct a graph of the SBEM objects.</p> <p>Nodes are fields of of SBEM NamedObjects, with edges representing the type of the child field as stored in the parent field.</p> <p>It begins with checking the root node's fields, then recurses into the child fields which are also NamedObjects.</p> <p>Note that currently, lists/dicts/tuples of NamedObjects are not supported.</p> <p>Parameters:</p> Name Type Description Default <code>root_node</code> <code>type[NamedObject]</code> <p>The root node of the graph.</p> required <p>Returns:</p> Name Type Description <code>graph</code> <code>DiGraph</code> <p>A graph of the SBEM objects.</p> Source code in <code>epinterface/sbem/components/composer.py</code> <pre><code>def construct_graph(root_node: type[NamedObject]):\n    \"\"\"Construct a graph of the SBEM objects.\n\n    Nodes are fields of of SBEM NamedObjects, with edges representing the type of the child field as stored in the parent field.\n\n    It begins with checking the root node's fields, then recurses into the child fields which are also NamedObjects.\n\n    Note that currently, lists/dicts/tuples of NamedObjects are not supported.\n\n    Args:\n        root_node (type[NamedObject]): The root node of the graph.\n\n    Returns:\n        graph (nx.DiGraph): A graph of the SBEM objects.\n    \"\"\"\n    g = nx.DiGraph()\n\n    def handle_obj_class(g: nx.DiGraph, field_name: str, obj_class: type[NamedObject]):\n        for child_field_name, child_annotation in obj_class.__annotations__.items():\n            if isinstance(child_annotation, NamedObject.__class__) and issubclass(\n                child_annotation, NamedObject\n            ):\n                g.add_edge(\n                    field_name, child_field_name, data={\"type\": child_annotation}\n                )\n                handle_obj_class(g, child_field_name, child_annotation)\n\n            elif hasattr(\n                child_annotation, \"__args__\"\n            ):  # but if it's a list, we want to skip\n                if get_origin(child_annotation) in [list, tuple, dict]:\n                    # TODO: special handling for list/dict cases using an additional entry in the edge data.\n                    continue\n                for note in child_annotation.__args__:\n                    if isinstance(note, NamedObject.__class__) and issubclass(\n                        note, NamedObject\n                    ):\n                        g.add_edge(field_name, child_field_name, data={\"type\": note})\n                        handle_obj_class(g, child_field_name, note)\n                        break\n\n    handle_obj_class(g, \"root\", root_node)\n    return g\n</code></pre>"},{"location":"modules/sbem/composer/#epinterface.sbem.components.composer.recursive_tree_dict_merge","title":"<code>recursive_tree_dict_merge(d1, d2)</code>","text":"<p>Merge two dictionaries recursively.</p> <p>The behavior is as follows: - Every key/tree in d2 is merged into d1. - If a key is found in both dictionaries, the value from d2 is used. - If a key is found in d1 but not in d2, the value from d1 is used. - If a key is found in d2 but not in d1, the value from d2 is used.</p> <p>Parameters:</p> Name Type Description Default <code>d1</code> <code>dict</code> <p>The base dictionary.</p> required <code>d2</code> <code>dict</code> <p>The dictionary to merge.</p> required Source code in <code>epinterface/sbem/components/composer.py</code> <pre><code>def recursive_tree_dict_merge(d1: dict, d2: dict):\n    \"\"\"Merge two dictionaries recursively.\n\n    The behavior is as follows:\n    - Every key/tree in d2 is merged into d1.\n    - If a key is found in both dictionaries, the value from d2 is used.\n    - If a key is found in d1 but not in d2, the value from d1 is used.\n    - If a key is found in d2 but not in d1, the value from d2 is used.\n\n    Args:\n        d1 (dict): The base dictionary.\n        d2 (dict): The dictionary to merge.\n    \"\"\"\n    for key, value in d2.items():\n        if key not in d1:\n            msg = f\"{key} is not in the d1 target dictionary.\"\n            raise ValueError(msg)\n        if isinstance(value, dict):\n            if not isinstance(d1[key], dict) and d1[key] is not None:\n                msg = f\"{key} is not a dict in the d1 target dictionary.\"\n                raise ValueError(msg)\n            recursive_tree_dict_merge(d1[key], value)\n        else:\n            d1[key] = value\n</code></pre>"}]}