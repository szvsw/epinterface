"""Decision DAG schema -- the structured output produced by the LLM.

Defines the node types, intermediate components, and the top-level
DecisionDAG model that represents the complete mapping from user
data fields to FlatModel parameters.
"""

from __future__ import annotations

from enum import Enum
from typing import Annotated, Any, Literal

from pydantic import BaseModel, Field


class ComparisonOperator(str, Enum):
    """Operators for evaluating conditions against a user data row."""

    EQ = "eq"
    NEQ = "neq"
    LT = "lt"
    LTE = "lte"
    GT = "gt"
    GTE = "gte"
    IN = "in"
    NOT_IN = "not_in"
    CONTAINS = "contains"
    IS_MISSING = "is_missing"
    IS_NOT_MISSING = "is_not_missing"


class FieldCondition(BaseModel):
    """A condition that evaluates a user data field against a value."""

    field: str = Field(description="Name of the user data field to evaluate.")
    operator: ComparisonOperator = Field(description="Comparison operator to apply.")
    value: Any = Field(
        default=None,
        description="Comparison value (not needed for is_missing/is_not_missing).",
    )


class ConditionalBranch(BaseModel):
    """A branch in a condition node: a condition paired with a target node."""

    condition: FieldCondition = Field(description="The condition to evaluate.")
    target_node_id: str = Field(
        description="ID of the node to visit if condition is true."
    )


class ConditionNode(BaseModel):
    """A node that branches based on evaluating conditions against a user data row.

    Branches are evaluated in order; the first matching branch is followed.
    If no branch matches, the default_target_id is followed (if set).
    """

    node_type: Literal["condition"] = "condition"
    id: str = Field(description="Unique identifier for this node.")
    description: str = Field(
        description="Human-readable description of what this node decides."
    )
    branches: list[ConditionalBranch] = Field(
        description="Ordered list of conditional branches."
    )
    default_target_id: str | None = Field(
        default=None,
        description="Fallback node ID if no branch condition matches.",
    )


class AssignmentNode(BaseModel):
    """A node that directly assigns values to FlatModel parameters.

    Can chain to further nodes via next_node_ids for sequential processing.
    """

    node_type: Literal["assignment"] = "assignment"
    id: str = Field(description="Unique identifier for this node.")
    description: str = Field(
        description="Human-readable description of what this assignment represents."
    )
    assignments: dict[str, Any] = Field(
        description="Mapping of FlatModel field names to values."
    )
    next_node_ids: list[str] = Field(
        default_factory=list,
        description="Node IDs to visit after this assignment.",
    )


class ComponentRefNode(BaseModel):
    """A node that references a named IntermediateComponent.

    Applies all of the component's assignments, then optionally
    continues to further nodes. This enables reusable parameter
    bundles like 'high performance single family wall'.
    """

    node_type: Literal["component_ref"] = "component_ref"
    id: str = Field(description="Unique identifier for this node.")
    description: str = Field(
        description="Human-readable description of why this component is applied."
    )
    component_id: str = Field(description="ID of the IntermediateComponent to apply.")
    next_node_ids: list[str] = Field(
        default_factory=list,
        description="Node IDs to visit after applying the component.",
    )


class IntermediateComponent(BaseModel):
    """A named, reusable bundle of FlatModel parameter assignments.

    Intermediate components represent archetypal building subsystems
    (e.g. 'Old Leaky SF Wall', 'High Efficiency Heat Pump') that
    set multiple parameters at once.
    """

    id: str = Field(description="Unique identifier for this component.")
    name: str = Field(
        description="Human-readable name (e.g. 'High Performance SF Wall')."
    )
    description: str = Field(
        description="Description of what this component represents and its assumptions."
    )
    assignments: dict[str, Any] = Field(
        description="Mapping of FlatModel field names to values."
    )


DAGNode = Annotated[
    ConditionNode | AssignmentNode | ComponentRefNode,
    Field(discriminator="node_type"),
]
"""Discriminated union of all node types in the decision DAG."""


class DecisionDAG(BaseModel):
    """The complete decision DAG that maps user data fields to FlatModel parameters.

    Generated by the LLM based on the user's field definitions and
    supplementary context. Contains reusable intermediate components,
    a graph of decision/assignment nodes, and entry point(s).
    """

    description: str = Field(
        description="Summary of the DAG's overall logic and reasoning."
    )
    components: list[IntermediateComponent] = Field(
        default_factory=list,
        description="Reusable intermediate components referenced by ComponentRefNodes.",
    )
    nodes: list[DAGNode] = Field(description="All nodes in the decision graph.")
    entry_node_ids: list[str] = Field(
        description="IDs of root nodes where DAG execution begins. Multiple entries allow independent sub-DAGs for orthogonal parameter groups.",
    )
